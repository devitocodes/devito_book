

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>1. Simulation of waves on a string &#8212; The Devito Book</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="../../_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/jupyter-sphinx.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/sphinx-book-theme.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/mystnb.js"></script>
    <script src="../../_static/sphinx-book-theme.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="prev" title="Welcome to the Devito Book!" href="../../index.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../../index.html">
  
  <img src="../../_static/devito_logo.png" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">The Devito Book</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../../index.html">
   Welcome to the Devito Book!
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Wave equations
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   1. Simulation of waves on a string
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="#verification">
   2. Verification
  </a>
 </li>
</ul>

</nav>

 <!-- To handle the deprecated key -->

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    
    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/notebooks/wave/wave1D_fd1.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
    
</div>
        <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/devitocodes/devito_book"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        
        
    </div>
</div>


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#discretizing-the-domain">
   1.1. Discretizing the domain
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#uniform-meshes">
     1.1.1. Uniform meshes
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-discrete-solution">
   1.2. The discrete solution
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#fulfilling-the-equation-at-the-mesh-points">
   1.3. Fulfilling the equation at the mesh points
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#replacing-derivatives-by-finite-differences">
   1.4. Replacing derivatives by finite differences
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#algebraic-version-of-the-pde">
     1.4.1. Algebraic version of the PDE
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#interpretation-of-the-equation-as-a-stencil">
     1.4.2. Interpretation of the equation as a stencil
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#algebraic-version-of-the-initial-conditions">
     1.4.3. Algebraic version of the initial conditions
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#formulating-a-recursive-algorithm">
   1.5. Formulating a recursive algorithm
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#sketch-of-an-implementation">
   1.6. Sketch of an implementation
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#devito-implementation">
     1.6.1. Devito implementation
    </a>
   </li>
  </ul>
 </li>
</ul>

        </nav>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <p>A very wide range of physical processes lead to wave motion, where
signals are propagated through a medium in space and time, normally
with little or no permanent movement of the medium itself.
The shape of the signals may undergo changes as they travel through
matter, but usually not so much that the signals cannot be recognized
at some later point in space and time.
Many types of wave motion can be described by the equation
<span class="math notranslate nohighlight">\(u_{tt}=\nabla\cdot (c^2\nabla u) + f\)</span>, which we will solve
in the forthcoming text by finite difference methods.</p>
<div class="section" id="simulation-of-waves-on-a-string">
<h1><span class="section-number">1. </span>Simulation of waves on a string<a class="headerlink" href="#simulation-of-waves-on-a-string" title="Permalink to this headline">¶</a></h1>
<div id="wave:string"></div>
<p>We begin our study of wave equations by simulating one-dimensional
waves on a string, say on a guitar or violin.
Let the string in the undeformed state
coincide with the interval
<span class="math notranslate nohighlight">\([0,L]\)</span> on the <span class="math notranslate nohighlight">\(x\)</span> axis, and let <span class="math notranslate nohighlight">\(u(x,t)\)</span> be the displacement at
time <span class="math notranslate nohighlight">\(t\)</span> in the <span class="math notranslate nohighlight">\(y\)</span> direction of a point initially at <span class="math notranslate nohighlight">\(x\)</span>.
The displacement function <span class="math notranslate nohighlight">\(u\)</span> is governed by the mathematical model</p>
<!-- Equation labels as ordinary links -->
<div id="wave:pde1"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\frac{\partial^2 u}{\partial t^2} =
c^2 \frac{\partial^2 u}{\partial x^2}, \quad x\in (0,L),\ t\in (0,T]
\label{wave:pde1} \tag{1}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="wave:pde1:ic:u"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
u(x,0) = I(x), \quad x\in [0,L]
\label{wave:pde1:ic:u} \tag{2}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="wave:pde1:ic:ut"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
\frac{\partial}{\partial t}u(x,0) = 0, \quad x\in [0,L]
\label{wave:pde1:ic:ut} \tag{3}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="wave:pde1:bc:0"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
u(0,t)  = 0, \quad  t\in (0,T]
\label{wave:pde1:bc:0} \tag{4}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="wave:pde1:bc:L"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
u(L,t)  = 0, \quad  t\in (0,T]
\label{wave:pde1:bc:L} \tag{5}
\end{equation}
\]</div>
<p>The constant <span class="math notranslate nohighlight">\(c\)</span> and the function <span class="math notranslate nohighlight">\(I(x)\)</span> must be prescribed.</p>
<p>Equation (<a class="reference external" href="#wave:pde1">1</a>) is known as the one-dimensional
<em>wave equation</em>. Since this PDE contains a second-order derivative
in time, we need <em>two initial conditions</em>. The condition
(<a class="reference external" href="#wave:pde1:ic:u">2</a>) specifies
the initial shape of the string, <span class="math notranslate nohighlight">\(I(x)\)</span>, and
(<a class="reference external" href="#wave:pde1:ic:ut">3</a>) expresses that the initial velocity of the
string is zero. In addition, PDEs need <em>boundary conditions</em>, given here as
(<a class="reference external" href="#wave:pde1:bc:0">4</a>) and (<a class="reference external" href="#wave:pde1:bc:L">5</a>). These two
conditions specify that
the string is fixed at the ends, i.e., that the displacement <span class="math notranslate nohighlight">\(u\)</span> is zero.</p>
<p>The solution <span class="math notranslate nohighlight">\(u(x,t)\)</span> varies in space and time and describes waves that
move with velocity <span class="math notranslate nohighlight">\(c\)</span> to the left and right.</p>
<p>Sometimes we will use a more compact notation for the partial derivatives
to save space:</p>
<!-- Equation labels as ordinary links -->
<div id="_auto1"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u_t = \frac{\partial u}{\partial t}, \quad
u_{tt} = \frac{\partial^2 u}{\partial t^2},
\label{_auto1} \tag{6}
\end{equation}
\]</div>
<p>and similar expressions
for derivatives with respect to other variables. Then the
wave equation can be written compactly as <span class="math notranslate nohighlight">\(u_{tt} = c^2u_{xx}\)</span>.</p>
<p>The PDE problem (<a class="reference external" href="#wave:pde1">1</a>)-(<a class="reference external" href="#wave:pde1:bc:L">5</a>) will now be
discretized in space and time by a finite difference method.</p>
<div class="section" id="discretizing-the-domain">
<h2><span class="section-number">1.1. </span>Discretizing the domain<a class="headerlink" href="#discretizing-the-domain" title="Permalink to this headline">¶</a></h2>
<div id="wave:string:mesh"></div>
<p>The temporal domain <span class="math notranslate nohighlight">\([0,T]\)</span> is represented by a finite number of mesh points</p>
<!-- Equation labels as ordinary links -->
<div id="_auto2"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
0 = t_0 &lt; t_1 &lt; t_2 &lt; \cdots &lt; t_{N_t-1} &lt; t_{N_t} = T    \label{_auto2} \tag{7}
\end{equation}
\]</div>
<p>Similarly, the spatial domain <span class="math notranslate nohighlight">\([0,L]\)</span> is replaced by a set of mesh points</p>
<!-- Equation labels as ordinary links -->
<div id="_auto3"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
0 = x_0 &lt; x_1 &lt; x_2 &lt; \cdots &lt; x_{N_x-1} &lt; x_{N_x} = L   \label{_auto3} \tag{8}
\end{equation}
\]</div>
<p>One may view the mesh as two-dimensional in the <span class="math notranslate nohighlight">\(x,t\)</span> plane, consisting
of points <span class="math notranslate nohighlight">\((x_i, t_n)\)</span>, with <span class="math notranslate nohighlight">\(i=0,\ldots,N_x\)</span> and <span class="math notranslate nohighlight">\(n=0,\ldots,N_t\)</span>.</p>
<div class="section" id="uniform-meshes">
<h3><span class="section-number">1.1.1. </span>Uniform meshes<a class="headerlink" href="#uniform-meshes" title="Permalink to this headline">¶</a></h3>
<p>For uniformly distributed mesh points we can introduce the constant
mesh spacings <span class="math notranslate nohighlight">\(\Delta t\)</span> and <span class="math notranslate nohighlight">\(\Delta x\)</span>. We have that</p>
<!-- Equation labels as ordinary links -->
<div id="_auto4"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
x_i = i\Delta x,\ i=0,\ldots,N_x,\quad
t_n = n\Delta t,\ n=0,\ldots,N_t
\label{_auto4} \tag{9}
\end{equation}
\]</div>
<p>We also have that <span class="math notranslate nohighlight">\(\Delta x = x_i-x_{i-1}\)</span>, <span class="math notranslate nohighlight">\(i=1,\ldots,N_x\)</span>, and
<span class="math notranslate nohighlight">\(\Delta t = t_n - t_{n-1}\)</span>, <span class="math notranslate nohighlight">\(n=1,\ldots,N_t\)</span>. <a class="reference external" href="#wave:pde1:fig:mesh">Figure</a>
displays a mesh in the <span class="math notranslate nohighlight">\(x,t\)</span> plane with <span class="math notranslate nohighlight">\(N_t=5\)</span>, <span class="math notranslate nohighlight">\(N_x=5\)</span>, and constant
mesh spacings.</p>
</div>
</div>
<div class="section" id="the-discrete-solution">
<h2><span class="section-number">1.2. </span>The discrete solution<a class="headerlink" href="#the-discrete-solution" title="Permalink to this headline">¶</a></h2>
<div id="wave:string:numerical:sol"></div>
<p>The solution <span class="math notranslate nohighlight">\(u(x,t)\)</span> is sought at the mesh points. We introduce
the mesh function <span class="math notranslate nohighlight">\(u_i^n\)</span>, which approximates the exact
solution at the
mesh point <span class="math notranslate nohighlight">\((x_i,t_n)\)</span> for <span class="math notranslate nohighlight">\(i=0,\ldots,N_x\)</span> and <span class="math notranslate nohighlight">\(n=0,\ldots,N_t\)</span>.
Using the finite difference method, we shall
develop algebraic equations for computing the mesh function.</p>
</div>
<div class="section" id="fulfilling-the-equation-at-the-mesh-points">
<h2><span class="section-number">1.3. </span>Fulfilling the equation at the mesh points<a class="headerlink" href="#fulfilling-the-equation-at-the-mesh-points" title="Permalink to this headline">¶</a></h2>
<div id="wave:string:samplingPDE"></div>
<p>In the finite difference method, we relax
the condition that (<a class="reference external" href="#wave:pde1">1</a>) holds at all points in
the space-time domain <span class="math notranslate nohighlight">\((0,L)\times (0,T]\)</span> to the requirement that the PDE is
fulfilled at the <em>interior</em> mesh points only:</p>
<!-- Equation labels as ordinary links -->
<div id="wave:pde1:step2"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\frac{\partial^2}{\partial t^2} u(x_i, t_n) =
c^2\frac{\partial^2}{\partial x^2} u(x_i, t_n),
\label{wave:pde1:step2} \tag{10}
\end{equation}
\]</div>
<p>for <span class="math notranslate nohighlight">\(i=1,\ldots,N_x-1\)</span> and <span class="math notranslate nohighlight">\(n=1,\ldots,N_t-1\)</span>. For <span class="math notranslate nohighlight">\(n=0\)</span> we have
the initial conditions <span class="math notranslate nohighlight">\(u=I(x)\)</span> and <span class="math notranslate nohighlight">\(u_t=0\)</span>,
and at the boundaries <span class="math notranslate nohighlight">\(i=0,N_x\)</span> we
have the boundary condition <span class="math notranslate nohighlight">\(u=0\)</span>.</p>
</div>
<div class="section" id="replacing-derivatives-by-finite-differences">
<h2><span class="section-number">1.4. </span>Replacing derivatives by finite differences<a class="headerlink" href="#replacing-derivatives-by-finite-differences" title="Permalink to this headline">¶</a></h2>
<div id="wave:string:fd"></div>
<p>The second-order derivatives can be replaced by central
differences. The most widely used difference approximation of
the second-order derivative is</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial^2}{\partial t^2}u(x_i,t_n)\approx
\frac{u_i^{n+1} - 2u_i^n + u^{n-1}_i}{\Delta t^2}\
\]</div>
<p>It is convenient to introduce the finite difference operator notation</p>
<div class="math notranslate nohighlight">
\[
[D_tD_t u]^n_i = \frac{u_i^{n+1} - 2u_i^n + u^{n-1}_i}{\Delta t^2}
\]</div>
<p>A similar approximation of the second-order derivative in the <span class="math notranslate nohighlight">\(x\)</span>
direction reads</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial^2}{\partial x^2}u(x_i,t_n)\approx
\frac{u_{i+1}^{n} - 2u_i^n + u^{n}_{i-1}}{\Delta x^2} = [D_xD_x u]^n_i
\]</div>
<div class="section" id="algebraic-version-of-the-pde">
<h3><span class="section-number">1.4.1. </span>Algebraic version of the PDE<a class="headerlink" href="#algebraic-version-of-the-pde" title="Permalink to this headline">¶</a></h3>
<p>We can now replace the derivatives in (<a class="reference external" href="#wave:pde1:step2">10</a>)
and get</p>
<!-- Equation labels as ordinary links -->
<div id="wave:pde1:step3b"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\frac{u_i^{n+1} - 2u_i^n + u^{n-1}_i}{\Delta t^2} =
c^2\frac{u_{i+1}^{n} - 2u_i^n + u^{n}_{i-1}}{\Delta x^2},
\label{wave:pde1:step3b} \tag{11}
\end{equation}
\]</div>
<p>or written more compactly using the operator notation:</p>
<!-- Equation labels as ordinary links -->
<div id="wave:pde1:step3a"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
[D_tD_t u = c^2 D_xD_x]^{n}_i
\label{wave:pde1:step3a} \tag{12}
\end{equation}
\]</div>
</div>
<div class="section" id="interpretation-of-the-equation-as-a-stencil">
<h3><span class="section-number">1.4.2. </span>Interpretation of the equation as a stencil<a class="headerlink" href="#interpretation-of-the-equation-as-a-stencil" title="Permalink to this headline">¶</a></h3>
<p>A characteristic feature of (<a class="reference external" href="#wave:pde1:step3b">11</a>) is that it
involves <span class="math notranslate nohighlight">\(u\)</span> values from neighboring points only: <span class="math notranslate nohighlight">\(u_i^{n+1}\)</span>,
<span class="math notranslate nohighlight">\(u^n_{i\pm 1}\)</span>, <span class="math notranslate nohighlight">\(u^n_i\)</span>, and <span class="math notranslate nohighlight">\(u^{n-1}_i\)</span>.  The circles in <a class="reference external" href="#wave:pde1:fig:mesh">Figure</a> illustrate such neighboring mesh points that
contribute to an algebraic equation. In this particular case, we have
sampled the PDE at the point <span class="math notranslate nohighlight">\((2,2)\)</span> and constructed
(<a class="reference external" href="#wave:pde1:step3b">11</a>), which then involves a coupling of <span class="math notranslate nohighlight">\(u_1^2\)</span>,
<span class="math notranslate nohighlight">\(u_2^3\)</span>, <span class="math notranslate nohighlight">\(u_2^2\)</span>, <span class="math notranslate nohighlight">\(u_2^1\)</span>, and <span class="math notranslate nohighlight">\(u_3^2\)</span>.  The term <em>stencil</em> is often
used about the algebraic equation at a mesh point, and the geometry of
a typical stencil is illustrated in <a class="reference external" href="#wave:pde1:fig:mesh">Figure</a>. One also often refers to the algebraic
equations as <em>discrete equations</em>, <em>(finite) difference equations</em> or
a <em>finite difference scheme</em>.</p>
<!-- dom:FIGURE: [mov-wave/D_stencil_gpl/stencil_n_interior.png, width=500] Mesh in space and time. The circles show points connected in a finite difference equation. <div id="wave:pde1:fig:mesh"></div> -->
<!-- begin figure -->
<div id="wave:pde1:fig:mesh"></div>
<!-- 
<p>Mesh in space and time. The circles show points connected in a finite difference equation.</p>
<img src="mov-wave/D_stencil_gpl/stencil_n_interior.png" width=500> -->
<div class="figure align-default" id="wave-pde1-fig-mesh">
<img alt="../../_images/stencil_n_interior.png" src="../../_images/stencil_n_interior.png" />
<p class="caption"><span class="caption-number">Fig. 1.1 </span><span class="caption-text">Mesh in space and time. The circles show points connected in a finite difference equation.</span><a class="headerlink" href="#wave-pde1-fig-mesh" title="Permalink to this image">¶</a></p>
</div>
<!-- end figure -->
</div>
<div class="section" id="algebraic-version-of-the-initial-conditions">
<h3><span class="section-number">1.4.3. </span>Algebraic version of the initial conditions<a class="headerlink" href="#algebraic-version-of-the-initial-conditions" title="Permalink to this headline">¶</a></h3>
<p>We also need to replace the derivative in the initial condition
(<a class="reference external" href="#wave:pde1:ic:ut">3</a>) by a finite difference approximation.
A centered difference of the type</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial}{\partial t} u(x_i,t_0)\approx
\frac{u^1_i - u^{-1}_i}{2\Delta t} = [D_{2t} u]^0_i,
\]</div>
<p>seems appropriate. Writing out this equation and ordering the terms give</p>
<!-- Equation labels as ordinary links -->
<div id="wave:pde1:step3c"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u^{-1}_i=u^{1}_i,\quad i=0,\ldots,N_x
\label{wave:pde1:step3c} \tag{13}
\end{equation}
\]</div>
<p>The other initial condition can be computed by</p>
<div class="math notranslate nohighlight">
\[
u_i^0 = I(x_i),\quad i=0,\ldots,N_x
\]</div>
</div>
</div>
<div class="section" id="formulating-a-recursive-algorithm">
<h2><span class="section-number">1.5. </span>Formulating a recursive algorithm<a class="headerlink" href="#formulating-a-recursive-algorithm" title="Permalink to this headline">¶</a></h2>
<div id="wave:string:alg"></div>
<p>We assume that <span class="math notranslate nohighlight">\(u^n_i\)</span> and <span class="math notranslate nohighlight">\(u^{n-1}_i\)</span> are available for
<span class="math notranslate nohighlight">\(i=0,\ldots,N_x\)</span>.  The only unknown quantity in
(<a class="reference external" href="#wave:pde1:step3b">11</a>) is therefore <span class="math notranslate nohighlight">\(u^{n+1}_i\)</span>, which we now can
solve for:</p>
<!-- Equation labels as ordinary links -->
<div id="wave:pde1:step4"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u^{n+1}_i = -u^{n-1}_i + 2u^n_i + C^2
\left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right)
\label{wave:pde1:step4} \tag{14}
\end{equation}
\]</div>
<p>We have here introduced the parameter</p>
<!-- Equation labels as ordinary links -->
<div id="_auto5"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
C = c\frac{\Delta t}{\Delta x},
\label{_auto5} \tag{15}
\end{equation}
\]</div>
<p>known as the <em>Courant number</em>.</p>
<p><strong><span class="math notranslate nohighlight">\(C\)</span> is the key parameter in the discrete wave equation.</strong></p>
<p>We see that the discrete version of the PDE features only one
parameter, <span class="math notranslate nohighlight">\(C\)</span>, which is therefore the key parameter, together with
<span class="math notranslate nohighlight">\(N_x\)</span>, that governs the quality of the numerical solution (see the section <a class="reference external" href="#wave:pde1:analysis">wave:pde1:analysis</a> for details). Both the primary physical
parameter <span class="math notranslate nohighlight">\(c\)</span> and the numerical parameters <span class="math notranslate nohighlight">\(\Delta x\)</span> and <span class="math notranslate nohighlight">\(\Delta t\)</span>
are lumped together in <span class="math notranslate nohighlight">\(C\)</span>. Note that <span class="math notranslate nohighlight">\(C\)</span> is a dimensionless
parameter.</p>
<p>Given that <span class="math notranslate nohighlight">\(u^{n-1}_i\)</span> and <span class="math notranslate nohighlight">\(u^n_i\)</span> are known for <span class="math notranslate nohighlight">\(i=0,\ldots,N_x\)</span>,
we find new values at the next time level by applying the formula
(<a class="reference external" href="#wave:pde1:step4">14</a>) for <span class="math notranslate nohighlight">\(i=1,\ldots,N_x-1\)</span>. <a class="reference external" href="#wave:pde1:fig:mesh">Figure</a> illustrates the points that are used to
compute <span class="math notranslate nohighlight">\(u^3_2\)</span>. For the boundary points, <span class="math notranslate nohighlight">\(i=0\)</span> and <span class="math notranslate nohighlight">\(i=N_x\)</span>, we apply
the boundary conditions <span class="math notranslate nohighlight">\(u_i^{n+1}=0\)</span>.</p>
<p>Even though sound reasoning leads up to
(<a class="reference external" href="#wave:pde1:step4">14</a>), there is still a minor challenge with it that needs
to be resolved. Think of the very first computational step to be made.
The scheme (<a class="reference external" href="#wave:pde1:step4">14</a>) is supposed to start at <span class="math notranslate nohighlight">\(n=1\)</span>, which means
that we compute <span class="math notranslate nohighlight">\(u^2\)</span> from <span class="math notranslate nohighlight">\(u^1\)</span> and <span class="math notranslate nohighlight">\(u^0\)</span>. Unfortunately, we do not know the
value of <span class="math notranslate nohighlight">\(u^1\)</span>, so how to proceed? A standard procedure in such cases is to
apply (<a class="reference external" href="#wave:pde1:step4">14</a>) also for <span class="math notranslate nohighlight">\(n=0\)</span>. This immediately seems strange,
since it involves <span class="math notranslate nohighlight">\(u^{-1}_i\)</span>, which is an undefined
quantity outside the time mesh (and the time domain). However, we can
use the initial condition (<a class="reference external" href="#wave:pde1:step3c">13</a>) in combination with
(<a class="reference external" href="#wave:pde1:step4">14</a>) when <span class="math notranslate nohighlight">\(n=0\)</span> to eliminate <span class="math notranslate nohighlight">\(u^{-1}_i\)</span> and
arrive at a special formula for <span class="math notranslate nohighlight">\(u_i^1\)</span>:</p>
<!-- Equation labels as ordinary links -->
<div id="wave:pde1:step4:1"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u_i^1 = u^0_i - \frac{1}{2}
C^2\left(u^{0}_{i+1}-2u^{0}_{i} + u^{0}_{i-1}\right)
\label{wave:pde1:step4:1} \tag{16}
\end{equation}
\]</div>
<p><a class="reference external" href="#wave:pde1:fig:stencil:u1">Figure</a> illustrates how (<a class="reference external" href="#wave:pde1:step4:1">16</a>)
connects four instead of five points: <span class="math notranslate nohighlight">\(u^1_2\)</span>, <span class="math notranslate nohighlight">\(u_1^0\)</span>, <span class="math notranslate nohighlight">\(u_2^0\)</span>, and <span class="math notranslate nohighlight">\(u_3^0\)</span>.</p>
<!-- dom:FIGURE: [mov-wave/D_stencil_gpl/stencil_n0_interior.png, width=500] Modified stencil for the first time step. <div id="wave:pde1:fig:stencil:u1"></div> -->
<!-- begin figure -->
<div id="wave:pde1:fig:stencil:u1"></div>
<!-- <p>Modified stencil for the first time step.</p>
<img src="./notebooks/02_wave/mov-wave/D_stencil_gpl/stencil_n0_interior.png" width=500> -->
<div class="figure align-default" id="wave-pde1-fig-stencil-u1">
<img alt="../../_images/stencil_n0_interior.png" src="../../_images/stencil_n0_interior.png" />
<p class="caption"><span class="caption-number">Fig. 1.2 </span><span class="caption-text">Modified stencil for the first time step.</span><a class="headerlink" href="#wave-pde1-fig-stencil-u1" title="Permalink to this image">¶</a></p>
</div>
<!-- end figure -->
<p>We can now summarize the computational algorithm:</p>
<ol>
<li><p>Compute <span class="math notranslate nohighlight">\(u^0_i=I(x_i)\)</span> for <span class="math notranslate nohighlight">\(i=0,\ldots,N_x\)</span></p></li>
<li><p>Compute <span class="math notranslate nohighlight">\(u^1_i\)</span> by (<a class="reference external" href="#wave:pde1:step4:1">16</a>) for <span class="math notranslate nohighlight">\(i=1,2,\ldots,N_x-1\)</span> and set <span class="math notranslate nohighlight">\(u_i^1=0\)</span>
for the boundary points given by <span class="math notranslate nohighlight">\(i=0\)</span> and <span class="math notranslate nohighlight">\(i=N_x\)</span>,</p></li>
<li><p>For each time level <span class="math notranslate nohighlight">\(n=1,2,\ldots,N_t-1\)</span></p>
<p>a. apply (<a class="reference external" href="#wave:pde1:step4">14</a>) to find <span class="math notranslate nohighlight">\(u^{n+1}_i\)</span> for <span class="math notranslate nohighlight">\(i=1,\ldots,N_x-1\)</span></p>
<p>b. set <span class="math notranslate nohighlight">\(u^{n+1}_i=0\)</span> for the boundary points having <span class="math notranslate nohighlight">\(i=0\)</span>, <span class="math notranslate nohighlight">\(i=N_x\)</span>.</p>
</li>
</ol>
<p>The algorithm essentially consists of moving a finite difference
stencil through all the mesh points, which can be seen as an animation
in a <span class="xref myst">web page</span>
or a <span class="xref myst">movie file</span>.</p>
</div>
<div class="section" id="sketch-of-an-implementation">
<h2><span class="section-number">1.6. </span>Sketch of an implementation<a class="headerlink" href="#sketch-of-an-implementation" title="Permalink to this headline">¶</a></h2>
<div id="wave:string:impl"></div>
<p>The algorithm only involves the three most recent time levels, so we
need only three arrays for <span class="math notranslate nohighlight">\(u_i^{n+1}\)</span>, <span class="math notranslate nohighlight">\(u_i^n\)</span>, and <span class="math notranslate nohighlight">\(u_i^{n-1}\)</span>,
<span class="math notranslate nohighlight">\(i=0,\ldots,N_x\)</span>.  Storing all the solutions in a two-dimensional
array of size <span class="math notranslate nohighlight">\((N_x+1)\times (N_t+1)\)</span> would be possible in this simple
one-dimensional PDE problem, but is normally out of the question in
three-dimensional (3D) and large two-dimensional (2D) problems. We
shall therefore, in all our PDE solving programs, have the unknown in
memory at as few time levels as possible.</p>
<p>In a Python implementation of this algorithm, we use the array
elements <code class="docutils literal notranslate"><span class="pre">u[i]</span></code> to store <span class="math notranslate nohighlight">\(u^{n+1}_i\)</span>, <code class="docutils literal notranslate"><span class="pre">u_n[i]</span></code> to store <span class="math notranslate nohighlight">\(u^n_i\)</span>, and
<code class="docutils literal notranslate"><span class="pre">u_nm1[i]</span></code> to store <span class="math notranslate nohighlight">\(u^{n-1}_i\)</span>.</p>
<p>The following Python snippet realizes the steps in the computational
algorithm.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Given mesh points as arrays x and t (x[i], t[n]),</span>
<span class="c1"># constant c and function I for initial condition</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">41</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">I</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>

<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">dx</span>            <span class="c1"># Courant number</span>
<span class="n">Nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
<span class="n">C2</span> <span class="o">=</span> <span class="n">C</span><span class="o">**</span><span class="mi">2</span>              <span class="c1"># Help variable in the scheme</span>

<span class="c1"># Initialise arrays</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u_nm1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>


<span class="c1"># Set initial condition u(x,0) = I(x)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="c1"># Apply special formula for first step, incorporating du/dt=0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> \
           <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">C2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c1"># Enforce boundary conditions</span>

<span class="c1"># Switch variables before next step</span>
<span class="n">u_nm1</span><span class="p">[:],</span> <span class="n">u_n</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u_n</span><span class="p">,</span> <span class="n">u</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
    <span class="c1"># Update all inner mesh points at time t[n+1]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_nm1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> \
               <span class="p">(</span><span class="n">C2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Insert boundary conditions</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Switch variables before next step</span>
    <span class="n">u_nm1</span><span class="p">[:],</span> <span class="n">u_n</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u_n</span><span class="p">,</span> <span class="n">u</span>
        

<span class="c1"># print(wave_1D_solver(x, t, 1, lambda x: x))</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="devito-implementation">
<h3><span class="section-number">1.6.1. </span>Devito implementation<a class="headerlink" href="#devito-implementation" title="Permalink to this headline">¶</a></h3>
<p>Now let’s take a look at the same algorithm, but this time, using Devito.</p>
<p>We start by defining our 1D computational grid and creating a function <code class="docutils literal notranslate"><span class="pre">u</span></code> as a symbolic <code class="docutils literal notranslate"><span class="pre">devito.TimeFunction</span></code>. We need to specify the <code class="docutils literal notranslate"><span class="pre">space_order</span></code> as 2 since our wave equation involves second-order derivatives with respect to <span class="math notranslate nohighlight">\(x\)</span>. Similarly, we specify the <code class="docutils literal notranslate"><span class="pre">time_order</span></code> as 2, as our equation involves second-order derivatives with respect to <span class="math notranslate nohighlight">\(t\)</span>. Setting these parameters allows us to use <code class="docutils literal notranslate"><span class="pre">u.dx2</span></code> and <code class="docutils literal notranslate"><span class="pre">u.dt2</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">devito</span> <span class="kn">import</span> <span class="n">Grid</span><span class="p">,</span> <span class="n">TimeFunction</span>

<span class="c1"># Initialise `u` for space and time order 2, using initialisation function I</span>
<span class="n">grid</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">Nx</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TimeFunction</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span> <span class="n">space_order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">time_order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">u</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now that we have initialised <code class="docutils literal notranslate"><span class="pre">u</span></code>, we can solve our wave equation for the unknown quantity <span class="math notranslate nohighlight">\(u^{n+1}_i\)</span> using forward and backward differences in space and time.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">devito</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">solve</span>

<span class="c1"># Set up wave equation and solve for forward stencil point in time</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="n">eq</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">dt2</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">dx2</span><span class="p">)</span>
<span class="n">stencil</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">forward</span><span class="p">)</span>
<span class="n">eq_stencil</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">forward</span><span class="p">,</span> <span class="n">stencil</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;LHS: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">eq_stencil</span><span class="o">.</span><span class="n">lhs</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;RHS: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">eq_stencil</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>LHS: u(t + dt, x)
RHS: dt**2*(c**2*(-2.0*u(t, x)/h_x**2 + u(t, x - h_x)/h_x**2 + u(t, x + h_x)/h_x**2) + 2.0*u(t, x)/dt**2 - u(t - dt, x)/dt**2)
</pre></div>
</div>
</div>
</div>
<p>Great! From these print statements, we can see that Devito has taken the wave equation in (<a class="reference external" href="#wave:pde1">1</a>) and solved it for <span class="math notranslate nohighlight">\(u^{n+1}_i\)</span>, giving us equation (<a class="reference external" href="#wave:pde1:step4">11</a>). Note that <code class="docutils literal notranslate"><span class="pre">dx</span></code> is denoted as <code class="docutils literal notranslate"><span class="pre">h_x</span></code>, while <code class="docutils literal notranslate"><span class="pre">u(t,</span> <span class="pre">x)</span></code>, <code class="docutils literal notranslate"><span class="pre">u(t,</span> <span class="pre">x</span> <span class="pre">-</span> <span class="pre">h_x)</span></code> and <code class="docutils literal notranslate"><span class="pre">u(t,</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">h_x)</span></code> denote the equivalent of <span class="math notranslate nohighlight">\(u^{n}_{i}\)</span>, <span class="math notranslate nohighlight">\(u^{n}_{i-1}\)</span> and <span class="math notranslate nohighlight">\(u^{n}_{i+1}\)</span> respectively.</p>
<p>Now we can create expressions for our boundary conditions and build the operator.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># NBVAL_IGNORE_OUTPUT</span>

<span class="kn">from</span> <span class="nn">devito</span> <span class="kn">import</span> <span class="n">Operator</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">stepping_dim</span>

<span class="c1"># Boundary conditions</span>
<span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.</span><span class="p">)]</span>
<span class="n">bcs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.</span><span class="p">)]</span>

<span class="c1"># Building operator</span>
<span class="n">op</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">([</span><span class="n">eq_stencil</span><span class="p">]</span> <span class="o">+</span> <span class="n">bcs</span><span class="p">)</span>
<span class="n">op</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">Nt</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="stderr docutils container">
<pre class="stderr literal-block">Data type float64 of runtime value `dt` does not match the Constant data type &lt;class 'numpy.float32'&gt;
</pre>
</div>
<div class="stderr docutils container">
<pre class="stderr literal-block">Operator `Kernel` run in 0.01 s
</pre>
</div>
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>PerformanceSummary([(PerfKey(name=&#39;section0&#39;, rank=None),
                     PerfEntry(time=1.2000000000000002e-05, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[]))])
</pre></div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="verification">
<h1><span class="section-number">2. </span>Verification<a class="headerlink" href="#verification" title="Permalink to this headline">¶</a></h1>
<p>Before implementing the algorithm, it is convenient to add a source
term to the PDE (<a class="reference external" href="#wave:pde1">1</a>), since that gives us more freedom in
finding test problems for verification. Physically, a source term acts
as a generator for waves in the interior of the domain.</p>
<div class="section" id="a-slightly-generalized-model-problem">
<h2><span class="section-number">2.1. </span>A slightly generalized model problem<a class="headerlink" href="#a-slightly-generalized-model-problem" title="Permalink to this headline">¶</a></h2>
<div id="wave:pde2:fd"></div>
<p>We now address the following extended initial-boundary value problem
for one-dimensional wave phenomena:</p>
<!-- Equation labels as ordinary links -->
<div id="wave:pde2"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u_{tt} = c^2 u_{xx} + f(x,t), \quad x\in (0,L),\ t\in (0,T]
\label{wave:pde2} \tag{17}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="wave:pde2:ic:u"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
u(x,0) = I(x), \quad x\in [0,L]
\label{wave:pde2:ic:u} \tag{18}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="wave:pde2:ic:ut"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
u_t(x,0) = V(x), \quad x\in [0,L]
\label{wave:pde2:ic:ut} \tag{19}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="wave:pde2:bc:0"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
u(0,t)  = 0, \quad  t&gt;0
\label{wave:pde2:bc:0} \tag{20}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="wave:pde2:bc:L"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
u(L,t)  = 0, \quad  t&gt;0
\label{wave:pde2:bc:L} \tag{21}
\end{equation}
\]</div>
<p>Sampling the PDE at <span class="math notranslate nohighlight">\((x_i,t_n)\)</span> and using the same finite difference
approximations as above, yields</p>
<!-- Equation labels as ordinary links -->
<div id="wave:pde2:fdop"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
[D_tD_t u = c^2 D_xD_x u + f]^{n}_i
\label{wave:pde2:fdop} \tag{22}
\end{equation}
\]</div>
<p>Writing this out and solving for the unknown <span class="math notranslate nohighlight">\(u^{n+1}_i\)</span> results in</p>
<!-- Equation labels as ordinary links -->
<div id="wave:pde2:step3b"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u^{n+1}_i = -u^{n-1}_i + 2u^n_i + C^2
(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}) + \Delta t^2 f^n_i
\label{wave:pde2:step3b} \tag{23}
\end{equation}
\]</div>
<p>The equation for the first time step must be rederived. The discretization
of the initial condition <span class="math notranslate nohighlight">\(u_t = V(x)\)</span> at <span class="math notranslate nohighlight">\(t=0\)</span>
becomes</p>
<div class="math notranslate nohighlight">
\[
[D_{2t}u = V]^0_i\quad\Rightarrow\quad u^{-1}_i = u^{1}_i - 2\Delta t V_i,
\]</div>
<p>which, when inserted in (<a class="reference external" href="#wave:pde2:step3b">23</a>) for <span class="math notranslate nohighlight">\(n=0\)</span>, gives
the special formula</p>
<!-- Equation labels as ordinary links -->
<div id="wave:pde2:step3c"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u^{1}_i = u^0_i - \Delta t V_i + {\frac{1}{2}}
C^2
\left(u^{0}_{i+1}-2u^{0}_{i} + u^{0}_{i-1}\right) + \frac{1}{2}\Delta t^2 f^0_i
\label{wave:pde2:step3c} \tag{24}
\end{equation}
\]</div>
</div>
<div class="section" id="using-an-analytical-solution-of-physical-significance">
<h2><span class="section-number">2.2. </span>Using an analytical solution of physical significance<a class="headerlink" href="#using-an-analytical-solution-of-physical-significance" title="Permalink to this headline">¶</a></h2>
<div id="wave:pde2:fd:standing:waves"></div>
<p>Many wave problems feature sinusoidal oscillations in time
and space. For example, the original PDE problem
(<a class="reference external" href="#wave:pde1">1</a>)-(<a class="reference external" href="#wave:pde1:bc:L">5</a>) allows an exact solution</p>
<!-- Equation labels as ordinary links -->
<div id="wave:pde2:test:ue"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u_e(x,t) = A\sin\left(\frac{\pi}{L}x\right)
\cos\left(\frac{\pi}{L}ct\right)
\label{wave:pde2:test:ue} \tag{25}
\end{equation}
\]</div>
<p>This <span class="math notranslate nohighlight">\(u_e\)</span> fulfills the PDE with <span class="math notranslate nohighlight">\(f=0\)</span>, boundary conditions
<span class="math notranslate nohighlight">\(u_e(0,t)=u_e(L,t)=0\)</span>, as well as initial
conditions <span class="math notranslate nohighlight">\(I(x)=A\sin\left(\frac{\pi}{L}x\right)\)</span> and <span class="math notranslate nohighlight">\(V=0\)</span>.</p>
<p><strong>How to use exact solutions for verification.</strong></p>
<p>It is common to use such exact solutions of physical interest
to verify implementations. However, the numerical
solution <span class="math notranslate nohighlight">\(u^n_i\)</span> will only be an approximation to <span class="math notranslate nohighlight">\(u_e(x_i,t_n)\)</span>.
We have no knowledge of the precise size of the error in
this approximation, and therefore we can never know if discrepancies
between <span class="math notranslate nohighlight">\(u^n_i\)</span> and <span class="math notranslate nohighlight">\(u_e(x_i,t_n)\)</span> are caused
by mathematical approximations or programming errors.
In particular, if plots of the computed solution <span class="math notranslate nohighlight">\(u^n_i\)</span> and
the exact one (<a class="reference external" href="#wave:pde2:test:ue">25</a>) look similar, many
are tempted to claim that the implementation works. However,
even if color plots look nice and the accuracy is “deemed good”,
there can still be serious programming errors present!</p>
<p>The only way to use exact physical solutions like
(<a class="reference external" href="#wave:pde2:test:ue">25</a>) for serious and thorough verification is to
run a series of simulations on finer and finer meshes, measure the
integrated error in each mesh, and from this information estimate the
empirical convergence rate of the method.</p>
<p>An introduction to the computing of convergence rates is given in Section 3.1.6
in <a class="reference external" href="#Langtangen_decay">[Langtangen_decay]</a>.</p>
<!-- % if BOOK == "book": -->
<p>There is also a detailed example on computing convergence rates in
the section <a class="reference external" href="#vib:ode1:verify">vib:ode1:verify</a>.</p>
<!-- % endif -->
<p>In the present problem, one expects the method to have a convergence rate
of 2 (see the section <a class="reference external" href="#wave:pde1:analysis">wave:pde1:analysis</a>), so if the computed rates
are close to 2 on a sufficiently fine mesh, we have good evidence that
the implementation is free of programming mistakes.</p>
</div>
<div class="section" id="manufactured-solution-and-estimation-of-convergence-rates">
<h2><span class="section-number">2.3. </span>Manufactured solution and estimation of convergence rates<a class="headerlink" href="#manufactured-solution-and-estimation-of-convergence-rates" title="Permalink to this headline">¶</a></h2>
<div id="wave:pde2:fd:MMS"></div>
<div class="section" id="specifying-the-solution-and-computing-corresponding-data">
<h3><span class="section-number">2.3.1. </span>Specifying the solution and computing corresponding data<a class="headerlink" href="#specifying-the-solution-and-computing-corresponding-data" title="Permalink to this headline">¶</a></h3>
<p>One problem with the exact solution (<a class="reference external" href="#wave:pde2:test:ue">25</a>) is
that it requires a simplification (<span class="math notranslate nohighlight">\({V}=0, f=0\)</span>) of the implemented problem
(<a class="reference external" href="#wave:pde2">17</a>)-(<a class="reference external" href="#wave:pde2:bc:L">21</a>). An advantage of using
a <em>manufactured solution</em> is that we can test all terms in the
PDE problem. The idea of this approach is to set up some chosen
solution and fit the source term, boundary conditions, and initial
conditions to be compatible with the chosen solution.
Given that our boundary conditions in the implementation are
<span class="math notranslate nohighlight">\(u(0,t)=u(L,t)=0\)</span>, we must choose a solution that fulfills these
conditions. One example is</p>
<div class="math notranslate nohighlight">
\[
u_e(x,t) = x(L-x)\sin t
\]</div>
<p>Inserted in the PDE <span class="math notranslate nohighlight">\(u_{tt}=c^2u_{xx}+f\)</span> we get</p>
<div class="math notranslate nohighlight">
\[
-x(L-x)\sin t = -c^2 2\sin t + f\quad\Rightarrow f = (2c^2 - x(L-x))\sin t
\]</div>
<p>The initial conditions become</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
u(x,0) =&amp; I(x) = 0,\\ 
u_t(x,0) &amp;= V(x) = x(L-x)
\end{align*}
\end{split}\]</div>
</div>
<div class="section" id="defining-a-single-discretization-parameter">
<h3><span class="section-number">2.3.2. </span>Defining a single discretization parameter<a class="headerlink" href="#defining-a-single-discretization-parameter" title="Permalink to this headline">¶</a></h3>
<p>To verify the code, we compute the convergence rates in a series of
simulations, letting each simulation use a finer mesh than the
previous one. Such empirical estimation of convergence rates relies on
an assumption that some measure <span class="math notranslate nohighlight">\(E\)</span> of the numerical error is related
to the discretization parameters through</p>
<div class="math notranslate nohighlight">
\[
E = C_t\Delta t^r + C_x\Delta x^p,
\]</div>
<p>where <span class="math notranslate nohighlight">\(C_t\)</span>, <span class="math notranslate nohighlight">\(C_x\)</span>, <span class="math notranslate nohighlight">\(r\)</span>, and <span class="math notranslate nohighlight">\(p\)</span> are constants. The constants <span class="math notranslate nohighlight">\(r\)</span> and
<span class="math notranslate nohighlight">\(p\)</span> are known as the <em>convergence rates</em> in time and space,
respectively.  From the accuracy in the finite difference
approximations, we expect <span class="math notranslate nohighlight">\(r=p=2\)</span>, since the error terms are of order
<span class="math notranslate nohighlight">\(\Delta t^2\)</span> and <span class="math notranslate nohighlight">\(\Delta x^2\)</span>.  This is confirmed by truncation error
analysis and other types of analysis.</p>
<p>By using an exact solution of the PDE problem, we will next compute
the error measure <span class="math notranslate nohighlight">\(E\)</span> on a sequence of refined meshes and see if
the rates <span class="math notranslate nohighlight">\(r=p=2\)</span> are obtained. We will not be concerned with estimating
the constants <span class="math notranslate nohighlight">\(C_t\)</span> and <span class="math notranslate nohighlight">\(C_x\)</span>, simply because we are not interested in
their values.</p>
<p>It is advantageous to introduce a single discretization parameter
<span class="math notranslate nohighlight">\(h=\Delta t=\hat c \Delta x\)</span> for some constant <span class="math notranslate nohighlight">\(\hat c\)</span>.  Since
<span class="math notranslate nohighlight">\(\Delta t\)</span> and <span class="math notranslate nohighlight">\(\Delta x\)</span> are related through the Courant number,
<span class="math notranslate nohighlight">\(\Delta t = C\Delta x/c\)</span>, we set <span class="math notranslate nohighlight">\(h=\Delta t\)</span>, and then <span class="math notranslate nohighlight">\(\Delta x =
hc/C\)</span>.  Now the expression for the error measure is greatly
simplified:</p>
<div class="math notranslate nohighlight">
\[
E = C_t\Delta t^r + C_x\Delta x^r =
C_t h^r + C_x\left(\frac{c}{C}\right)^r h^r
= Dh^r,\quad D = C_t+C_x\left(\frac{c}{C}\right)^r 
\]</div>
</div>
<div class="section" id="computing-errors">
<h3><span class="section-number">2.3.3. </span>Computing errors<a class="headerlink" href="#computing-errors" title="Permalink to this headline">¶</a></h3>
<p>We choose an initial discretization parameter <span class="math notranslate nohighlight">\(h_0\)</span> and run
experiments with decreasing <span class="math notranslate nohighlight">\(h\)</span>: <span class="math notranslate nohighlight">\(h_i=2^{-i}h_0\)</span>, <span class="math notranslate nohighlight">\(i=1,2,\ldots,m\)</span>.
Halving <span class="math notranslate nohighlight">\(h\)</span> in each experiment is not necessary, but it is a common
choice.  For each experiment we must record <span class="math notranslate nohighlight">\(E\)</span> and <span class="math notranslate nohighlight">\(h\)</span>.  Standard
choices of error measure are the <span class="math notranslate nohighlight">\(\ell^2\)</span> and <span class="math notranslate nohighlight">\(\ell^\infty\)</span> norms of the
error mesh function <span class="math notranslate nohighlight">\(e^n_i\)</span>:</p>
<!-- Equation labels as ordinary links -->
<div id="wave:pde2:fd:MMS:E:l2"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
E = ||e^n_i||_{\ell^2} = \left( \Delta t\Delta x
\sum_{n=0}^{N_t}\sum_{i=0}^{N_x}
(e^n_i)^2\right)^{\frac{1}{2}},\quad e^n_i = u_e(x_i,t_n)-u^n_i,
\label{wave:pde2:fd:MMS:E:l2} \tag{26}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="wave:pde2:fd:MMS:E:linf"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
E = ||e^n_i||_{\ell^\infty} = \max_{i,n} |e^n_i|
\label{wave:pde2:fd:MMS:E:linf} \tag{27}
\end{equation}
\]</div>
<p>In Python, one can compute <span class="math notranslate nohighlight">\(\sum_{i}(e^{n}_i)^2\)</span> at each time step
and accumulate the value in some sum variable, say <code class="docutils literal notranslate"><span class="pre">e2_sum</span></code>.  At the
final time step one can do <code class="docutils literal notranslate"><span class="pre">sqrt(dt*dx*e2_sum)</span></code>.  For the
<span class="math notranslate nohighlight">\(\ell^\infty\)</span> norm one must compare the maximum error at a time level
(<code class="docutils literal notranslate"><span class="pre">e.max()</span></code>) with the global maximum over the time domain: <code class="docutils literal notranslate"><span class="pre">e_max</span> <span class="pre">=</span> <span class="pre">max(e_max,</span> <span class="pre">e.max())</span></code>.</p>
<p>An alternative error measure is to use a spatial norm at one time step
only, e.g., the end time <span class="math notranslate nohighlight">\(T\)</span> (<span class="math notranslate nohighlight">\(n=N_t\)</span>):</p>
<!-- Equation labels as ordinary links -->
<div id="_auto6"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
E = ||e^n_i||_{\ell^2} = \left( \Delta x\sum_{i=0}^{N_x}
(e^n_i)^2\right)^{\frac{1}{2}},\quad e^n_i = u_e(x_i,t_n)-u^n_i,
\label{_auto6} \tag{28}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto7"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
E = ||e^n_i||_{\ell^\infty} = \max_{0\leq i\leq N_x} |e^{n}_i|
\label{_auto7} \tag{29}
\end{equation}
\]</div>
<p>The important point is that the error measure (<span class="math notranslate nohighlight">\(E\)</span>) for the simulation is represented by a single number.</p>
</div>
<div class="section" id="computing-rates">
<h3><span class="section-number">2.3.4. </span>Computing rates<a class="headerlink" href="#computing-rates" title="Permalink to this headline">¶</a></h3>
<p>Let <span class="math notranslate nohighlight">\(E_i\)</span> be the error measure in experiment (mesh) number <span class="math notranslate nohighlight">\(i\)</span>
(not to be confused with the spatial index <span class="math notranslate nohighlight">\(i\)</span>) and
let <span class="math notranslate nohighlight">\(h_i\)</span> be the corresponding discretization parameter (<span class="math notranslate nohighlight">\(h\)</span>).
With the error model <span class="math notranslate nohighlight">\(E_i = Dh_i^r\)</span>, we can
estimate <span class="math notranslate nohighlight">\(r\)</span> by comparing two consecutive
experiments:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
E_{i+1}&amp; =D h_{i+1}^{r},\\ 
E_{i}&amp; =D h_{i}^{r}
\end{align*}
\end{split}\]</div>
<p>Dividing the two equations eliminates the (uninteresting) constant <span class="math notranslate nohighlight">\(D\)</span>.
Thereafter, solving for <span class="math notranslate nohighlight">\(r\)</span> yields</p>
<div class="math notranslate nohighlight">
\[
r = \frac{\ln E_{i+1}/E_{i}}{\ln h_{i+1}/h_{i}}
\]</div>
<p>Since <span class="math notranslate nohighlight">\(r\)</span> depends on <span class="math notranslate nohighlight">\(i\)</span>, i.e., which simulations we compare,
we add an index to <span class="math notranslate nohighlight">\(r\)</span>: <span class="math notranslate nohighlight">\(r_i\)</span>, where <span class="math notranslate nohighlight">\(i=0,\ldots,m-2\)</span>, if we
have <span class="math notranslate nohighlight">\(m\)</span> experiments: <span class="math notranslate nohighlight">\((h_0,E_0),\ldots,(h_{m-1}, E_{m-1})\)</span>.</p>
<p>In our present discretization of the wave equation we expect <span class="math notranslate nohighlight">\(r=2\)</span>, and
hence the <span class="math notranslate nohighlight">\(r_i\)</span> values should converge to 2 as <span class="math notranslate nohighlight">\(i\)</span> increases.</p>
</div>
</div>
<div class="section" id="constructing-an-exact-solution-of-the-discrete-equations">
<h2><span class="section-number">2.4. </span>Constructing an exact solution of the discrete equations<a class="headerlink" href="#constructing-an-exact-solution-of-the-discrete-equations" title="Permalink to this headline">¶</a></h2>
<div id="wave:pde2:fd:verify:quadratic"></div>
<p>With a manufactured or known analytical solution, as outlined above,
we can estimate convergence rates and see if they have the correct
asymptotic behavior. Experience shows that this is a quite good
verification technique in that many common bugs will destroy the
convergence rates. A significantly better test though,
would be to check that the
numerical solution is exactly what it should be. This will in general
require exact knowledge of the numerical error, which we do not normally have
(although we in the section <a class="reference external" href="#wave:pde1:analysis">wave:pde1:analysis</a> establish such knowledge
in simple cases).
However, it is possible to look for solutions where we can show that
the numerical error vanishes, i.e., the solution of the original continuous
PDE problem is
also a solution of the discrete equations. This property often arises
if the exact solution of the PDE
is a lower-order polynomial. (Truncation error
analysis leads to error measures that involve derivatives of the
exact solution. In the present problem, the truncation error involves
4th-order derivatives of <span class="math notranslate nohighlight">\(u\)</span> in space and time. Choosing <span class="math notranslate nohighlight">\(u\)</span>
as a polynomial of degree three or less
will therefore lead to vanishing error.)</p>
<p>We shall now illustrate the construction of an exact solution to both the
PDE itself and the discrete equations.
Our chosen manufactured solution is quadratic in space
and linear in time. More specifically, we set</p>
<!-- Equation labels as ordinary links -->
<div id="wave:pde2:fd:verify:quadratic:uex"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u_e (x,t) = x(L-x)(1+{\frac{1}{2}}t),
\label{wave:pde2:fd:verify:quadratic:uex} \tag{30}
\end{equation}
\]</div>
<p>which by insertion in the PDE leads to <span class="math notranslate nohighlight">\(f(x,t)=2(1+t)c^2\)</span>. This <span class="math notranslate nohighlight">\(u_e\)</span>
fulfills the boundary conditions <span class="math notranslate nohighlight">\(u=0\)</span> and demands <span class="math notranslate nohighlight">\(I(x)=x(L-x)\)</span>
and <span class="math notranslate nohighlight">\(V(x)={\frac{1}{2}}x(L-x)\)</span>.</p>
<p>To realize that the chosen <span class="math notranslate nohighlight">\(u_e\)</span> is also an exact
solution of the discrete equations,
we first remind ourselves that <span class="math notranslate nohighlight">\(t_n=n\Delta t\)</span> so that</p>
<!-- Equation labels as ordinary links -->
<div id="_auto8"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\lbrack D_tD_t t^2\rbrack^n = \frac{t_{n+1}^2 - 2t_n^2 + t_{n-1}^2}{\Delta t^2}
= (n+1)^2 -2n^2 + (n-1)^2 = 2,
\label{_auto8} \tag{31}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto9"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
\lbrack D_tD_t t\rbrack^n = \frac{t_{n+1} - 2t_n + t_{n-1}}{\Delta t^2}
= \frac{((n+1) -2n + (n-1))\Delta t}{\Delta t^2} = 0
\label{_auto9} \tag{32}
\end{equation}
\]</div>
<p>Hence,</p>
<div class="math notranslate nohighlight">
\[
[D_tD_t u_e]^n_i = x_i(L-x_i)[D_tD_t (1+{\frac{1}{2}}t)]^n =
x_i(L-x_i){\frac{1}{2}}[D_tD_t t]^n = 0
\]</div>
<p>Similarly, we get that</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
\lbrack D_xD_x u_e\rbrack^n_i &amp;=
(1+{\frac{1}{2}}t_n)\lbrack D_xD_x (xL-x^2)\rbrack_i\\ 
&amp; =
(1+{\frac{1}{2}}t_n)\lbrack LD_xD_x x - D_xD_x x^2\rbrack_i \\ 
&amp;= -2(1+{\frac{1}{2}}t_n)
\end{align*}
\end{split}\]</div>
<p>Now, <span class="math notranslate nohighlight">\(f^n_i = 2(1+{\frac{1}{2}}t_n)c^2\)</span>, which results in</p>
<div class="math notranslate nohighlight">
\[
[D_tD_t u_e - c^2D_xD_xu_e - f]^n_i = 0 +
c^2 2(1 + {\frac{1}{2}}t_{n}) +
2(1+{\frac{1}{2}}t_n)c^2 = 0
\]</div>
<p>Moreover, <span class="math notranslate nohighlight">\(u_e(x_i,0)=I(x_i)\)</span>,
<span class="math notranslate nohighlight">\(\partial u_e/\partial t = V(x_i)\)</span> at <span class="math notranslate nohighlight">\(t=0\)</span>, and
<span class="math notranslate nohighlight">\(u_e(x_0,t)=u_e(x_{N_x},0)=0\)</span>. Also the modified scheme for the
first time step is fulfilled by <span class="math notranslate nohighlight">\(u_e(x_i,t_n)\)</span>.</p>
<p>Therefore, the exact solution <span class="math notranslate nohighlight">\(u_e(x,t)=x(L-x)(1+t/2)\)</span> of the PDE
problem is also an exact solution of the discrete problem.  This means
that we know beforehand what numbers the numerical algorithm should
produce.  We can use this fact to check that the computed <span class="math notranslate nohighlight">\(u^n_i\)</span>
values from an implementation equals <span class="math notranslate nohighlight">\(u_e(x_i,t_n)\)</span>, within machine
precision.  This result is valid <em>regardless of the mesh spacings</em>
<span class="math notranslate nohighlight">\(\Delta x\)</span> and <span class="math notranslate nohighlight">\(\Delta t\)</span>!  Nevertheless, there might be stability
restrictions on <span class="math notranslate nohighlight">\(\Delta x\)</span> and <span class="math notranslate nohighlight">\(\Delta t\)</span>, so the test can only be run
for a mesh that is compatible with the stability criterion (which in
the present case is <span class="math notranslate nohighlight">\(C\leq 1\)</span>, to be derived later).</p>
<p><strong>Notice.</strong></p>
<p>A product of quadratic or linear expressions in the various
independent variables, as shown above, will often fulfill both the
PDE problem and the discrete equations, and can therefore be very useful
solutions for verifying implementations.</p>
<p>However, for 1D wave
equations of the type <span class="math notranslate nohighlight">\(u_{tt}=c^2u_{xx}\)</span> we shall see that there is always
another much more powerful way of generating exact
solutions (which consists in just setting <span class="math notranslate nohighlight">\(C=1\)</span> (!), as shown in
the section <a class="reference external" href="#wave:pde1:analysis">wave:pde1:analysis</a>).</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./notebooks/wave"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="../../index.html" title="previous page">Welcome to the Devito Book!</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By The Devito Project Community<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    <script src="../../_static/js/index.js"></script>
    
  </body>
</html>