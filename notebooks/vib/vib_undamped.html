

<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>1. Finite difference discretization &#8212; The Devito Book</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="../../_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-dropdown.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/sphinx-book-theme.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/sphinx-book-theme.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="1. Simulation of waves on a string" href="../wave/wave1D_fd1.html" />
    <link rel="prev" title="Welcome to the Devito Book!" href="../../index.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../../index.html">
  
  <img src="../../_static/devito_logo.png" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">The Devito Book</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../../index.html">
   Welcome to the Devito Book!
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Vibration ODEs
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   1. Finite difference discretization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="#implementation">
   2. Implementation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="#visualization-of-long-time-simulations">
   3. Visualization of long time simulations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="#analysis-of-the-numerical-scheme">
   4. Analysis of the numerical scheme
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="#alternative-schemes-based-on-1st-order-equations">
   5. Alternative schemes based on 1st-order equations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="#energy-considerations">
   6. Energy considerations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="#the-euler-cromer-method">
   7. The Euler-Cromer method
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="#staggered-mesh">
   8. Staggered mesh
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="#exercises-and-problems">
   9. Exercises and Problems
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Wave equations
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../wave/wave1D_fd1.html">
   1. Simulation of waves on a string
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../wave/wave1D_fd1.html#verification">
   2. Verification
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../wave/wave1D_prog.html">
   3. Implementation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../wave/wave1D_prog.html#exercises">
   4. Exercises
  </a>
 </li>
</ul>

</nav>

 <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    
    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/notebooks/vib/vib_undamped.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
    
</div>
        <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/devitocodes/devito_book"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        
        
    </div>
</div>


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/devitocodes/devito_book/master?urlpath=tree/notebooks/vib/vib_undamped.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        <a class="colab-button" href="https://colab.research.google.com/github/devitocodes/devito_book/blob/master/notebooks/vib/vib_undamped.ipynb"><button type="button" class="btn btn-secondary topbarbtn"
                title="Launch Colab" data-toggle="tooltip" data-placement="left"><img class="colab-button-logo"
                    src="../../_static/images/logo_colab.png"
                    alt="Interact on Colab">Colab</button></a>
        
        
    </div>
</div>

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-basic-model-for-vibrations">
   1.1. A basic model for vibrations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-centered-finite-difference-scheme">
   1.2. A centered finite difference scheme
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#step-1-discretizing-the-domain">
     1.2.1. Step 1: Discretizing the domain
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#step-2-fulfilling-the-equation-at-discrete-time-points">
     1.2.2. Step 2: Fulfilling the equation at discrete time points
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#step-3-replacing-derivatives-by-finite-differences">
     1.2.3. Step 3: Replacing derivatives by finite differences
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#step-4-formulating-a-recursive-algorithm">
     1.2.4. Step 4: Formulating a recursive algorithm
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#computing-the-first-step">
     1.2.5. Computing the first step
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-computational-algorithm">
     1.2.6. The computational algorithm
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#operator-notation">
     1.2.7. Operator notation
    </a>
   </li>
  </ul>
 </li>
</ul>

        </nav>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <!-- 2DO: -->
<!-- _undamped -> _simple everywhere -->
<!-- Long time integration by adaptive RK: will that improve the -->
<!-- phase error? Do experiments where we measure the wavelength -->
<!-- and plot it as function of time. Can we vectorize the -->
<!-- max/min pt computation? -->
<p>Vibration problems lead to differential equations with solutions that
oscillate in time, typically in a damped or undamped sinusoidal
fashion.  Such solutions put certain demands on the numerical methods
compared to other phenomena whose solutions are monotone or very smooth.
Both the frequency and amplitude of the oscillations need to be
accurately handled by the numerical schemes. The forthcoming text
presents a range of different methods, from classical ones
(Runge-Kutta and midpoint/Crank-Nicolson methods), to more
modern and popular symplectic (geometric) integration schemes (Leapfrog,
Euler-Cromer, and
Stoermer-Verlet
methods), but with a clear emphasis on the latter. Vibration problems
occur throughout mechanics and physics, but the methods discussed
in this text are also fundamental for constructing successful algorithms
for partial differential equations
of wave nature in multiple spatial dimensions.</p>
<div class="section" id="finite-difference-discretization">
<h1><span class="section-number">1. </span>Finite difference discretization<a class="headerlink" href="#finite-difference-discretization" title="Permalink to this headline">¶</a></h1>
<div id="vib:model1"></div>
<p>Many of the numerical challenges faced when computing oscillatory
solutions to ODEs and PDEs can be captured by the very simple ODE
<span class="math notranslate nohighlight">\(u^{\prime\prime} + u =0\)</span>. This ODE is thus chosen as our starting
point for method development, implementation, and analysis.</p>
<div class="section" id="a-basic-model-for-vibrations">
<h2><span class="section-number">1.1. </span>A basic model for vibrations<a class="headerlink" href="#a-basic-model-for-vibrations" title="Permalink to this headline">¶</a></h2>
<p>The simplest model of a vibrating mechanical system has the following form:</p>
<!-- Equation labels as ordinary links -->
<div id="vib:ode1"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u^{\prime\prime} + \omega^2u = 0,\quad u(0)=I,\ u^{\prime}(0)=0,\ t\in (0,T\rbrack
% \thinspace .
\label{vib:ode1} \tag{1}
\end{equation}
\]</div>
<p>Here, <span class="math notranslate nohighlight">\(\omega\)</span> and <span class="math notranslate nohighlight">\(I\)</span> are given constants.
The section <a class="reference external" href="vib_app.ipynb#vib:app:mass_spring">Applications of vibration models</a> derives (<a class="reference external" href="#vib:ode1">1</a>) from physical
principles and explains what the constants mean.</p>
<p>The exact solution of (<a class="reference external" href="#vib:ode1">1</a>) is</p>
<!-- Equation labels as ordinary links -->
<div id="vib:ode1:uex"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u(t) = I\cos (\omega t)
\thinspace .
\label{vib:ode1:uex} \tag{2}
\end{equation}
\]</div>
<p>That is, <span class="math notranslate nohighlight">\(u\)</span> oscillates with constant amplitude <span class="math notranslate nohighlight">\(I\)</span> and
angular frequency <span class="math notranslate nohighlight">\(\omega\)</span>.
The corresponding period of oscillations (i.e., the time between two
neighboring peaks in the cosine function) is <span class="math notranslate nohighlight">\(P=2\pi/\omega\)</span>.
The number of periods per second
is <span class="math notranslate nohighlight">\(f=\omega/(2\pi)\)</span> and measured in the unit Hz.
Both <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(\omega\)</span> are referred to as frequency, but <span class="math notranslate nohighlight">\(\omega\)</span>
is more precisely named <em>angular frequency</em>, measured in rad/s.</p>
<p>In vibrating mechanical systems modeled by (<a class="reference external" href="#vib:ode1">1</a>), <span class="math notranslate nohighlight">\(u(t)\)</span>
very often represents a position or a displacement of a particular
point in the system. The derivative <span class="math notranslate nohighlight">\(u^{\prime}(t)\)</span> then has the
interpretation of velocity, and <span class="math notranslate nohighlight">\(u^{\prime\prime}(t)\)</span> is the associated
acceleration.  The model (<a class="reference external" href="#vib:ode1">1</a>) is not only
applicable to vibrating mechanical systems, but also to oscillations
in electrical circuits.</p>
</div>
<div class="section" id="a-centered-finite-difference-scheme">
<h2><span class="section-number">1.2. </span>A centered finite difference scheme<a class="headerlink" href="#a-centered-finite-difference-scheme" title="Permalink to this headline">¶</a></h2>
<div id="vib:ode1:fdm"></div>
<p>To formulate a finite difference method for the model
problem  (<a class="reference external" href="#vib:ode1">1</a>), we follow the four steps explained in Section 1.1.2
in <a class="reference external" href="#Langtangen_decay">[Langtangen_decay]</a>.</p>
<div class="section" id="step-1-discretizing-the-domain">
<h3><span class="section-number">1.2.1. </span>Step 1: Discretizing the domain<a class="headerlink" href="#step-1-discretizing-the-domain" title="Permalink to this headline">¶</a></h3>
<p>The domain is discretized by
introducing a uniformly partitioned time mesh.
The points in the mesh are <span class="math notranslate nohighlight">\(t_n=n\Delta t\)</span>, <span class="math notranslate nohighlight">\(n=0,1,\ldots,N_t\)</span>,
where <span class="math notranslate nohighlight">\(\Delta t = T/N_t\)</span> is the constant length of the time steps.
We introduce a mesh function <span class="math notranslate nohighlight">\(u^n\)</span> for <span class="math notranslate nohighlight">\(n=0,1,\ldots,N_t\)</span>, which
approximates the exact solution at the mesh points. (Note that
<span class="math notranslate nohighlight">\(n=0\)</span> is the known initial condition, so <span class="math notranslate nohighlight">\(u^n\)</span> is identical to the mathematical
<span class="math notranslate nohighlight">\(u\)</span> at this point.) The mesh
function <span class="math notranslate nohighlight">\(u^n\)</span> will be computed from algebraic equations derived from
the differential equation problem.</p>
</div>
<div class="section" id="step-2-fulfilling-the-equation-at-discrete-time-points">
<h3><span class="section-number">1.2.2. </span>Step 2: Fulfilling the equation at discrete time points<a class="headerlink" href="#step-2-fulfilling-the-equation-at-discrete-time-points" title="Permalink to this headline">¶</a></h3>
<p>The ODE is to be satisfied at each mesh point where the solution
must be found:</p>
<!-- Equation labels as ordinary links -->
<div id="vib:ode1:step2"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u^{\prime\prime}(t_n) + \omega^2u(t_n) = 0,\quad n=1,\ldots,N_t
\thinspace .
\label{vib:ode1:step2} \tag{3}
\end{equation}
\]</div>
</div>
<div class="section" id="step-3-replacing-derivatives-by-finite-differences">
<h3><span class="section-number">1.2.3. </span>Step 3: Replacing derivatives by finite differences<a class="headerlink" href="#step-3-replacing-derivatives-by-finite-differences" title="Permalink to this headline">¶</a></h3>
<p>The derivative <span class="math notranslate nohighlight">\(u^{\prime\prime}(t_n)\)</span> is to be replaced by a finite
difference approximation. A common second-order accurate approximation
to the second-order derivative is</p>
<!-- Equation labels as ordinary links -->
<div id="vib:ode1:step3"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u^{\prime\prime}(t_n) \approx \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
\thinspace .
\label{vib:ode1:step3} \tag{4}
\end{equation}
\]</div>
<p>Inserting (<a class="reference external" href="#vib:ode1:step3">4</a>) in (<a class="reference external" href="#vib:ode1:step2">3</a>)
yields</p>
<!-- Equation labels as ordinary links -->
<div id="vib:ode1:step3b"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2} = -\omega^2 u^n
\thinspace .
\label{vib:ode1:step3b} \tag{5}
\end{equation}
\]</div>
<p>We also need to replace the derivative in the initial condition by
a finite difference. Here we choose a centered difference, whose
accuracy is similar to the centered difference we used for <span class="math notranslate nohighlight">\(u^{\prime\prime}\)</span>:</p>
<!-- Equation labels as ordinary links -->
<div id="vib:ode1:step3c"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\frac{u^1-u^{-1}}{2\Delta t} = 0
\label{vib:ode1:step3c} \tag{6}
\thinspace .
\end{equation}
\]</div>
</div>
<div class="section" id="step-4-formulating-a-recursive-algorithm">
<h3><span class="section-number">1.2.4. </span>Step 4: Formulating a recursive algorithm<a class="headerlink" href="#step-4-formulating-a-recursive-algorithm" title="Permalink to this headline">¶</a></h3>
<p>To formulate the computational algorithm, we assume that we
have already computed <span class="math notranslate nohighlight">\(u^{n-1}\)</span> and <span class="math notranslate nohighlight">\(u^n\)</span>, such that <span class="math notranslate nohighlight">\(u^{n+1}\)</span> is the
unknown value to be solved for:</p>
<!-- Equation labels as ordinary links -->
<div id="vib:ode1:step4"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u^{n+1} = 2u^n - u^{n-1} - \Delta t^2\omega^2 u^n
\thinspace .
\label{vib:ode1:step4} \tag{7}
\end{equation}
\]</div>
<p>The computational algorithm is simply to apply (<a class="reference external" href="#vib:ode1:step4">7</a>)
successively for <span class="math notranslate nohighlight">\(n=1,2,\ldots,N_t-1\)</span>. This numerical scheme sometimes
goes under the name
Stoermer’s
method, <a class="reference external" href="http://en.wikipedia.org/wiki/Verlet_integration">Verlet integration</a>, or the Leapfrog method
(one should note
that Leapfrog is used for many quite different methods for quite
different differential equations!).</p>
</div>
<div class="section" id="computing-the-first-step">
<h3><span class="section-number">1.2.5. </span>Computing the first step<a class="headerlink" href="#computing-the-first-step" title="Permalink to this headline">¶</a></h3>
<p>We observe that (<a class="reference external" href="#vib:ode1:step4">7</a>) cannot be used for <span class="math notranslate nohighlight">\(n=0\)</span> since
the computation of <span class="math notranslate nohighlight">\(u^1\)</span> then involves the undefined value <span class="math notranslate nohighlight">\(u^{-1}\)</span>
at <span class="math notranslate nohighlight">\(t=-\Delta t\)</span>. The discretization of the initial condition
then comes to our rescue: (<a class="reference external" href="#vib:ode1:step3c">6</a>) implies <span class="math notranslate nohighlight">\(u^{-1} = u^1\)</span>
and this relation can be combined with (<a class="reference external" href="#vib:ode1:step4">7</a>)
for <span class="math notranslate nohighlight">\(n=0\)</span> to yield a value for <span class="math notranslate nohighlight">\(u^1\)</span>:</p>
<div class="math notranslate nohighlight">
\[
u^1 = 2u^0 - u^{1} - \Delta t^2 \omega^2 u^0,
\]</div>
<p>which reduces to</p>
<!-- Equation labels as ordinary links -->
<div id="vib:ode1:step4b"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u^1 = u^0 - \frac{1}{2} \Delta t^2 \omega^2 u^0
\thinspace .
\label{vib:ode1:step4b} \tag{8}
\end{equation}
\]</div>
<p><a class="reference external" href="#vib:exer:step4b:alt">Exercise 5: Use a Taylor polynomial to compute <span class="math notranslate nohighlight">\(u^1\)</span></a> asks you to perform an alternative derivation
and also to generalize the initial condition to <span class="math notranslate nohighlight">\(u^{\prime}(0)=V\neq 0\)</span>.</p>
</div>
<div class="section" id="the-computational-algorithm">
<h3><span class="section-number">1.2.6. </span>The computational algorithm<a class="headerlink" href="#the-computational-algorithm" title="Permalink to this headline">¶</a></h3>
<p>The steps for solving (<a class="reference external" href="#vib:ode1">1</a>) become</p>
<ol class="simple">
<li><p><span class="math notranslate nohighlight">\(u^0=I\)</span></p></li>
<li><p>compute <span class="math notranslate nohighlight">\(u^1\)</span> from (<a class="reference external" href="#vib:ode1:step4b">8</a>)</p></li>
<li><p>for <span class="math notranslate nohighlight">\(n=1,2,\ldots,N_t-1\)</span>: compute <span class="math notranslate nohighlight">\(u^{n+1}\)</span> from (<a class="reference external" href="#vib:ode1:step4">7</a>)</p></li>
</ol>
<p>The algorithm is more precisely expressed directly in Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># mesh points in time</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>          <span class="c1"># constant time step</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>           <span class="c1"># solution</span>

<span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
<span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
    <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<p><strong>Remark on using <code class="docutils literal notranslate"><span class="pre">w</span></code> for <span class="math notranslate nohighlight">\(\omega\)</span> in computer code.</strong></p>
<p>In the code, we use <code class="docutils literal notranslate"><span class="pre">w</span></code> as the symbol for <span class="math notranslate nohighlight">\(\omega\)</span>.
The reason is that the authors prefer <code class="docutils literal notranslate"><span class="pre">w</span></code> for readability
and comparison with the mathematical <span class="math notranslate nohighlight">\(\omega\)</span> instead of
the full word <code class="docutils literal notranslate"><span class="pre">omega</span></code> as variable name.</p>
</div>
<div class="section" id="operator-notation">
<h3><span class="section-number">1.2.7. </span>Operator notation<a class="headerlink" href="#operator-notation" title="Permalink to this headline">¶</a></h3>
<p>We may write the scheme using a compact difference notation
listed in the <a class="reference external" href="../A_formulas/formulas.ipynb#sec:form:fdop">Finite difference operator notation</a> section
(see also Section 1.1.8 in <a class="reference external" href="#Langtangen_decay">[Langtangen_decay]</a>).
The difference (<a class="reference external" href="#vib:ode1:step3">4</a>) has the operator
notation <span class="math notranslate nohighlight">\([D_tD_t u]^n\)</span> such that we can write:</p>
<!-- Equation labels as ordinary links -->
<div id="vib:ode1:step4:op"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
[D_tD_t u  + \omega^2 u = 0]^n
\thinspace .
\label{vib:ode1:step4:op} \tag{9}
\end{equation}
\]</div>
<p>Note that <span class="math notranslate nohighlight">\([D_tD_t u]^n\)</span> means applying a central difference with step <span class="math notranslate nohighlight">\(\Delta t/2\)</span> twice:</p>
<div class="math notranslate nohighlight">
\[
[D_t(D_t u)]^n = \frac{[D_t u]^{n+\frac{1}{2}} - [D_t u]^{n-\frac{1}{2}}}{\Delta t}
\]</div>
<p>which is written out as</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{\Delta t}\left(\frac{u^{n+1}-u^n}{\Delta t} - \frac{u^{n}-u^{n-1}}{\Delta t}\right) = \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
\thinspace .
\]</div>
<p>The discretization of initial conditions can in the operator notation
be expressed as</p>
<!-- Equation labels as ordinary links -->
<div id="_auto1"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
[u = I]^0,\quad [D_{2t} u = 0]^0,
\label{_auto1} \tag{10}
\end{equation}
\]</div>
<p>where the operator <span class="math notranslate nohighlight">\([D_{2t} u]^n\)</span> is defined as</p>
<!-- Equation labels as ordinary links -->
<div id="_auto2"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
[D_{2t} u]^n = \frac{u^{n+1} - u^{n-1}}{2\Delta t}
\thinspace .
\label{_auto2} \tag{11}
\end{equation}
\]</div>
</div>
</div>
</div>
<div class="section" id="implementation">
<h1><span class="section-number">2. </span>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h1>
<div id="vib:impl1"></div>
<div class="section" id="making-a-solver-function">
<h2><span class="section-number">2.1. </span>Making a solver function<a class="headerlink" href="#making-a-solver-function" title="Permalink to this headline">¶</a></h2>
<div id="vib:impl1:solver"></div>
<p>The algorithm from the previous section is readily translated to
a complete Python function for computing and returning
<span class="math notranslate nohighlight">\(u^0,u^1,\ldots,u^{N_t}\)</span> and <span class="math notranslate nohighlight">\(t_0,t_1,\ldots,t_{N_t}\)</span>, given the
input <span class="math notranslate nohighlight">\(I\)</span>, <span class="math notranslate nohighlight">\(\omega\)</span>, <span class="math notranslate nohighlight">\(\Delta t\)</span>, and <span class="math notranslate nohighlight">\(T\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># NBVAL_IGNORE_OUTPUT</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">devito</span> <span class="kn">import</span> <span class="n">Dimension</span><span class="p">,</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">TimeFunction</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">solve</span><span class="p">,</span> <span class="n">Operator</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load -s solver, src-vib/vib_undamped.py</span>
<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;&#39; + w**2*u = 0 for t in (0,T], u(0)=I and u&#39;(0)=0,</span>
<span class="sd">    by a central finite difference method with time step dt.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">Dimension</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="n">Constant</span><span class="p">(</span><span class="s1">&#39;h_t&#39;</span><span class="p">))</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">TimeFunction</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="p">(</span><span class="n">t</span><span class="p">,),</span>
                     <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">,),</span> <span class="n">space_order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">u</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">eqn</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">dt2</span> <span class="o">+</span> <span class="p">(</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">u</span>
    <span class="n">stencil</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">forward</span><span class="p">,</span> <span class="n">solve</span><span class="p">(</span><span class="n">eqn</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">forward</span><span class="p">))</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">(</span><span class="n">stencil</span><span class="p">)</span>
    <span class="n">op</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">h_t</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">t_M</span><span class="o">=</span><span class="n">Nt</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We have imported <code class="docutils literal notranslate"><span class="pre">numpy</span></code> and <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> under the names <code class="docutils literal notranslate"><span class="pre">np</span></code> and <code class="docutils literal notranslate"><span class="pre">plt</span></code>, as this is very common in the Python scientific computing community and a good programming habit (since we explicitly
see where the different functions come from).</p>
<p>A function for plotting the numerical and the exact solution is also
convenient to have:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load -s u_exact, src-vib/vib_undamped.py</span>
<span class="k">def</span> <span class="nf">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load -s visualize, src-vib/vib_undamped.py</span>
<span class="k">def</span> <span class="nf">visualize</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s1">&#39;r--o&#39;</span><span class="p">)</span>
    <span class="n">t_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1001</span><span class="p">)</span>  <span class="c1"># very fine mesh for u_e</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;numerical&#39;</span><span class="p">,</span> <span class="s1">&#39;exact&#39;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;dt=</span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">umin</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">min</span><span class="p">();</span>  <span class="n">umax</span> <span class="o">=</span> <span class="o">-</span><span class="n">umin</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;tmp1.png&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;tmp1.pdf&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>A corresponding main program calling these functions to simulate
a given number of periods (<code class="docutils literal notranslate"><span class="pre">num_periods</span></code>) may take the form</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">I</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">w</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">num_periods</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>    <span class="c1">#  one period</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">num_periods</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
<span class="n">visualize</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Operator `Kernel` run in 0.01 s
</pre></div>
</div>
<img alt="../../_images/vib_undamped_37_1.png" src="../../_images/vib_undamped_37_1.png" />
</div>
</div>
<p>Adjusting some of the input parameters via the command line can be
handy. Here is a code segment using the <code class="docutils literal notranslate"><span class="pre">ArgumentParser</span></code> tool in
the <code class="docutils literal notranslate"><span class="pre">argparse</span></code> module to define option value (<code class="docutils literal notranslate"><span class="pre">--option</span> <span class="pre">value</span></code>)
pairs on the command line:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">argparse</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--I&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--w&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--dt&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--num_periods&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
<span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">num_periods</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">num_periods</span>
</pre></div>
</div>
<p>Such parsing of the command line is explained in more detail in Section 5.2.3 in
<a class="reference external" href="#Langtangen_decay">[Langtangen_decay]</a>.</p>
<p>A typical execution goes like</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    Terminal&gt; python vib_undamped.py --num_periods 20 --dt 0.1
</pre></div>
</div>
</div>
<div class="section" id="verification">
<h2><span class="section-number">2.2. </span>Verification<a class="headerlink" href="#verification" title="Permalink to this headline">¶</a></h2>
<div id="vib:ode1:verify"></div>
<div class="section" id="manual-calculation">
<h3><span class="section-number">2.2.1. </span>Manual calculation<a class="headerlink" href="#manual-calculation" title="Permalink to this headline">¶</a></h3>
<p>The simplest type of verification, which is also instructive for understanding
the algorithm, is to compute <span class="math notranslate nohighlight">\(u^1\)</span>, <span class="math notranslate nohighlight">\(u^2\)</span>, and <span class="math notranslate nohighlight">\(u^3\)</span>
with the aid of a calculator
and make a function for comparing these results with those from the <code class="docutils literal notranslate"><span class="pre">solver</span></code>
function. The <code class="docutils literal notranslate"><span class="pre">test_three_steps</span></code> function in
the file <span class="xref myst"><code class="docutils literal notranslate"><span class="pre">vib_undamped.py</span></code></span>
shows the details of how we use the hand calculations to test the code:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load -s test_three_steps, src-vib/vib_undamped.py</span>
<span class="k">def</span> <span class="nf">test_three_steps</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
    <span class="n">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">;</span>  <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>  <span class="n">T</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">u_by_hand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.000000000000000</span><span class="p">,</span>
                          <span class="mf">0.802607911978213</span><span class="p">,</span>
                          <span class="mf">0.288358920740053</span><span class="p">])</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_by_hand</span> <span class="o">-</span> <span class="n">u</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
</div>
</div>
<p>This function is a proper <em>test function</em>,
compliant with the pytest and nose testing
framework for Python code, because</p>
<ul class="simple">
<li><p>the function name begins with <code class="docutils literal notranslate"><span class="pre">test_</span></code></p></li>
<li><p>the function takes no arguments</p></li>
<li><p>the test is formulated as a boolean condition and executed by <code class="docutils literal notranslate"><span class="pre">assert</span></code></p></li>
</ul>
<p>We shall in this book implement all software verification via such
proper test functions, also known as unit testing.</p>
<p>See Section 5.3.2 in <a class="reference external" href="#Langtangen_decay">[Langtangen_decay]</a>
for more details on how to construct test functions and utilize nose
or pytest for automatic execution of tests. Our recommendation is to
use pytest. With this choice, you can
run all test functions in <code class="docutils literal notranslate"><span class="pre">vib_undamped.py</span></code> by</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    Terminal&gt; py.test -s -v vib_undamped.py
    ============================= test session starts ======...
    platform linux2 -- Python 2.7.9 -- ...
    collected 2 items
    
    vib_undamped.py::test_three_steps PASSED
    vib_undamped.py::test_convergence_rates PASSED
    
    =========================== 2 passed in 0.19 seconds ===...
</pre></div>
</div>
</div>
<div class="section" id="testing-very-simple-polynomial-solutions">
<h3><span class="section-number">2.2.2. </span>Testing very simple polynomial solutions<a class="headerlink" href="#testing-very-simple-polynomial-solutions" title="Permalink to this headline">¶</a></h3>
<p>Constructing test problems where the exact solution is constant or
linear helps initial debugging and verification as one expects any
reasonable numerical method to reproduce such solutions to machine
precision.  Second-order accurate methods will often also reproduce a
quadratic solution.  Here <span class="math notranslate nohighlight">\([D_tD_tt^2]^n=2\)</span>, which is the exact
result. A solution <span class="math notranslate nohighlight">\(u=t^2\)</span> leads to <span class="math notranslate nohighlight">\(u^{\prime\prime}+\omega^2 u=2 + (\omega
t)^2\neq 0\)</span>.  We must therefore add a source in the equation: <span class="math notranslate nohighlight">\(u^{\prime\prime} +
\omega^2 u = f\)</span> to allow a solution <span class="math notranslate nohighlight">\(u=t^2\)</span> for <span class="math notranslate nohighlight">\(f=2 + (\omega t)^2\)</span>.  By
simple insertion we can show that the mesh function <span class="math notranslate nohighlight">\(u^n = t_n^2\)</span> is
also a solution of the discrete equations.  <a class="reference external" href="#vib:exer:undamped:verify:linquad">Problem 1: Use linear/quadratic functions for verification</a> asks you to carry out all
details to show that linear and quadratic solutions are solutions
of the discrete equations. Such results are very useful for debugging
and verification. You are strongly encouraged to do this problem now!</p>
</div>
<div class="section" id="checking-convergence-rates">
<h3><span class="section-number">2.2.3. </span>Checking convergence rates<a class="headerlink" href="#checking-convergence-rates" title="Permalink to this headline">¶</a></h3>
<p>Empirical computation of convergence rates yields a good method for
verification. The method and its computational details are explained
in detail in Section 3.1.6 in <a class="reference external" href="#Langtangen_decay">[Langtangen_decay]</a>.  Readers not
familiar with the concept should look up this reference before
proceeding.</p>
<p>In the present problem, computing convergence rates means that we must</p>
<ul class="simple">
<li><p>perform <span class="math notranslate nohighlight">\(m\)</span> simulations, halving the time steps as: <span class="math notranslate nohighlight">\(\Delta t_i=2^{-i}\Delta t_0\)</span>, <span class="math notranslate nohighlight">\(i=1,\ldots,m-1\)</span>, and <span class="math notranslate nohighlight">\(\Delta t_i\)</span> is the time step used in simulation <span class="math notranslate nohighlight">\(i\)</span>;</p></li>
<li><p>compute the <span class="math notranslate nohighlight">\(L^2\)</span> norm of the error,
<span class="math notranslate nohighlight">\(E_i=\sqrt{\Delta t_i\sum_{n=0}^{N_t-1}(u^n-u(t_n))^2}\)</span> in each case;</p></li>
<li><p>estimate the convergence rates <span class="math notranslate nohighlight">\(r_i\)</span> based on two consecutive
experiments <span class="math notranslate nohighlight">\((\Delta t_{i-1}, E_{i-1})\)</span> and <span class="math notranslate nohighlight">\((\Delta t_{i}, E_{i})\)</span>,
assuming <span class="math notranslate nohighlight">\(E_i=C(\Delta t_i)^{r}\)</span> and <span class="math notranslate nohighlight">\(E_{i-1}=C(\Delta t_{i-1})^{r}\)</span>, where <span class="math notranslate nohighlight">\(C\)</span> is a constant.
From these equations it follows that
<span class="math notranslate nohighlight">\(r = \ln (E_{i-1}/E_i)/\ln (\Delta t_{i-1}/\Delta t_i)\)</span>. Since this <span class="math notranslate nohighlight">\(r\)</span>
will vary with <span class="math notranslate nohighlight">\(i\)</span>, we equip it with an index and call it <span class="math notranslate nohighlight">\(r_{i-1}\)</span>,
where <span class="math notranslate nohighlight">\(i\)</span> runs from <span class="math notranslate nohighlight">\(1\)</span> to <span class="math notranslate nohighlight">\(m-1\)</span>.</p></li>
</ul>
<p>The computed rates <span class="math notranslate nohighlight">\(r_0,r_1,\ldots,r_{m-2}\)</span> hopefully converge to the
number 2 in the present
problem, because theory (from the section <a class="reference external" href="#vib:ode1:analysis">Analysis of the numerical scheme</a>) shows
that the error of the numerical method we use behaves like <span class="math notranslate nohighlight">\(\Delta t^2\)</span>.
The convergence of the sequence <span class="math notranslate nohighlight">\(r_0,r_1,\ldots,r_{m-2}\)</span>
demands that the time steps
<span class="math notranslate nohighlight">\(\Delta t_i\)</span> are sufficiently small for the error model <span class="math notranslate nohighlight">\(E_i=C(\Delta t_i)^r\)</span>
to be valid.</p>
<p>All the implementational details of computing the sequence
<span class="math notranslate nohighlight">\(r_0,r_1,\ldots,r_{m-2}\)</span> appear below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load -s convergence_rates, src-vib/vib_undamped.py</span>
<span class="k">def</span> <span class="nf">convergence_rates</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">solver_function</span><span class="p">,</span> <span class="n">num_periods</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return m-1 empirical estimates of the convergence rate</span>
<span class="sd">    based on m simulations, where the time step is halved</span>
<span class="sd">    for each simulation.</span>
<span class="sd">    solver_function(I, w, dt, T) solves each problem, where T</span>
<span class="sd">    is based on simulation for num_periods periods.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mf">0.35</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="mf">0.3</span>       <span class="c1"># just chosen values</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>              <span class="c1"># period</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">P</span><span class="o">/</span><span class="mi">30</span>               <span class="c1"># 30 time step per period 2*pi/w</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">num_periods</span>

    <span class="n">dt_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">E_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver_function</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
        <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">u_e</span><span class="o">-</span><span class="n">u</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">dt_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">E_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">/</span><span class="mi">2</span>

    <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">E_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">E_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span>
         <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">E_values</span><span class="p">,</span> <span class="n">dt_values</span>
</pre></div>
</div>
</div>
</div>
<p>The error analysis in the section <a class="reference external" href="#vib:ode1:analysis">Analysis of the numerical scheme</a> is quite
detailed and suggests that <span class="math notranslate nohighlight">\(r=2\)</span>.
mathcal{I}_t is also a intuitively reasonable result, since we used a
second-order accurate finite difference approximation <span class="math notranslate nohighlight">\([D_tD_tu]^n\)</span> to
the ODE and a second-order accurate finite difference formula for the
initial condition for <span class="math notranslate nohighlight">\(u^{\prime}\)</span>.</p>
<p>In the present problem, when <span class="math notranslate nohighlight">\(\Delta t_0\)</span> corresponds to 30 time steps
per period, the returned <code class="docutils literal notranslate"><span class="pre">r</span></code> list has all its values equal to 2.00
(if rounded to two decimals). This amazingly accurate result means that all
<span class="math notranslate nohighlight">\(\Delta t_i\)</span> values are well into the asymptotic regime where the
error model <span class="math notranslate nohighlight">\(E_i = C(\Delta t_i)^r\)</span> is valid.</p>
<p>We can now construct a proper test function that computes convergence rates
and checks that the final (and usually the best) estimate is sufficiently
close to 2. Here, a rough tolerance of 0.1 is enough. Later, we will argue
for an improvement by adjusting omega and include also that case in our test
function here. The unit test goes like</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load -s test_convergence_rates, src-vib/vib_undamped.py</span>
<span class="k">def</span> <span class="nf">test_convergence_rates</span><span class="p">():</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span>
        <span class="n">m</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">solver_function</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span> <span class="n">num_periods</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="c1"># Accept rate to 1 decimal place</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>
    <span class="c1"># Test that adjusted w obtains 4th order convergence</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span>
        <span class="n">m</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">solver_function</span><span class="o">=</span><span class="n">solver_adjust_w</span><span class="p">,</span> <span class="n">num_periods</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;adjust w rates:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">4.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
</div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">solver_adjust_w</span></code> is a slight variation on the original <code class="docutils literal notranslate"><span class="pre">solver</span></code> function, as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load -s solver_adjust_w, src-vib/vib_undamped.py</span>
<span class="k">def</span> <span class="nf">solver_adjust_w</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">adjust_w</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;&#39; + w**2*u = 0 for t in (0,T], u(0)=I and u&#39;(0)=0,</span>
<span class="sd">    by a central finite difference method with time step dt.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">Dimension</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="n">Constant</span><span class="p">(</span><span class="s1">&#39;h_t&#39;</span><span class="p">))</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">TimeFunction</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="p">(</span><span class="n">t</span><span class="p">,),</span>
                     <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">,),</span> <span class="n">space_order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">w_adj</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">24.</span><span class="p">)</span> <span class="k">if</span> <span class="n">adjust_w</span> <span class="k">else</span> <span class="n">w</span>

    <span class="n">u</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">eqn</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">dt2</span> <span class="o">+</span> <span class="p">(</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">u</span>
    <span class="n">stencil</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">forward</span><span class="p">,</span> <span class="n">solve</span><span class="p">(</span><span class="n">eqn</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">forward</span><span class="p">))</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">(</span><span class="n">stencil</span><span class="p">)</span>
    <span class="n">op</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">h_t</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">t_M</span><span class="o">=</span><span class="n">Nt</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The complete code appears in the file <span class="xref myst"><code class="docutils literal notranslate"><span class="pre">vib_undamped.py</span></code></span>.</p>
</div>
<div class="section" id="visualizing-convergence-rates-with-slope-markers">
<h3><span class="section-number">2.2.4. </span>Visualizing convergence rates with slope markers<a class="headerlink" href="#visualizing-convergence-rates-with-slope-markers" title="Permalink to this headline">¶</a></h3>
<p>Tony S. Yu has written a script <a class="reference external" href="http://goo.gl/A4Utm7"><code class="docutils literal notranslate"><span class="pre">plotslopes.py</span></code></a>
that is very useful to indicate the slope of a graph, especially
a graph like <span class="math notranslate nohighlight">\(\ln E = r\ln \Delta t + \ln C\)</span> arising from the model
<span class="math notranslate nohighlight">\(E=C\Delta t^r\)</span>. A copy of the script resides in the <span class="xref myst"><code class="docutils literal notranslate"><span class="pre">src-vib</span></code></span>
directory. Let us use it to compare the original method for <span class="math notranslate nohighlight">\(u'' + \omega^2u =0\)</span>
with the same method applied to the equation with a modified
<span class="math notranslate nohighlight">\(\omega\)</span>. We make log-log plots of the error versus <span class="math notranslate nohighlight">\(\Delta t\)</span>.
For each curve we attach a slope marker using the <code class="docutils literal notranslate"><span class="pre">slope_marker((x,y),</span> <span class="pre">r)</span></code>
function from <code class="docutils literal notranslate"><span class="pre">plotslopes.py</span></code>, where <code class="docutils literal notranslate"><span class="pre">(x,y)</span></code> is the position of the
marker and <code class="docutils literal notranslate"><span class="pre">r</span></code> and the slope (<span class="math notranslate nohighlight">\((r,1)\)</span>), here (2,1) and (4,1).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load -s plot_convergence_rates, src-vib/vib_undamped.py</span>
<span class="k">def</span> <span class="nf">plot_convergence_rates</span><span class="p">():</span>
    <span class="n">r2</span><span class="p">,</span> <span class="n">E2</span><span class="p">,</span> <span class="n">dt2</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span>
        <span class="n">m</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">solver_function</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span> <span class="n">num_periods</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">dt2</span><span class="p">,</span> <span class="n">E2</span><span class="p">)</span>
    <span class="n">r4</span><span class="p">,</span> <span class="n">E4</span><span class="p">,</span> <span class="n">dt4</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span>
        <span class="n">m</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">solver_function</span><span class="o">=</span><span class="n">solver_adjust_w</span><span class="p">,</span> <span class="n">num_periods</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">dt4</span><span class="p">,</span> <span class="n">E4</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;original scheme&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;adjusted $\omega$&#39;</span><span class="p">],</span>
               <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Convergence of finite difference methods&#39;</span><span class="p">)</span>
    <span class="c1"># from plotslopes import slope_marker</span>
    <span class="c1"># slope_marker((dt2[1], E2[1]), (2,1))</span>
    <span class="c1"># slope_marker((dt4[1], E4[1]), (4,1))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;tmp_convrate.png&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;tmp_convrate.pdf&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p><a class="reference external" href="#vib:ode1:verify:fig:convrate_curve">Figure</a> displays the two curves
with the markers. The match of the curve slope and the marker slope is
excellent.</p>
<!-- dom:FIGURE: [fig-vib/vib_adjusted_w_rate_curves.png, width=500 frac=0.7] Empirical convergence rate curves with special slope marker. <div id="vib:ode1:verify:fig:convrate_curve"></div> -->
<!-- begin figure -->
<div id="vib:ode1:verify:fig:convrate_curve"></div>
<p>Empirical convergence rate curves with special slope marker.</p>
<img src="fig-vib/vib_adjusted_w_rate_curves.png" width=500>
<!-- end figure -->
</div>
</div>
<div class="section" id="scaled-model">
<h2><span class="section-number">2.3. </span>Scaled model<a class="headerlink" href="#scaled-model" title="Permalink to this headline">¶</a></h2>
<p>It is advantageous to use dimensionless variables in simulations,
because fewer parameters need to be set. The present problem is made
dimensionless by introducing dimensionless variables <span class="math notranslate nohighlight">\(\bar t = t/t_c\)</span>
and <span class="math notranslate nohighlight">\(\bar u = u/u_c\)</span>, where <span class="math notranslate nohighlight">\(t_c\)</span> and <span class="math notranslate nohighlight">\(u_c\)</span> are characteristic scales
for <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(u\)</span>, respectively. We refer to Section 2.2.1 in
<a class="reference external" href="#Langtangen_scaling">[Langtangen_scaling]</a> for all details about this scaling.</p>
<p>The scaled ODE problem reads</p>
<div class="math notranslate nohighlight">
\[
\frac{u_c}{t_c^2}\frac{d^2\bar u}{d\bar t^2} + u_c\bar u = 0,\quad
u_c\bar u(0) = I,\ \frac{u_c}{t_c}\frac{d\bar u}{d\bar t}(0)=0\thinspace .
\]</div>
<p>A common choice is to take <span class="math notranslate nohighlight">\(t_c\)</span> as one period of
the oscillations, <span class="math notranslate nohighlight">\(t_c = 2\pi/w\)</span>, and <span class="math notranslate nohighlight">\(u_c=I\)</span>.
This gives the dimensionless model</p>
<!-- Equation labels as ordinary links -->
<div id="vib:ode1:model:scaled"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\frac{d^2\bar u}{d\bar t^2} + 4\pi^2 \bar u = 0,\quad \bar u(0)=1,\ 
\bar u^{\prime}(0)=0\thinspace .
\label{vib:ode1:model:scaled} \tag{13}
\end{equation}
\]</div>
<p>Observe that there are no physical parameters in (<a class="reference external" href="#vib:ode1:model:scaled">13</a>)!
We can therefore perform
a single numerical simulation <span class="math notranslate nohighlight">\(\bar u(\bar t)\)</span> and afterwards
recover any <span class="math notranslate nohighlight">\(u(t; \omega, I)\)</span> by</p>
<div class="math notranslate nohighlight">
\[
u(t;\omega, I) = u_c\bar u(t/t_c) = I\bar u(\omega t/(2\pi))\thinspace .
\]</div>
<p>We can easily check this assertion: the solution of the scaled problem
is <span class="math notranslate nohighlight">\(\bar u(\bar t) = \cos(2\pi\bar t)\)</span>. The formula for <span class="math notranslate nohighlight">\(u\)</span> in terms
of <span class="math notranslate nohighlight">\(\bar u\)</span> gives <span class="math notranslate nohighlight">\(u = I\cos(\omega t)\)</span>, which is nothing but the solution
of the original problem with dimensions.</p>
<p>The scaled model can be run by calling <code class="docutils literal notranslate"><span class="pre">solver(I=1,</span> <span class="pre">w=2*pi,</span> <span class="pre">dt,</span> <span class="pre">T)</span></code>.
Each period is now 1 and <code class="docutils literal notranslate"><span class="pre">T</span></code> simply counts the number of periods.
Choosing <code class="docutils literal notranslate"><span class="pre">dt</span></code> as <code class="docutils literal notranslate"><span class="pre">1./M</span></code> gives <code class="docutils literal notranslate"><span class="pre">M</span></code> time steps per period.</p>
</div>
</div>
<div class="section" id="visualization-of-long-time-simulations">
<h1><span class="section-number">3. </span>Visualization of long time simulations<a class="headerlink" href="#visualization-of-long-time-simulations" title="Permalink to this headline">¶</a></h1>
<div id="vib:ode1:longseries"></div>
<p><a class="reference external" href="#vib:ode1:2dt">Figure</a> shows a comparison of the exact and numerical
solution for the scaled model (<a class="reference external" href="#vib:ode1:model:scaled">13</a>) with
<span class="math notranslate nohighlight">\(\Delta t=0.1, 0.05\)</span>.
From the plot we make the following observations:</p>
<ul class="simple">
<li><p>The numerical solution seems to have correct amplitude.</p></li>
<li><p>There is an angular frequency error which is reduced by decreasing the time step.</p></li>
<li><p>The total angular frequency error grows with time.</p></li>
</ul>
<p>By angular frequency error we mean that the numerical angular frequency differs
from the exact <span class="math notranslate nohighlight">\(\omega\)</span>. This is evident by looking
at the peaks of the numerical solution: these have incorrect
positions compared with the peaks of the exact cosine solution. The
effect can be mathematically expressed by writing the numerical solution
as <span class="math notranslate nohighlight">\(I\cos\tilde\omega t\)</span>, where <span class="math notranslate nohighlight">\(\tilde\omega\)</span> is not exactly
equal to <span class="math notranslate nohighlight">\(\omega\)</span>. Later, we shall mathematically
quantify this numerical angular frequency <span class="math notranslate nohighlight">\(\tilde\omega\)</span>.</p>
<p>Here, we show the effect of halving the time step on the error.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">I</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">w</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">num_periods</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>    <span class="c1">#  one period</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">num_periods</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">u_1</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
<span class="n">visualize</span><span class="p">(</span><span class="n">u_1</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Operator `Kernel` run in 0.01 s
</pre></div>
</div>
<img alt="../../_images/vib_undamped_62_1.png" src="../../_images/vib_undamped_62_1.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dt</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">u_2</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
<span class="n">visualize</span><span class="p">(</span><span class="n">u_2</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Operator `Kernel` run in 0.01 s
</pre></div>
</div>
<img alt="../../_images/vib_undamped_63_1.png" src="../../_images/vib_undamped_63_1.png" />
</div>
</div>
<div class="section" id="using-a-moving-plot-window">
<h2><span class="section-number">3.1. </span>Using a moving plot window<a class="headerlink" href="#using-a-moving-plot-window" title="Permalink to this headline">¶</a></h2>
<p>In vibration problems it is often of interest to investigate the system’s
behavior over long time intervals. Errors in the angular frequency accumulate
and become more visible as time grows. We can investigate long
time series by introducing a moving plot window that can move along with
the <span class="math notranslate nohighlight">\(p\)</span> most recently computed periods of the solution. The
<a class="reference external" href="https://github.com/hplgit/scitools">SciTools</a> package contains
a convenient tool for this: <code class="docutils literal notranslate"><span class="pre">MovingPlotWindow</span></code>. Typing
<code class="docutils literal notranslate"><span class="pre">pydoc</span> <span class="pre">scitools.MovingPlotWindow</span></code> shows a demo and a description of its use.
The function below utilizes the moving plot window and is in fact
called by the <code class="docutils literal notranslate"><span class="pre">main</span></code> function in the <code class="docutils literal notranslate"><span class="pre">vib_undamped</span></code> module
if the number of periods in the simulation exceeds 10.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load -s visualize_front, src-vib/vib_undamped.py</span>
<span class="k">def</span> <span class="nf">visualize_front</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">skip_frames</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Visualize u and the exact solution vs t, using a</span>
<span class="sd">    moving plot window and continuous drawing of the</span>
<span class="sd">    curves as they evolve in time.</span>
<span class="sd">    Makes it easy to plot very long time series.</span>
<span class="sd">    Plots are saved to files if savefig is True.</span>
<span class="sd">    Only each skip_frames-th plot is saved (e.g., if</span>
<span class="sd">    skip_frame=10, only each 10th plot is saved to file;</span>
<span class="sd">    this is convenient if plot files corresponding to</span>
<span class="sd">    different time steps are to be compared).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">scitools.std</span> <span class="k">as</span> <span class="nn">st</span>
    <span class="kn">from</span> <span class="nn">scitools.MovingPlotWindow</span> <span class="kn">import</span> <span class="n">MovingPlotWindow</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>

    <span class="c1"># Remove all old plot files tmp_*.png</span>
    <span class="kn">import</span> <span class="nn">glob</span><span class="o">,</span> <span class="nn">os</span>
    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;tmp_*.png&#39;</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>  <span class="c1"># one period</span>
    <span class="n">umin</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">min</span><span class="p">();</span>  <span class="n">umax</span> <span class="o">=</span> <span class="o">-</span><span class="n">umin</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">plot_manager</span> <span class="o">=</span> <span class="n">MovingPlotWindow</span><span class="p">(</span>
        <span class="n">window_width</span><span class="o">=</span><span class="mi">8</span><span class="o">*</span><span class="n">P</span><span class="p">,</span>
        <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span>
        <span class="n">yaxis</span><span class="o">=</span><span class="p">[</span><span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">],</span>
        <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;continuous drawing&#39;</span><span class="p">)</span>
    <span class="n">frame_counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">plot_manager</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">plot_manager</span><span class="o">.</span><span class="n">first_index_in_plot</span>
            <span class="n">st</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;r-1&#39;</span><span class="p">,</span>
                    <span class="n">t</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">I</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)[</span><span class="n">s</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;b-1&#39;</span><span class="p">,</span>
                    <span class="n">title</span><span class="o">=</span><span class="s1">&#39;t=</span><span class="si">%6.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">plot_manager</span><span class="o">.</span><span class="n">axis</span><span class="p">(),</span>
                    <span class="n">show</span><span class="o">=</span><span class="ow">not</span> <span class="n">savefig</span><span class="p">)</span> <span class="c1"># drop window if savefig</span>
            <span class="k">if</span> <span class="n">savefig</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">%</span> <span class="n">skip_frames</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;tmp_</span><span class="si">%04d</span><span class="s1">.png&#39;</span> <span class="o">%</span> <span class="n">frame_counter</span>
                <span class="n">st</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;making plot file&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;at t=</span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
                <span class="n">frame_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">plot_manager</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We run the scaled problem (the default values for the command-line arguments
<code class="docutils literal notranslate"><span class="pre">--I</span></code> and <code class="docutils literal notranslate"><span class="pre">--w</span></code> correspond to the scaled problem) for 40 periods with 20
time steps per period:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    Terminal&gt; python vib_undamped.py --dt 0.05 --num_periods 40
</pre></div>
</div>
<p>The moving plot window is invoked, and we can follow the numerical and exact
solutions as time progresses. From this demo we see that
the angular frequency error is small in the beginning, and that it becomes more
prominent with time. A new run with <span class="math notranslate nohighlight">\(\Delta t=0.1\)</span> (i.e., only 10 time steps per period)
clearly shows that the phase errors become significant even earlier
in the time series, deteriorating the solution further.</p>
</div>
<div class="section" id="making-animations">
<h2><span class="section-number">3.2. </span>Making animations<a class="headerlink" href="#making-animations" title="Permalink to this headline">¶</a></h2>
<div id="vib:ode1:anim"></div>
<div class="section" id="producing-standard-video-formats">
<h3><span class="section-number">3.2.1. </span>Producing standard video formats<a class="headerlink" href="#producing-standard-video-formats" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">visualize_front</span></code> function stores all the plots in
files whose names are numbered:
<code class="docutils literal notranslate"><span class="pre">tmp_0000.png</span></code>, <code class="docutils literal notranslate"><span class="pre">tmp_0001.png</span></code>, <code class="docutils literal notranslate"><span class="pre">tmp_0002.png</span></code>,
and so on. From these files we may make a movie. The Flash
format is popular,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    Terminal&gt; ffmpeg -r 25 -i tmp_%04d.png -c:v flv movie.flv
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">-r</span></code> option should come first and
describes the number of frames per second in the movie (even if we
would like to have slow movies, keep this number as large as 25,
otherwise files are skipped from the movie). The
<code class="docutils literal notranslate"><span class="pre">-i</span></code> option describes the name of the plot files.
Other formats can be generated by changing the video codec
and equipping the video file with the right extension:</p>
<table border="1">
<thead>
<tr><th align="center">Format</th> <th align="center">    Codec and filename    </th> </tr>
</thead>
<tbody>
<tr><td align="left">   Flash     </td> <td align="left">   <code>-c:v flv movie.flv</code>          </td> </tr>
<tr><td align="left">   MP4       </td> <td align="left">   <code>-c:v libx264 movie.mp4</code>      </td> </tr>
<tr><td align="left">   WebM      </td> <td align="left">   <code>-c:v libvpx movie.webm</code>      </td> </tr>
<tr><td align="left">   Ogg       </td> <td align="left">   <code>-c:v libtheora movie.ogg</code>    </td> </tr>
</tbody>
</table>
<p>The video file can be played by some video player like <code class="docutils literal notranslate"><span class="pre">vlc</span></code>, <code class="docutils literal notranslate"><span class="pre">mplayer</span></code>,
<code class="docutils literal notranslate"><span class="pre">gxine</span></code>, or <code class="docutils literal notranslate"><span class="pre">totem</span></code>, e.g.,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    Terminal&gt; vlc movie.webm
</pre></div>
</div>
<p>A web page can also be used to play the movie. Today’s standard is
to use the HTML5 <code class="docutils literal notranslate"><span class="pre">video</span></code> tag:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    &lt;video autoplay loop controls
           width=&#39;640&#39; height=&#39;365&#39; preload=&#39;none&#39;&gt;
    &lt;source src=&#39;movie.webm&#39;  type=&#39;video/webm; codecs=&quot;vp8, vorbis&quot;&#39;&gt;
    &lt;/video&gt;
</pre></div>
</div>
<p>Modern browsers do not support all of the video formats.
MP4 is needed to successfully play the videos on Apple devices
that use the Safari browser.
WebM is the preferred format for Chrome, Opera, Firefox, and Internet
Explorer v9+. Flash was a popular format, but older browsers that
required Flash can play MP4. All browsers that work with Ogg can also
work with WebM. This means that to have a video work in all browsers,
the video should be available in the MP4 and WebM formats.
The proper HTML code reads</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    &lt;video autoplay loop controls
           width=&#39;640&#39; height=&#39;365&#39; preload=&#39;none&#39;&gt;
    &lt;source src=&#39;movie.mp4&#39;   type=&#39;video/mp4;
     codecs=&quot;avc1.42E01E, mp4a.40.2&quot;&#39;&gt;
    &lt;source src=&#39;movie.webm&#39;  type=&#39;video/webm;
     codecs=&quot;vp8, vorbis&quot;&#39;&gt;
    &lt;/video&gt;
</pre></div>
</div>
<p>The MP4 format should appear first to ensure that Apple devices will
load the video correctly.</p>
<p><strong>Caution: number the plot files correctly.</strong></p>
<p>To ensure that the individual plot frames are shown in correct order,
it is important to number the files with zero-padded numbers
(0000, 0001, 0002, etc.). The printf format <code class="docutils literal notranslate"><span class="pre">%04d</span></code> specifies an
integer in a field of width 4, padded with zeros from the left.
A simple Unix wildcard file specification like <code class="docutils literal notranslate"><span class="pre">tmp_*.png</span></code>
will then list the frames in the right order. If the numbers in the
filenames were not zero-padded, the frame <code class="docutils literal notranslate"><span class="pre">tmp_11.png</span></code> would appear
before <code class="docutils literal notranslate"><span class="pre">tmp_2.png</span></code> in the movie.</p>
</div>
<div class="section" id="playing-png-files-in-a-web-browser">
<h3><span class="section-number">3.2.2. </span>Playing PNG files in a web browser<a class="headerlink" href="#playing-png-files-in-a-web-browser" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">scitools</span> <span class="pre">movie</span></code> command can create a movie player for a set
of PNG files such that a web browser can be used to watch the movie.
This interface has the advantage that the speed of the movie can
easily be controlled, a feature that scientists often appreciate.
The command for creating an HTML with a player for a set of
PNG files <code class="docutils literal notranslate"><span class="pre">tmp_*.png</span></code> goes like</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    Terminal&gt; scitools movie output_file=vib.html fps=4 tmp_*.png
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">fps</span></code> argument controls the speed of the movie (“frames per second”).</p>
<p>To watch the movie, load the video file <code class="docutils literal notranslate"><span class="pre">vib.html</span></code> into some browser, e.g.,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    Terminal&gt; google-chrome vib.html  # invoke web page
</pre></div>
</div>
<p>Click on <code class="docutils literal notranslate"><span class="pre">Start</span> <span class="pre">movie</span></code> to see the result. Moving this movie to
some other place requires moving <code class="docutils literal notranslate"><span class="pre">vib.html</span></code> <em>and all the PNG files</em>
<code class="docutils literal notranslate"><span class="pre">tmp_*.png</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    Terminal&gt; mkdir vib_dt0.1
    Terminal&gt; mv tmp_*.png vib_dt0.1
    Terminal&gt; mv vib.html vib_dt0.1/index.html
</pre></div>
</div>
</div>
<div class="section" id="making-animated-gif-files">
<h3><span class="section-number">3.2.3. </span>Making animated GIF files<a class="headerlink" href="#making-animated-gif-files" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">convert</span></code> program from the ImageMagick software suite can be
used to produce animated GIF files from a set of PNG files:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    Terminal&gt; convert -delay 25 tmp_vib*.png tmp_vib.gif
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">-delay</span></code> option needs an argument of the delay between each frame,
measured in 1/100 s, so 4 frames/s here gives 25/100 s delay.
Note, however, that in this particular example
with <span class="math notranslate nohighlight">\(\Delta t=0.05\)</span> and 40 periods,
making an animated GIF file out of
the large number of PNG files is a very heavy process and not
considered feasible. Animated GIFs are best suited for animations with
not so many frames and where you want to see each frame and play them
slowly.</p>
<p>[hpl 2: Combine two simulations side by side!]</p>
</div>
</div>
<div class="section" id="using-bokeh-to-compare-graphs">
<h2><span class="section-number">3.3. </span>Using Bokeh to compare graphs<a class="headerlink" href="#using-bokeh-to-compare-graphs" title="Permalink to this headline">¶</a></h2>
<p>Instead of a moving plot frame, one can use tools that allow panning
by the mouse. For example, we can show four periods of several signals in
several plots and then scroll with the mouse through the rest of the
simulation <em>simultaneously</em> in all the plot windows.
The <a class="reference external" href="http://bokeh.pydata.org/en/latest">Bokeh</a> plotting library offers such tools, but the plots must be displayed in
a web browser. The documentation of Bokeh is excellent, so here we just
show how the library can be used to compare a set of <span class="math notranslate nohighlight">\(u\)</span> curves corresponding
to long time simulations. (By the way, the guidance to correct
pronunciation of Bokeh in
the <a class="reference external" href="http://bokeh.pydata.org/en/0.10.0/docs/faq.html#how-do-you-pronounce-bokeh">documentation</a> and on <a class="reference external" href="https://en.wikipedia.org/wiki/Bokeh">Wikipedia</a> is not directly compatible with a <a class="reference external" href="https://www.youtube.com/watch?v=OR8HSHevQTM">YouTube video</a>…).</p>
<p>Imagine we have performed experiments for a set of <span class="math notranslate nohighlight">\(\Delta t\)</span> values.
We want each curve, together with the exact solution, to appear in
a plot, and then arrange all plots in a grid-like fashion:</p>
<!-- dom:FIGURE: [fig-vib/bokeh_gridplot1.png, width=800 frac=1] -->
<!-- begin figure -->
<p></p>
<img src="fig-vib/bokeh_gridplot1.png" width=800>
<!-- end figure -->
<p>Furthermore, we want the axes to couple such that if we move into
the future in one plot, all the other plots follows (note the
displaced <span class="math notranslate nohighlight">\(t\)</span> axes!):</p>
<!-- dom:FIGURE: [fig-vib/bokeh_gridplot2.png, width=800 frac=1] -->
<!-- begin figure -->
<p></p>
<img src="fig-vib/bokeh_gridplot2.png" width=800>
<!-- end figure -->
<p>A function for creating a Bokeh plot, given a list of <code class="docutils literal notranslate"><span class="pre">u</span></code> arrays
and corresponding <code class="docutils literal notranslate"><span class="pre">t</span></code> arrays, is implemented below.
The code combines data from different simulations, described
compactly in a list of strings <code class="docutils literal notranslate"><span class="pre">legends</span></code>.</p>
<p>A particular example using the <code class="docutils literal notranslate"><span class="pre">bokeh_plot</span></code> function appears below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load -s bokeh_plot, src-vib/vib_undamped.py</span>
<span class="k">def</span> <span class="nf">bokeh_plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">legends</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">t_range</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make plots for u vs t using the Bokeh library.</span>
<span class="sd">    u and t are lists (several experiments can be compared).</span>
<span class="sd">    legens contain legend strings for the various u,t pairs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span><span class="p">]</span>  <span class="c1"># wrap in list</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span>  <span class="c1"># wrap in list</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">legends</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">legends</span> <span class="o">=</span> <span class="p">[</span><span class="n">legends</span><span class="p">]</span>  <span class="c1"># wrap in list</span>

    <span class="kn">import</span> <span class="nn">bokeh.plotting</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">output_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;cdn&#39;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Comparison&#39;</span><span class="p">)</span>
    <span class="c1"># Assume that all t arrays have the same range</span>
    <span class="n">t_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1001</span><span class="p">)</span>  <span class="c1"># fine mesh for u_e</span>
    <span class="n">tools</span> <span class="o">=</span> <span class="s1">&#39;pan,wheel_zoom,box_zoom,reset,&#39;</span>\
            <span class="s1">&#39;save,box_select,lasso_select&#39;</span>
    <span class="n">u_range</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.2</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">I</span><span class="p">]</span>
    <span class="n">font_size</span> <span class="o">=</span> <span class="s1">&#39;8pt&#39;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of plot objects</span>
    <span class="c1"># Make the first figure</span>
    <span class="n">p_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span>
        <span class="n">width</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">plot_height</span><span class="o">=</span><span class="mi">250</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">legends</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">x_axis_label</span><span class="o">=</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="n">y_axis_label</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">,</span>
        <span class="n">x_range</span><span class="o">=</span><span class="n">t_range</span><span class="p">,</span> <span class="n">y_range</span><span class="o">=</span><span class="n">u_range</span><span class="p">,</span> <span class="n">tools</span><span class="o">=</span><span class="n">tools</span><span class="p">)</span>
    <span class="n">p_</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">axis_label_text_font_size</span><span class="o">=</span><span class="n">font_size</span>
    <span class="n">p_</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">axis_label_text_font_size</span><span class="o">=</span><span class="n">font_size</span>
    <span class="n">p_</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">line_color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)</span>
    <span class="c1"># Add exact solution</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="n">p_</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="n">line_color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">line_dash</span><span class="o">=</span><span class="s1">&#39;4 4&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_</span><span class="p">)</span>
    <span class="c1"># Make the rest of the figures and attach their axes to</span>
    <span class="c1"># the first figure&#39;s axes</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
        <span class="n">p_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span>
            <span class="n">width</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">plot_height</span><span class="o">=</span><span class="mi">250</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">legends</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="n">x_axis_label</span><span class="o">=</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="n">y_axis_label</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">,</span>
            <span class="n">x_range</span><span class="o">=</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x_range</span><span class="p">,</span> <span class="n">y_range</span><span class="o">=</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y_range</span><span class="p">,</span> <span class="n">tools</span><span class="o">=</span><span class="n">tools</span><span class="p">)</span>
        <span class="n">p_</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">axis_label_text_font_size</span> <span class="o">=</span> <span class="n">font_size</span>
        <span class="n">p_</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">axis_label_text_font_size</span> <span class="o">=</span> <span class="n">font_size</span>
        <span class="n">p_</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">line_color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)</span>
        <span class="n">p_</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="n">line_color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">line_dash</span><span class="o">=</span><span class="s1">&#39;4 4&#39;</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_</span><span class="p">)</span>

    <span class="c1"># Arrange all plots in a grid with 3 plots per row</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="p">[[]]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="n">grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># New row</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gridplot</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">toolbar_location</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">plot</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">plot</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load -s demo_bokeh, src-vib/vib_undamped.py</span>
<span class="k">def</span> <span class="nf">demo_bokeh</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Solve a scaled ODE u&#39;&#39; + u = 0.&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mf">1.0</span>        <span class="c1"># Scaled problem (frequency)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>  <span class="c1"># Period</span>
    <span class="n">num_steps_per_period</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">80</span><span class="p">]</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">40</span><span class="o">*</span><span class="n">P</span>       <span class="c1"># Simulation time: 40 periods</span>
    <span class="n">u</span> <span class="o">=</span> <span class="p">[]</span>         <span class="c1"># List of numerical solutions</span>
    <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>         <span class="c1"># List of corresponding meshes</span>
    <span class="n">legends</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">num_steps_per_period</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">P</span><span class="o">/</span><span class="n">n</span>
        <span class="n">u_</span><span class="p">,</span> <span class="n">t_</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">)</span>
        <span class="n">u</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t_</span><span class="p">)</span>
        <span class="n">legends</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;# time steps per period: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">bokeh_plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">legends</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">t_range</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">P</span><span class="p">],</span>
               <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;tmp.html&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can run this below, which should open a window with the Bokeh plots where you can experiment with the graphs yourself:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># NBVAL_IGNORE_OUTPUT</span>
<span class="n">demo_bokeh</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Operator `Kernel` run in 0.01 s
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Operator `Kernel` run in 0.01 s
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Operator `Kernel` run in 0.01 s
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Operator `Kernel` run in 0.01 s
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Operator `Kernel` run in 0.01 s
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="using-a-line-by-line-ascii-plotter">
<h2><span class="section-number">3.4. </span>Using a line-by-line ascii plotter<a class="headerlink" href="#using-a-line-by-line-ascii-plotter" title="Permalink to this headline">¶</a></h2>
<p>Plotting functions vertically, line by line, in the terminal window
using ascii characters only is a simple, fast, and convenient
visualization technique for long time series. Note that the time
axis then is positive downwards on the screen, so we can let the
solution be visualized “forever”.
The tool
<code class="docutils literal notranslate"><span class="pre">scitools.avplotter.Plotter</span></code> makes it easy to create such plots:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load -s visualize_front_ascii, src-vib/vib_undamped.py</span>
<span class="k">def</span> <span class="nf">visualize_front_ascii</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot u and the exact solution vs t line by line in a</span>
<span class="sd">    terminal window (only using ascii characters).</span>
<span class="sd">    Makes it easy to plot very long time series.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scitools.avplotter</span> <span class="kn">import</span> <span class="n">Plotter</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>
    <span class="n">umin</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">min</span><span class="p">();</span>  <span class="n">umax</span> <span class="o">=</span> <span class="o">-</span><span class="n">umin</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">Plotter</span><span class="p">(</span><span class="n">ymin</span><span class="o">=</span><span class="n">umin</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="n">umax</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="s1">&#39;+o&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">I</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])),</span> <span class="s1">&#39;</span><span class="si">%.1f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">/</span><span class="n">P</span><span class="p">))</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">fps</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>The call <code class="docutils literal notranslate"><span class="pre">p.plot</span></code> returns a line of text, with the <span class="math notranslate nohighlight">\(t\)</span> axis marked and
a symbol <code class="docutils literal notranslate"><span class="pre">+</span></code> for the first function (<code class="docutils literal notranslate"><span class="pre">u</span></code>) and <code class="docutils literal notranslate"><span class="pre">o</span></code> for the second
function (the exact solution). Here we append to this text
a time counter reflecting how many periods the current time point
corresponds to.</p>
<p>The function can be run as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">visualize_front_ascii</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>                              |                        o      0.0
                              |                       o+      0.1
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>                              |                   o +         0.1
                              |              o  +             0.2
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>                              |       o  +                    0.2
                              |   +                           0.2
                      o   +   |                               0.3
               o  +           |                               0.4
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>          o +                 |                               0.4
      o +                     |                               0.5
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>     o                        |                               0.5
     +o                       |                               0.6
        + o                   |                               0.6
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>             + o              |                               0.7
                   +  o       |                               0.7
                           +  |                               0.8
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>                              |   +   o                       0.8
                              |           +  o                0.9
                              |                 + o           0.9
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>                              |                      +o       1.0
                              |                        o      1.0
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>                              |                       o+      1.1
                              |                   o +         1.1
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>                              |              o +              1.2
                              |       o  +                    1.2
                              |  +                            1.2
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>                      o  +    |                               1.3
               o  +           |                               1.4
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>          o +                 |                               1.4
      o+                      |                               1.5
     o                        |                               1.5
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>     +o                       |                               1.6
        + o                   |                               1.6
             + o              |                               1.7
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>                    + o       |                               1.7
                           +  |                               1.8
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>                              |    +  o                       1.8
                              |           +  o                1.9
                              |                  +o           1.9
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>                              |                      +o       2.0
                              |                        o      2.0
                              |                       o       2.1
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>                              |                   o +         2.1
                              |              o +              2.1
                              |       o +                     2.2
                              | +                             2.2
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>                      o  +    |                               2.3
               o +            |                               2.4
          o+                  |                               2.4
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>      o+                      |                               2.5
     o                        |                               2.5
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>      o                       |                               2.6
         +o                   |                               2.6
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>              +o              |                               2.7
                    + o       |                               2.7
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>                            + |                               2.8
                              |     + o                       2.8
                              |            + o                2.9
                              |                  +o           2.9
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>                              |                      +o       3.0
                              |                        o      3.0
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>                              |                       o       3.1
                              |                   o+          3.1
                              |              o+               3.2
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>                              |       o+                      3.2
                              | +                             3.2
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>                      o +     |                               3.3
               o +            |                               3.4
          o+                  |                               3.4
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>      o+                      |                               3.5
     o                        |                               3.5
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>      o                       |                               3.6
         +o                   |                               3.6
              +o              |                               3.7
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>                     +o       |                               3.7
                             +|                               3.8
                              |     + o                       3.8
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>                              |             +o                3.9
                              |                  +o           3.9
                              |                      +o       4.0
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>                              |                        o      4.0
                              |                       o       4.0
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>                              |                   o+          4.1
                              |              o+               4.2
                              |       o+                      4.2
                              |+                              4.2
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>                      o+      |                               4.3
               o+             |                               4.4
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>          o                   |                               4.4
      o+                      |                               4.5
     o                        |                               4.5
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>      o                       |                               4.5
         +o                   |                               4.6
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>               o              |                               4.7
                     +o       |                               4.7
                             +|                               4.8
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>                              |      +o                       4.8
                              |             +o                4.9
                              |                   o           4.9
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>                              |                       o       5.0
                              |                        o      5.0
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="empirical-analysis-of-the-solution">
<h2><span class="section-number">3.5. </span>Empirical analysis of the solution<a class="headerlink" href="#empirical-analysis-of-the-solution" title="Permalink to this headline">¶</a></h2>
<div id="vib:ode1:empirical"></div>
<p>For oscillating functions like those in <a class="reference external" href="#vib:ode1:2dt">Figure</a> we may
compute the amplitude and frequency (or period) empirically.
That is, we run through the discrete solution points <span class="math notranslate nohighlight">\((t_n, u_n)\)</span> and
find all maxima and minima points. The distance between two consecutive
maxima (or minima) points can be used as estimate of the local period,
while half the difference between the <span class="math notranslate nohighlight">\(u\)</span> value at a maximum and a nearby
minimum gives an estimate of the local amplitude.</p>
<p>The local maxima are the points where</p>
<!-- Equation labels as ordinary links -->
<div id="_auto4"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u^{n-1} &lt; u^n &gt; u^{n+1},\quad n=1,\ldots,N_t-1,
\label{_auto4} \tag{14}
\end{equation}
\]</div>
<p>and the local minima are recognized by</p>
<!-- Equation labels as ordinary links -->
<div id="_auto5"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u^{n-1} &gt; u^n &lt; u^{n+1},\quad n=1,\ldots,N_t-1
\thinspace .
\label{_auto5} \tag{15}
\end{equation}
\]</div>
<p>In computer code this becomes</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load -s minmax, src-vib/vib_empirical_analysis.py</span>
<span class="k">def</span> <span class="nf">minmax</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute all local minima and maxima of the function u(t),</span>
<span class="sd">    represented by discrete points in the arrays u and t.</span>
<span class="sd">    Return lists minima and maxima of (t[i],u[i]) extreme points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">minima</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">maxima</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">minima</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">maxima</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">minima</span><span class="p">,</span> <span class="n">maxima</span>
</pre></div>
</div>
</div>
</div>
<p>Note that the two returned objects are lists of tuples.</p>
<p>Let <span class="math notranslate nohighlight">\((t_i, e_i)\)</span>, <span class="math notranslate nohighlight">\(i=0,\ldots,M-1\)</span>, be the sequence of all
the <span class="math notranslate nohighlight">\(M\)</span> maxima points, where <span class="math notranslate nohighlight">\(t_i\)</span>
is the time value and <span class="math notranslate nohighlight">\(e_i\)</span> the corresponding <span class="math notranslate nohighlight">\(u\)</span> value.
The local period can be defined as <span class="math notranslate nohighlight">\(p_i=t_{i+1}-t_i\)</span>.
With Python syntax this reads</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load -s periods, src-vib/vib_empirical_analysis.py</span>
<span class="k">def</span> <span class="nf">periods</span><span class="p">(</span><span class="n">extrema</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of (t,u) points of the maxima or minima,</span>
<span class="sd">    return an array of the corresponding local periods.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">extrema</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">extrema</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
         <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">extrema</span><span class="p">))]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The list <code class="docutils literal notranslate"><span class="pre">p</span></code> created by a list comprehension is converted to an array
since we probably want to compute with it, e.g., find the corresponding
frequencies <code class="docutils literal notranslate"><span class="pre">2*pi/p</span></code>.</p>
<p>Having the minima and the maxima, the local amplitude can be
calculated as the difference between two neighboring minimum and
maximum points:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load -s amplitudes, src-vib/vib_empirical_analysis.py</span>
<span class="k">def</span> <span class="nf">amplitudes</span><span class="p">(</span><span class="n">minima</span><span class="p">,</span> <span class="n">maxima</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of (t,u) points of the minima and maxima of</span>
<span class="sd">    u, return an array of the corresponding local amplitudes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Compare first maxima with first minima and so on</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">abs</span><span class="p">(</span><span class="n">maxima</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">minima</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span><span class="o">/</span><span class="mf">2.0</span>
         <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">minima</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">maxima</span><span class="p">)))]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The code segments are found in the file <span class="xref myst"><code class="docutils literal notranslate"><span class="pre">vib_empirical_analysis.py</span></code></span>.</p>
<p>Since <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> and <code class="docutils literal notranslate"><span class="pre">p[i]</span></code> correspond to
the <span class="math notranslate nohighlight">\(i\)</span>-th amplitude estimate and the <span class="math notranslate nohighlight">\(i\)</span>-th period estimate, respectively,
it is most convenient to visualize the <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">p</span></code> values with the
index <code class="docutils literal notranslate"><span class="pre">i</span></code> on the horizontal axis.
(There is no unique time point associated with either of these estimate
since values at two different time points were used in the
computations.)</p>
<p>In the analysis of very long time series, it is advantageous to
compute and plot <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span></code> instead of <span class="math notranslate nohighlight">\(u\)</span> to get an impression of
the development of the oscillations. Let us do this for the scaled
problem and <span class="math notranslate nohighlight">\(\Delta t=0.1, 0.05, 0.01\)</span>.
A ready-made function</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plot_empirical_freq_and_amplitude</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
<p>computes the empirical amplitudes and periods, and creates a plot
where the amplitudes and angular frequencies
are visualized together with the exact amplitude <code class="docutils literal notranslate"><span class="pre">I</span></code>
and the exact angular frequency <code class="docutils literal notranslate"><span class="pre">w</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load -s plot_empirical_freq_and_amplitude, src-vib/vib_undamped.py</span>
<span class="k">def</span> <span class="nf">plot_empirical_freq_and_amplitude</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the empirical angular frequency and amplitude of</span>
<span class="sd">    simulations in u and t. u and t can be arrays or (in</span>
<span class="sd">    the case of multiple simulations) multiple arrays.</span>
<span class="sd">    One plot is made for the amplitude and one for the angular</span>
<span class="sd">    frequency (just called frequency in the legends).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span>
    <span class="n">legends1</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">legends2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)):</span>
        <span class="n">minima</span><span class="p">,</span> <span class="n">maxima</span> <span class="o">=</span> <span class="n">minmax</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">periods</span><span class="p">(</span><span class="n">maxima</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">amplitudes</span><span class="p">(</span><span class="n">minima</span><span class="p">,</span> <span class="n">maxima</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)),</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">p</span><span class="p">)</span>
        <span class="n">legends1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;frequency, case</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)),</span> <span class="n">a</span><span class="p">)</span>
        <span class="n">legends2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;amplitude, case</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)),</span> <span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="s1">&#39;k--&#39;</span><span class="p">)</span>
    <span class="n">legends1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;exact frequency&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">legends1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower left&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.8</span><span class="o">*</span><span class="n">w</span><span class="p">,</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">w</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;tmp1.png&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;tmp1.pdf&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)),</span> <span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="s1">&#39;k--&#39;</span><span class="p">)</span>
    <span class="n">legends2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;exact amplitude&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">legends2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower left&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.8</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">I</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;tmp2.png&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;tmp2.pdf&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We can make a little program
for creating the plot:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># NBVAL_IGNORE_OUTPUT</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
<span class="n">dt_values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">]</span>
<span class="n">u_cases</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">t_cases</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dt_values</span><span class="p">:</span>
    <span class="c1"># Simulate scaled problem for 40 periods</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
    <span class="n">u_cases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">t_cases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">plot_empirical_freq_and_amplitude</span><span class="p">(</span><span class="n">u_cases</span><span class="p">,</span> <span class="n">t_cases</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Operator `Kernel` run in 0.01 s
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Operator `Kernel` run in 0.01 s
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Operator `Kernel` run in 0.01 s
</pre></div>
</div>
<img alt="../../_images/vib_undamped_109_3.png" src="../../_images/vib_undamped_109_3.png" />
<img alt="../../_images/vib_undamped_109_4.png" src="../../_images/vib_undamped_109_4.png" />
</div>
</div>
<p>Empirical angular frequency (top) and amplitude (bottom) for three different time steps.</p>
<p>We can clearly see that
lowering <span class="math notranslate nohighlight">\(\Delta t\)</span> improves the angular frequency significantly, while the
amplitude seems to be more accurate.
The lines with
<span class="math notranslate nohighlight">\(\Delta t=0.01\)</span>, corresponding to 100 steps per period, can hardly be
distinguished from the exact values. The next section shows how we
can get mathematical insight into why amplitudes are good while frequencies
are more inaccurate.</p>
</div>
</div>
<div class="section" id="analysis-of-the-numerical-scheme">
<h1><span class="section-number">4. </span>Analysis of the numerical scheme<a class="headerlink" href="#analysis-of-the-numerical-scheme" title="Permalink to this headline">¶</a></h1>
<div id="vib:ode1:analysis"></div>
<div class="section" id="deriving-a-solution-of-the-numerical-scheme">
<h2><span class="section-number">4.1. </span>Deriving a solution of the numerical scheme<a class="headerlink" href="#deriving-a-solution-of-the-numerical-scheme" title="Permalink to this headline">¶</a></h2>
<div id="vib:ode1:analysis:solderiv"></div>
<p>After having seen the phase error grow with time in the previous
section, we shall now quantify this error through mathematical
analysis.  The key tool in the analysis will be to establish an exact
solution of the discrete equations.  The difference equation
(<a class="reference external" href="#vib:ode1:step4">7</a>) has constant coefficients and is
homogeneous. Such equations are known to have solutions on the form
<span class="math notranslate nohighlight">\(u^n=CA^n\)</span>, where <span class="math notranslate nohighlight">\(A\)</span> is some number
to be determined from the difference equation and <span class="math notranslate nohighlight">\(C\)</span> is found as the
initial condition (<span class="math notranslate nohighlight">\(C=I\)</span>).  Recall that <span class="math notranslate nohighlight">\(n\)</span> in <span class="math notranslate nohighlight">\(u^n\)</span> is a
superscript labeling the time level, while <span class="math notranslate nohighlight">\(n\)</span> in <span class="math notranslate nohighlight">\(A^n\)</span> is an
exponent.</p>
<p>With oscillating functions as solutions, the algebra will
be considerably simplified if we seek an <span class="math notranslate nohighlight">\(A\)</span> on the form</p>
<div class="math notranslate nohighlight">
\[
A=e^{i\tilde\omega \Delta t},
\]</div>
<p>and solve for the numerical frequency <span class="math notranslate nohighlight">\(\tilde\omega\)</span> rather than
<span class="math notranslate nohighlight">\(A\)</span>. Note that <span class="math notranslate nohighlight">\(i=\sqrt{-1}\)</span> is the imaginary unit. (Using a
complex exponential function gives simpler arithmetics than working
with a sine or cosine function.)
We have</p>
<div class="math notranslate nohighlight">
\[
A^n = e^{i\tilde\omega \Delta t\, n}=e^{i\tilde\omega t_n} =
\cos (\tilde\omega t_n) + i\sin(\tilde \omega t_n)
\thinspace .
\]</div>
<p>The physically relevant numerical solution can
be taken as the real part of this complex expression.</p>
<p>The calculations go as</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
[D_tD_t u]^n &amp;= \frac{u^{n+1} - 2u^n + u^{n-1}}{\Delta t^2}\\ 
&amp;= I\frac{A^{n+1} - 2A^n + A^{n-1}}{\Delta t^2}\\ 
&amp;= \frac{I}{\Delta t^{2}}(e^{i\tilde\omega(t_n+\Delta t)} - 2e^{i\tilde\omega t_n} + e^{i\tilde\omega(t_n-\Delta t)})\\ 
&amp;= Ie^{i\tilde\omega t_n}\frac{1}{\Delta t^2}\left(e^{i\tilde\omega\Delta t} + e^{i\tilde\omega(-\Delta t)} - 2\right)\\ 
&amp;= Ie^{i\tilde\omega t_n}\frac{2}{\Delta t^2}\left(\cosh(i\tilde\omega\Delta t) -1 \right)\\ 
&amp;= Ie^{i\tilde\omega t_n}\frac{2}{\Delta t^2}\left(\cos(\tilde\omega\Delta t) -1 \right)\\ 
&amp;= -Ie^{i\tilde\omega t_n}\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2})
\end{align*}
\end{split}\]</div>
<p>The last line follows from the relation
<span class="math notranslate nohighlight">\(\cos x - 1 = -2\sin^2(x/2)\)</span> (try <code class="docutils literal notranslate"><span class="pre">cos(x)-1</span></code> on
<a class="reference external" href="http://www.wolframalpha.com">wolframalpha.com</a> to see the formula).</p>
<p>The scheme (<a class="reference external" href="#vib:ode1:step4">7</a>)
with <span class="math notranslate nohighlight">\(u^n=Ie^{i\tilde\omega\Delta t\, n}\)</span> inserted now gives</p>
<!-- Equation labels as ordinary links -->
<div id="_auto6"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
-Ie^{i\tilde\omega t_n}
\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2})
+ \omega^2 Ie^{i\tilde\omega t_n} = 0,
\label{_auto6} \tag{16}
\end{equation}
\]</div>
<p>which after dividing by <span class="math notranslate nohighlight">\(Ie^{i\tilde\omega t_n}\)</span> results in</p>
<!-- Equation labels as ordinary links -->
<div id="_auto7"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2}) = \omega^2
\thinspace .
\label{_auto7} \tag{17}
\end{equation}
\]</div>
<p>The first step in solving for the unknown <span class="math notranslate nohighlight">\(\tilde\omega\)</span> is</p>
<div class="math notranslate nohighlight">
\[
\sin^2(\frac{\tilde\omega\Delta t}{2}) = \left(\frac{\omega\Delta t}{2}\right)^2
\thinspace .
\]</div>
<p>Then, taking the square root, applying the inverse sine function, and
multiplying by <span class="math notranslate nohighlight">\(2/\Delta t\)</span>, results in</p>
<!-- Equation labels as ordinary links -->
<div id="vib:ode1:tildeomega"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\tilde\omega = \pm \frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
\thinspace .
\label{vib:ode1:tildeomega} \tag{18}
\end{equation}
\]</div>
</div>
<div class="section" id="the-error-in-the-numerical-frequency">
<h2><span class="section-number">4.2. </span>The error in the numerical frequency<a class="headerlink" href="#the-error-in-the-numerical-frequency" title="Permalink to this headline">¶</a></h2>
<div id="vib:ode1:analysis:numfreq"></div>
<p>The first observation following (<a class="reference external" href="#vib:ode1:tildeomega">18</a>) tells that there
is a phase error since the numerical frequency <span class="math notranslate nohighlight">\(\tilde\omega\)</span> never
equals the exact frequency <span class="math notranslate nohighlight">\(\omega\)</span>. But how good is the approximation
(<a class="reference external" href="#vib:ode1:tildeomega">18</a>)? That is, what is the error <span class="math notranslate nohighlight">\(\omega -
\tilde\omega\)</span> or <span class="math notranslate nohighlight">\(\tilde\omega/\omega\)</span>?  Taylor series expansion for
small <span class="math notranslate nohighlight">\(\Delta t\)</span> may give an expression that is easier to understand
than the complicated function in (<a class="reference external" href="#vib:ode1:tildeomega">18</a>):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">dt</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;dt w&#39;</span><span class="p">)</span>
<span class="n">w_tilde_e</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="n">dt</span><span class="o">*</span><span class="n">asin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="n">w_tilde_series</span> <span class="o">=</span> <span class="n">w_tilde_e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">w_tilde_series</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>w + dt**2*w**3/24 + O(dt**4)
</pre></div>
</div>
</div>
</div>
<p>This means that</p>
<!-- See vib_symbolic.py for computations with sympy --><!-- Equation labels as ordinary links -->
<div id="vib:ode1:tildeomega:series"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\tilde\omega = \omega\left( 1 + \frac{1}{24}\omega^2\Delta t^2\right)
+ \mathcal{O}({\Delta t^4})
\thinspace .
\label{vib:ode1:tildeomega:series} \tag{19}
\end{equation}
\]</div>
<p>The error in the numerical frequency is of second-order in <span class="math notranslate nohighlight">\(\Delta t\)</span>,
and the error vanishes as <span class="math notranslate nohighlight">\(\Delta t\rightarrow 0\)</span>.  We see that
<span class="math notranslate nohighlight">\(\tilde\omega &gt; \omega\)</span> since the term <span class="math notranslate nohighlight">\(\omega^3\Delta t^2/24 &gt;0\)</span> and
this is by far the biggest term in the series expansion for small
<span class="math notranslate nohighlight">\(\omega\Delta t\)</span>. A numerical frequency that is too large gives an
oscillating curve that oscillates too fast and therefore “lags
behind” the exact oscillations, a feature that can be seen in the
left plot in <a class="reference external" href="#vib:ode1:2dt">Figure</a>.</p>
<p><a class="reference external" href="#vib:ode1:tildeomega:plot">Figure</a> plots the discrete frequency
(<a class="reference external" href="#vib:ode1:tildeomega">18</a>) and its approximation
(<a class="reference external" href="#vib:ode1:tildeomega:series">19</a>) for <span class="math notranslate nohighlight">\(\omega =1\)</span> (based on the
program <span class="xref myst"><code class="docutils literal notranslate"><span class="pre">vib_plot_freq.py</span></code></span>).
Although <span class="math notranslate nohighlight">\(\tilde\omega\)</span> is a function of <span class="math notranslate nohighlight">\(\Delta t\)</span> in
(<a class="reference external" href="#vib:ode1:tildeomega:series">19</a>), it is misleading to think of
<span class="math notranslate nohighlight">\(\Delta t\)</span> as the important discretization parameter. mathcal{I}_t is the
product <span class="math notranslate nohighlight">\(\omega\Delta t\)</span> that is the key discretization
parameter. This quantity reflects the <em>number of time steps per
period</em> of the oscillations.  To see this, we set <span class="math notranslate nohighlight">\(P=N_P\Delta t\)</span>,
where <span class="math notranslate nohighlight">\(P\)</span> is the length of a period, and <span class="math notranslate nohighlight">\(N_P\)</span> is the number of time
steps during a period.  Since <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(\omega\)</span> are related by
<span class="math notranslate nohighlight">\(P=2\pi/\omega\)</span>, we get that <span class="math notranslate nohighlight">\(\omega\Delta t = 2\pi/N_P\)</span>, which shows
that <span class="math notranslate nohighlight">\(\omega\Delta t\)</span> is directly related to <span class="math notranslate nohighlight">\(N_P\)</span>.</p>
<p>The plot shows that at least <span class="math notranslate nohighlight">\(N_P\sim 25-30\)</span> points per period are
necessary for reasonable accuracy, but this depends on the length of
the simulation (<span class="math notranslate nohighlight">\(T\)</span>) as the total phase error due to the frequency
error grows linearly with time (see <a class="reference external" href="#vib:exer:phase:err:growth">Exercise 2: Show linear growth of the phase with time</a>).</p>
<!-- dom:FIGURE: [fig-vib/discrete_freq.png, width=400] Exact discrete frequency and its second-order series expansion. <div id="vib:ode1:tildeomega:plot"></div> -->
<!-- begin figure -->
<div id="vib:ode1:tildeomega:plot"></div>
<p>Exact discrete frequency and its second-order series expansion.</p>
<img src="fig-vib/discrete_freq.png" width=400>
<!-- end figure -->
</div>
<div class="section" id="empirical-convergence-rates-and-adjusted-omega">
<h2><span class="section-number">4.3. </span>Empirical convergence rates and adjusted <span class="math notranslate nohighlight">\(\omega\)</span><a class="headerlink" href="#empirical-convergence-rates-and-adjusted-omega" title="Permalink to this headline">¶</a></h2>
<p>The expression (<a class="reference external" href="#vib:ode1:tildeomega:series">19</a>) suggests that
adjusting omega to</p>
<div class="math notranslate nohighlight">
\[
\omega\left( 1 - \frac{1}{24}\omega^2\Delta t^2\right),
\]</div>
<p>could have effect on the <em>convergence rate</em> of the global error in <span class="math notranslate nohighlight">\(u\)</span>
(cf. the section <a class="reference external" href="#vib:ode1:verify">Verification</a>). With the <code class="docutils literal notranslate"><span class="pre">convergence_rates</span></code> function
in <code class="docutils literal notranslate"><span class="pre">vib_undamped.py</span></code> we can easily check this. A special solver, with
adjusted <span class="math notranslate nohighlight">\(w\)</span>, is available as the function <code class="docutils literal notranslate"><span class="pre">solver_adjust_w</span></code>. A
call to <code class="docutils literal notranslate"><span class="pre">convergence_rates</span></code> with this solver reveals that the rate is
4.0! With the original, physical <span class="math notranslate nohighlight">\(\omega\)</span> the rate is 2.0  - as expected
from using second-order finite difference approximations,
as expected from the forthcoming derivation of the global error,
and as expected from truncation error analysis as explained in the <a class="reference external" href="../B_trunc/trunc.ipynb#trunc:vib:undamped">truncation error analysis</a> section.</p>
<p>Adjusting <span class="math notranslate nohighlight">\(\omega\)</span> is an ideal trick for this simple problem, but when
adding damping and nonlinear terms, we have no simple formula for the
impact on <span class="math notranslate nohighlight">\(\omega\)</span>, and therefore we cannot use the trick.</p>
</div>
<div class="section" id="exact-discrete-solution">
<h2><span class="section-number">4.4. </span>Exact discrete solution<a class="headerlink" href="#exact-discrete-solution" title="Permalink to this headline">¶</a></h2>
<div id="vib:ode1:analysis:sol"></div>
<p>Perhaps more important than the <span class="math notranslate nohighlight">\(\tilde\omega = \omega + {\cal O}(\Delta t^2)\)</span>
result found above is the fact that we have an exact discrete solution of
the problem:</p>
<!-- Equation labels as ordinary links -->
<div id="vib:ode1:un:exact"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u^n = I\cos\left(\tilde\omega n\Delta t\right),\quad
\tilde\omega = \frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
\thinspace .
\label{vib:ode1:un:exact} \tag{20}
\end{equation}
\]</div>
<p>We can then compute the error mesh function</p>
<!-- Equation labels as ordinary links -->
<div id="vib:ode1:en"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
e^n = u(t_n) - u^n =
I\cos\left(\omega n\Delta t\right) - I\cos\left(\tilde\omega n\Delta t\right)\thinspace .
\label{vib:ode1:en} \tag{21}
\end{equation}
\]</div>
<p>From the formula <span class="math notranslate nohighlight">\(\cos 2x - \cos 2y = -2\sin(x-y)\sin(x+y)\)</span> we can
rewrite <span class="math notranslate nohighlight">\(e^n\)</span> so the expression is easier to interpret:</p>
<!-- Equation labels as ordinary links -->
<div id="vib:ode1:en2"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
e^n = -2I\sin\left(t\frac{1}{2}\left( \omega - \tilde\omega\right)\right)
\sin\left(t\frac{1}{2}\left( \omega + \tilde\omega\right)\right)\thinspace .
\label{vib:ode1:en2} \tag{22}
\end{equation}
\]</div>
<p>The error mesh function is ideal for verification purposes and you are
strongly encouraged to make a test based on (<a class="reference external" href="#vib:ode1:un:exact">20</a>)
by doing <a class="reference external" href="#vib:exer:discrete:omega">Exercise 11: Use an exact discrete solution for verification</a>.</p>
</div>
<div class="section" id="convergence">
<h2><span class="section-number">4.5. </span>Convergence<a class="headerlink" href="#convergence" title="Permalink to this headline">¶</a></h2>
<div id="vib:ode1:analysis:conv"></div>
<p>We can use (<a class="reference external" href="#vib:ode1:tildeomega:series">19</a>) and (<a class="reference external" href="#vib:ode1:en">21</a>), or
(<a class="reference external" href="#vib:ode1:en2">22</a>), to show <em>convergence</em> of the numerical scheme,
i.e., <span class="math notranslate nohighlight">\(e^n\rightarrow 0\)</span> as <span class="math notranslate nohighlight">\(\Delta t\rightarrow 0\)</span>, which implies
that the numerical solution approaches the exact solution as <span class="math notranslate nohighlight">\(\Delta
t\)</span> approaches to zero.  We have that</p>
<div class="math notranslate nohighlight">
\[
\lim_{\Delta t\rightarrow 0}
\tilde\omega = \lim_{\Delta t\rightarrow 0}
\frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
= \omega,
\]</div>
<p>by L’Hopital’s rule. This result could also been computed <a class="reference external" href="http://www.wolframalpha.com/input/?i=%282%2Fx%29*asin%28w*x%2F2%29+as+x-%3E0">WolframAlpha</a>, or
we could use the limit functionality in <code class="docutils literal notranslate"><span class="pre">sympy</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="nn">sym</span>
<span class="n">dt</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x w&#39;</span><span class="p">)</span>
<span class="n">sym</span><span class="o">.</span><span class="n">limit</span><span class="p">((</span><span class="mi">2</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">asin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle w\]</div>
</div>
</div>
<p>Also (<a class="reference external" href="#vib:ode1:tildeomega:series">19</a>) can be used to establish
that <span class="math notranslate nohighlight">\(\tilde\omega\rightarrow\omega\)</span> when <span class="math notranslate nohighlight">\(\Delta t\rightarrow 0\)</span>.
mathcal{I}_t then follows from the expression(s) for <span class="math notranslate nohighlight">\(e^n\)</span> that <span class="math notranslate nohighlight">\(e^n\rightarrow 0\)</span>.</p>
</div>
<div class="section" id="the-global-error">
<h2><span class="section-number">4.6. </span>The global error<a class="headerlink" href="#the-global-error" title="Permalink to this headline">¶</a></h2>
<p>To achieve more analytical insight into the nature of the global
error, we can Taylor expand the error mesh function
(<a class="reference external" href="#vib:ode1:en">21</a>).  Since <span class="math notranslate nohighlight">\(\tilde\omega\)</span> in
(<a class="reference external" href="#vib:ode1:tildeomega">18</a>) contains <span class="math notranslate nohighlight">\(\Delta t\)</span> in the denominator we
use the series expansion for <span class="math notranslate nohighlight">\(\tilde\omega\)</span> inside the cosine
function. A relevant <code class="docutils literal notranslate"><span class="pre">sympy</span></code> session is</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">dt</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;dt w t&#39;</span><span class="p">)</span>
<span class="n">w_tilde_e</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="n">dt</span><span class="o">*</span><span class="n">asin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="n">w_tilde_series</span> <span class="o">=</span> <span class="n">w_tilde_e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">w_tilde_series</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle w + \frac{dt^{2} w^{3}}{24} + O\left(dt^{4}\right)\]</div>
</div>
</div>
<p>Series expansions in <code class="docutils literal notranslate"><span class="pre">sympy</span></code> have the inconvenient <code class="docutils literal notranslate"><span class="pre">O()</span></code> term that
prevents further calculations with the series. We can use the
<code class="docutils literal notranslate"><span class="pre">removeO()</span></code> command to get rid of the <code class="docutils literal notranslate"><span class="pre">O()</span></code> term:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">w_tilde_series</span> <span class="o">=</span> <span class="n">w_tilde_series</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
<span class="n">w_tilde_series</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle \frac{dt^{2} w^{3}}{24} + w\]</div>
</div>
</div>
<p>Using this <code class="docutils literal notranslate"><span class="pre">w_tilde_series</span></code> expression for <span class="math notranslate nohighlight">\(\tilde w\)</span> in
(<a class="reference external" href="#vib:ode1:en">21</a>), dropping <span class="math notranslate nohighlight">\(I\)</span> (which is a common factor), and
performing a series expansion of the error yields</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">error</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">w_tilde_series</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="n">error</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle \frac{dt^{2} t w^{3} \sin{\left(t w \right)}}{24} + \frac{dt^{4} t^{2} w^{6} \cos{\left(t w \right)}}{1152} + O\left(dt^{6}\right)\]</div>
</div>
</div>
<p>Since we are mainly interested in the leading-order term in
such expansions (the term with lowest power in <span class="math notranslate nohighlight">\(\Delta t\)</span>, which
goes most slowly to zero), we use the <code class="docutils literal notranslate"><span class="pre">.as_leading_term(dt)</span></code>
construction to pick out this term:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">error</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">as_leading_term</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle \frac{dt^{2} t w^{3} \sin{\left(t w \right)}}{24}\]</div>
</div>
</div>
<p>The last result
means that the leading order global (true) error at a point <span class="math notranslate nohighlight">\(t\)</span>
is proportional to <span class="math notranslate nohighlight">\(\omega^3t\Delta t^2\)</span>. Considering only the
discrete <span class="math notranslate nohighlight">\(t_n\)</span> values for <span class="math notranslate nohighlight">\(t\)</span>, <span class="math notranslate nohighlight">\(t_n\)</span> is related
to <span class="math notranslate nohighlight">\(\Delta t\)</span> through <span class="math notranslate nohighlight">\(t_n=n\Delta t\)</span>. The factor
<span class="math notranslate nohighlight">\(\sin(\omega t)\)</span> can at most be 1, so we use this value to
bound the leading-order expression to its maximum value</p>
<div class="math notranslate nohighlight">
\[
e^n = \frac{1}{24}n\omega^3\Delta t^3\thinspace .
\]</div>
<p>This is the dominating term of the error <em>at a point</em>.</p>
<p>We are interested in the accumulated global error, which can be taken
as the <span class="math notranslate nohighlight">\(\ell^2\)</span> norm of <span class="math notranslate nohighlight">\(e^n\)</span>.  The norm is simply computed by summing
contributions from all mesh points:</p>
<div class="math notranslate nohighlight">
\[
||e^n||_{\ell^2}^2 = \Delta t\sum_{n=0}^{N_t} \frac{1}{24^2}n^2\omega^6\Delta t^6
=\frac{1}{24^2}\omega^6\Delta t^7 \sum_{n=0}^{N_t} n^2\thinspace .
\]</div>
<p>The sum <span class="math notranslate nohighlight">\(\sum_{n=0}^{N_t} n^2\)</span> is approximately equal to
<span class="math notranslate nohighlight">\(\frac{1}{3}N_t^3\)</span>. Replacing <span class="math notranslate nohighlight">\(N_t\)</span> by <span class="math notranslate nohighlight">\(T/\Delta t\)</span> and taking
the square root gives the expression</p>
<div class="math notranslate nohighlight">
\[
||e^n||_{\ell^2} = \frac{1}{24}\sqrt{\frac{T^3}{3}}\omega^3\Delta t^2\thinspace .
\]</div>
<p>This is our expression for the global (or integrated) error.
A primary result from this expression is that the global error
is proportional to <span class="math notranslate nohighlight">\(\Delta t^2\)</span>.</p>
</div>
<div class="section" id="stability">
<h2><span class="section-number">4.7. </span>Stability<a class="headerlink" href="#stability" title="Permalink to this headline">¶</a></h2>
<p>Looking at (<a class="reference external" href="#vib:ode1:un:exact">20</a>), it appears that the numerical
solution has constant and correct amplitude, but an error in the
angular frequency. A constant amplitude is not necessarily the case,
however! To see this, note that if only <span class="math notranslate nohighlight">\(\Delta t\)</span> is large enough,
the magnitude of the argument to <span class="math notranslate nohighlight">\(\sin^{-1}\)</span> in
(<a class="reference external" href="#vib:ode1:tildeomega">18</a>) may be larger than 1, i.e., <span class="math notranslate nohighlight">\(\omega\Delta
t/2 &gt; 1\)</span>. In this case, <span class="math notranslate nohighlight">\(\sin^{-1}(\omega\Delta t/2)\)</span> has a complex
value and therefore <span class="math notranslate nohighlight">\(\tilde\omega\)</span> becomes complex.  Type, for
example, <code class="docutils literal notranslate"><span class="pre">asin(x)</span></code> in <a class="reference external" href="http://www.wolframalpha.com">wolframalpha.com</a> to see basic properties of <span class="math notranslate nohighlight">\(\sin^{-1}
(x)\)</span>).</p>
<p>A complex <span class="math notranslate nohighlight">\(\tilde\omega\)</span> can be written $\tilde\omega = \tilde\omega_r</p>
<ul class="simple">
<li><p>i\tilde\omega_i<span class="math notranslate nohighlight">\(. Since \)</span>\sin^{-1}(x)<span class="math notranslate nohighlight">\( has a *negative* imaginary
part for \)</span>x&gt;1<span class="math notranslate nohighlight">\(, \)</span>\tilde\omega_i &lt; 0<span class="math notranslate nohighlight">\(, which means that
\)</span>e^{i\tilde\omega t}=e^{-\tilde\omega_i t}e^{i\tilde\omega_r t}<span class="math notranslate nohighlight">\( will
lead to exponential growth in time because \)</span>e^{-\tilde\omega_i t}<span class="math notranslate nohighlight">\(
with \)</span>\tilde\omega_i &lt;0$ has a positive exponent.</p></li>
</ul>
<p><strong>Stability criterion.</strong></p>
<p>We do not tolerate growth in the amplitude since such growth is not
present in the exact solution. Therefore, we
must impose a <em>stability criterion</em> so that
the argument in the inverse sine function leads
to real and not complex values of <span class="math notranslate nohighlight">\(\tilde\omega\)</span>. The stability
criterion reads</p>
<!-- Equation labels as ordinary links -->
<div id="_auto8"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\frac{\omega\Delta t}{2} \leq 1\quad\Rightarrow\quad
\Delta t \leq \frac{2}{\omega}
\thinspace .
\label{_auto8} \tag{23}
\end{equation}
\]</div>
<p>With <span class="math notranslate nohighlight">\(\omega =2\pi\)</span>, <span class="math notranslate nohighlight">\(\Delta t &gt; \pi^{-1} = 0.3183098861837907\)</span> will give
growing solutions. <a class="reference external" href="#vib:ode1:dt:unstable">Figure</a>
displays what happens when <span class="math notranslate nohighlight">\(\Delta t =0.3184\)</span>,
which is slightly above the critical value: <span class="math notranslate nohighlight">\(\Delta t =\pi^{-1} + 9.01\cdot
10^{-5}\)</span>.</p>
<!-- dom:FIGURE: [fig-vib/vib_unstable.png, width=400] Growing, unstable solution because of a time step slightly beyond the stability limit. <div id="vib:ode1:dt:unstable"></div> -->
<!-- begin figure -->
<div id="vib:ode1:dt:unstable"></div>
<p>Growing, unstable solution because of a time step slightly beyond the stability limit.</p>
<img src="fig-vib/vib_unstable.png" width=400>
<!-- end figure -->
</div>
<div class="section" id="about-the-accuracy-at-the-stability-limit">
<h2><span class="section-number">4.8. </span>About the accuracy at the stability limit<a class="headerlink" href="#about-the-accuracy-at-the-stability-limit" title="Permalink to this headline">¶</a></h2>
<p>An interesting question is whether the stability condition <span class="math notranslate nohighlight">\(\Delta t &lt;
2/\omega\)</span> is unfortunate, or more precisely: would it be meaningful to
take larger time steps to speed up computations?  The answer is a
clear no. At the stability limit, we have that <span class="math notranslate nohighlight">\(\sin^{-1}\omega\Delta
t/2 = \sin^{-1} 1 = \pi/2\)</span>, and therefore <span class="math notranslate nohighlight">\(\tilde\omega = \pi/\Delta
t\)</span>. (Note that the approximate formula
(<a class="reference external" href="#vib:ode1:tildeomega:series">19</a>) is very inaccurate for this value of
<span class="math notranslate nohighlight">\(\Delta t\)</span> as it predicts <span class="math notranslate nohighlight">\(\tilde\omega = 2.34/pi\)</span>, which is a 25
percent reduction.) The corresponding period of the numerical solution
is <span class="math notranslate nohighlight">\(\tilde P=2\pi/\tilde\omega = 2\Delta t\)</span>, which means that there is
just one time step <span class="math notranslate nohighlight">\(\Delta t\)</span> between a peak (maximum) and a
<a class="reference external" href="https://simple.wikipedia.org/wiki/Wave_(physics)">through</a>
(minimum) in the numerical solution. This is the shortest possible
wave that can be represented in the mesh! In other words, it is not
meaningful to use a larger time step than the stability limit.</p>
<p>Also, the error in angular frequency when <span class="math notranslate nohighlight">\(\Delta t = 2/\omega\)</span> is
severe: <a class="reference external" href="#vib:ode1:dt:stablimit">Figure</a> shows a comparison of the
numerical and analytical solution with <span class="math notranslate nohighlight">\(\omega = 2\pi\)</span> and <span class="math notranslate nohighlight">\(\Delta t =
2/\omega = \pi^{-1}\)</span>. Already after one period, the numerical solution
has a through while the exact solution has a peak (!).  The error in
frequency when <span class="math notranslate nohighlight">\(\Delta t\)</span> is at the stability limit becomes <span class="math notranslate nohighlight">\(\omega -
\tilde\omega = \omega(1-\pi/2)\approx -0.57\omega\)</span>.  The corresponding
error in the period is <span class="math notranslate nohighlight">\(P - \tilde P \approx 0.36P\)</span>.  The error after
<span class="math notranslate nohighlight">\(m\)</span> periods is then <span class="math notranslate nohighlight">\(0.36mP\)</span>. This error has reached half a period
when <span class="math notranslate nohighlight">\(m=1/(2\cdot 0.36)\approx 1.38\)</span>, which theoretically confirms the
observations in <a class="reference external" href="#vib:ode1:dt:stablimit">Figure</a> that the numerical
solution is a through ahead of a peak already after one and a half
period. Consequently, <span class="math notranslate nohighlight">\(\Delta t\)</span> should be chosen much less than the
stability limit to achieve meaningful numerical computations.</p>
<!-- dom:FIGURE: [fig-vib/vib_stability_limit.png, width=400] Numerical solution with $\Delta t$ exactly at the stability limit. <div id="vib:ode1:dt:stablimit"></div> -->
<!-- begin figure -->
<div id="vib:ode1:dt:stablimit"></div>
<p>Numerical solution with $\Delta t$ exactly at the stability limit.</p>
<img src="fig-vib/vib_stability_limit.png" width=400>
<!-- end figure -->
<p><strong>Summary.</strong></p>
<p>From the accuracy and stability
analysis we can draw three important conclusions:</p>
<ol class="simple">
<li><p>The key parameter in the formulas is <span class="math notranslate nohighlight">\(p=\omega\Delta t\)</span>.
The period of oscillations is <span class="math notranslate nohighlight">\(P=2\pi/\omega\)</span>, and the
number of time steps per period is <span class="math notranslate nohighlight">\(N_P=P/\Delta t\)</span>.
Therefore, <span class="math notranslate nohighlight">\(p=\omega\Delta t = 2\pi/N_P\)</span>, showing that the
critical parameter is the number of time steps per period.
The smallest possible <span class="math notranslate nohighlight">\(N_P\)</span> is 2, showing that <span class="math notranslate nohighlight">\(p\in (0,\pi]\)</span>.</p></li>
<li><p>Provided <span class="math notranslate nohighlight">\(p\leq 2\)</span>, the amplitude of the numerical solution is
constant.</p></li>
<li><p>The ratio of the numerical angular frequency and the exact
one is
<span class="math notranslate nohighlight">\(\tilde\omega/\omega \approx 1 + \frac{1}{24}p^2\)</span>.
The error <span class="math notranslate nohighlight">\(\frac{1}{24}p^2\)</span> leads to wrongly displaced peaks of the numerical
solution, and the error in peak location grows linearly with time
(see <a class="reference external" href="#vib:exer:phase:err:growth">Exercise 2: Show linear growth of the phase with time</a>).</p></li>
</ol>
</div>
</div>
<div class="section" id="alternative-schemes-based-on-1st-order-equations">
<h1><span class="section-number">5. </span>Alternative schemes based on 1st-order equations<a class="headerlink" href="#alternative-schemes-based-on-1st-order-equations" title="Permalink to this headline">¶</a></h1>
<div id="vib:model2x2"></div>
<p>A standard technique for solving second-order ODEs is to rewrite them
as a system of first-order ODEs and then choose a solution strategy
from the vast collection of methods for first-order ODE systems.
Given the second-order ODE problem</p>
<div class="math notranslate nohighlight">
\[
u^{\prime\prime} + \omega^2 u = 0,\quad u(0)=I,\ u^{\prime}(0)=0,
\]</div>
<p>we introduce the auxiliary variable <span class="math notranslate nohighlight">\(v=u^{\prime}\)</span> and express the ODE problem
in terms of first-order derivatives of <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span>:</p>
<!-- Equation labels as ordinary links -->
<div id="vib:model2x2:ueq"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u^{\prime} = v,
\label{vib:model2x2:ueq} \tag{24}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="vib:model2x2:veq"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
v^{\prime} = -\omega^2 u
\label{vib:model2x2:veq} \tag{25}
\thinspace .
\end{equation}
\]</div>
<p>The initial conditions become <span class="math notranslate nohighlight">\(u(0)=I\)</span> and <span class="math notranslate nohighlight">\(v(0)=0\)</span>.</p>
<div class="section" id="the-forward-euler-scheme">
<h2><span class="section-number">5.1. </span>The Forward Euler scheme<a class="headerlink" href="#the-forward-euler-scheme" title="Permalink to this headline">¶</a></h2>
<p>A Forward Euler approximation to our <span class="math notranslate nohighlight">\(2\times 2\)</span> system of ODEs
(<a class="reference external" href="#vib:model2x2:ueq">24</a>)-(<a class="reference external" href="#vib:model2x2:veq">25</a>) becomes</p>
<!-- Equation labels as ordinary links -->
<div id="_auto9"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\lbrack D_t^+ u = v\rbrack^n,
\label{_auto9} \tag{26}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto10"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
\lbrack D_t^+ v = -\omega^2 u\rbrack^n,
\label{_auto10} \tag{27}
\end{equation}
\]</div>
<p>or written out,</p>
<!-- Equation labels as ordinary links -->
<div id="vib:undamped:FE1"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u^{n+1} = u^n + \Delta t v^n,
\label{vib:undamped:FE1} \tag{28}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="vib:undamped:FE2"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
v^{n+1} = v^n -\Delta t \omega^2 u^n
\label{vib:undamped:FE2} \tag{29}
\thinspace .
\end{equation}
\]</div>
<p>Let us briefly compare this Forward Euler method with the centered
difference scheme for the second-order differential equation. We have
from (<a class="reference external" href="#vib:undamped:FE1">28</a>) and (<a class="reference external" href="#vib:undamped:FE2">29</a>) applied at
levels <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(n-1\)</span> that</p>
<div class="math notranslate nohighlight">
\[
u^{n+1} = u^n + \Delta t v^n = u^n + \Delta t (v^{n-1} -\Delta t \omega^2 u^{n-1})\thinspace .
\]</div>
<p>Since from (<a class="reference external" href="#vib:undamped:FE1">28</a>)</p>
<div class="math notranslate nohighlight">
\[
v^{n-1} = \frac{1}{\Delta t}(u^{n}-u^{n-1}),
\]</div>
<p>it follows that</p>
<div class="math notranslate nohighlight">
\[
u^{n+1} = 2u^n - u^{n-1} -\Delta t^2\omega^2 u^{n-1},
\]</div>
<p>which is very close to the centered difference scheme, but the last
term is evaluated at <span class="math notranslate nohighlight">\(t_{n-1}\)</span> instead of <span class="math notranslate nohighlight">\(t_n\)</span>.  Rewriting, so that
<span class="math notranslate nohighlight">\(\Delta t^2\omega^2u^{n-1}\)</span> appears alone on the right-hand side, and
then dividing by <span class="math notranslate nohighlight">\(\Delta t^2\)</span>, the new left-hand side is an
approximation to <span class="math notranslate nohighlight">\(u^{\prime\prime}\)</span> at <span class="math notranslate nohighlight">\(t_n\)</span>, while the right-hand
side is sampled at <span class="math notranslate nohighlight">\(t_{n-1}\)</span>.  All terms should be sampled at the same
mesh point, so using <span class="math notranslate nohighlight">\(\omega^2 u^{n-1}\)</span> instead of <span class="math notranslate nohighlight">\(\omega^2 u^n\)</span>
points to a kind of mathematical error in the derivation of the
scheme. This error turns out to be rather crucial for the accuracy of
the Forward Euler method applied to vibration problems (the section <a class="reference external" href="#vib:model2x2:compare">Comparison of schemes</a> has examples).</p>
<p>The reasoning above does not imply that the Forward Euler scheme is not
correct, but more that it is almost equivalent to a second-order accurate
scheme for the second-order ODE formulation, and that the error
committed has to do with a wrong sampling point.</p>
</div>
<div class="section" id="the-backward-euler-scheme">
<h2><span class="section-number">5.2. </span>The Backward Euler scheme<a class="headerlink" href="#the-backward-euler-scheme" title="Permalink to this headline">¶</a></h2>
<p>A Backward Euler approximation to the ODE system is equally easy to
write up in the operator notation:</p>
<!-- Equation labels as ordinary links -->
<div id="_auto11"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\lbrack D_t^- u = v\rbrack^{n+1},
\label{_auto11} \tag{30}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto12"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
\lbrack D_t^- v = -\omega u\rbrack^{n+1} \thinspace .
\label{_auto12} \tag{31}
\end{equation}
\]</div>
<p>This becomes a coupled system for <span class="math notranslate nohighlight">\(u^{n+1}\)</span> and <span class="math notranslate nohighlight">\(v^{n+1}\)</span>:</p>
<!-- Equation labels as ordinary links -->
<div id="vib:undamped:BE1"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u^{n+1} - \Delta t v^{n+1} = u^{n},
\label{vib:undamped:BE1} \tag{32}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="vib:undamped:BE2"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
v^{n+1} + \Delta t \omega^2 u^{n+1} = v^{n}
\label{vib:undamped:BE2} \tag{33}
\thinspace .
\end{equation}
\]</div>
<p>We can compare (<a class="reference external" href="#vib:undamped:BE1">32</a>)-(<a class="reference external" href="#vib:undamped:BE2">33</a>) with
the centered scheme (<a class="reference external" href="#vib:ode1:step4">7</a>) for the second-order
differential equation.  To this end, we eliminate <span class="math notranslate nohighlight">\(v^{n+1}\)</span> in
(<a class="reference external" href="#vib:undamped:BE1">32</a>) using (<a class="reference external" href="#vib:undamped:BE2">33</a>) solved with
respect to <span class="math notranslate nohighlight">\(v^{n+1}\)</span>.  Thereafter, we eliminate <span class="math notranslate nohighlight">\(v^n\)</span> using
(<a class="reference external" href="#vib:undamped:BE1">32</a>) solved with respect to <span class="math notranslate nohighlight">\(v^{n+1}\)</span> and also
replacing <span class="math notranslate nohighlight">\(n+1\)</span> by <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(n\)</span> by <span class="math notranslate nohighlight">\(n-1\)</span>.  The resulting equation
involving only <span class="math notranslate nohighlight">\(u^{n+1}\)</span>, <span class="math notranslate nohighlight">\(u^n\)</span>, and <span class="math notranslate nohighlight">\(u^{n-1}\)</span> can be ordered as</p>
<div class="math notranslate nohighlight">
\[
\frac{u^{n+1}-2u^n+u^{n-1}}{\Delta t^2} = -\omega^2 u^{n+1},
\]</div>
<p>which has almost the same form as the centered scheme for the
second-order differential equation, but the right-hand side is
evaluated at <span class="math notranslate nohighlight">\(u^{n+1}\)</span> and not <span class="math notranslate nohighlight">\(u^n\)</span>. This inconsistent sampling
of terms has a dramatic effect on the numerical solution, as we
demonstrate in the section <a class="reference external" href="#vib:model2x2:compare">Comparison of schemes</a>.</p>
</div>
<div class="section" id="the-crank-nicolson-scheme">
<h2><span class="section-number">5.3. </span>The Crank-Nicolson scheme<a class="headerlink" href="#the-crank-nicolson-scheme" title="Permalink to this headline">¶</a></h2>
<div id="vib:undamped:CN"></div>
<p>The Crank-Nicolson scheme takes this form in the operator notation:</p>
<!-- Equation labels as ordinary links -->
<div id="_auto13"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\lbrack D_t u = \overline{v}^t\rbrack^{n+\frac{1}{2}},
\label{_auto13} \tag{34}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto14"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
\lbrack D_t v = -\omega^2 \overline{u}^t\rbrack^{n+\frac{1}{2}}
\thinspace .
\label{_auto14} \tag{35}
\end{equation}
\]</div>
<p>Writing the equations out and rearranging terms,
shows that this is also a coupled system of two linear equations
at each time level:</p>
<!-- Equation labels as ordinary links -->
<div id="_auto15"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u^{n+1} - \frac{1}{2}\Delta t v^{n+1} = u^{n} + \frac{1}{2}\Delta t v^{n},
\label{_auto15} \tag{36}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto16"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
v^{n+1} + \frac{1}{2}\Delta t \omega^2 u^{n+1} = v^{n}
- \frac{1}{2}\Delta t \omega^2 u^{n}
\thinspace .
\label{_auto16} \tag{37}
\end{equation}
\]</div>
<p>We may compare also this scheme to the centered discretization of
the second-order ODE. It turns out that the Crank-Nicolson scheme is
equivalent to the discretization</p>
<!-- Equation labels as ordinary links -->
<div id="vib:undamped:CN:equiv_utt"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\frac{u^{n+1} - 2u^n + u^{n-1}}{\Delta t^2} = - \omega^2
\frac{1}{4}(u^{n+1} + 2u^n + u^{n-1}) = -\omega^2 u^{n} +
\mathcal{O}{\Delta t^2}\thinspace .
\label{vib:undamped:CN:equiv_utt} \tag{38}
\end{equation}
\]</div>
<p>That is, the Crank-Nicolson is equivalent to (<a class="reference external" href="#vib:ode1:step4">7</a>)
for the second-order ODE, apart from an extra term of size
<span class="math notranslate nohighlight">\(\Delta t^2\)</span>, but this is an error of the same order as in
the finite difference approximation on the left-hand side of the
equation anyway. The fact that the Crank-Nicolson scheme is so
close to (<a class="reference external" href="#vib:ode1:step4">7</a>) makes it a much better method than
the Forward or Backward Euler methods for vibration problems,
as will be illustrated in the section <a class="reference external" href="#vib:model2x2:compare">Comparison of schemes</a>.</p>
<p>Deriving (<a class="reference external" href="#vib:undamped:CN:equiv_utt">38</a>) is a bit tricky.
We start with rewriting the Crank-Nicolson equations as follows</p>
<!-- Equation labels as ordinary links -->
<div id="vib:undamped:CN3a"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u^{n+1} - u^n = \frac{1}{2}\Delta t(v^{n+1} + v^n),
\label{vib:undamped:CN3a} \tag{39}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="vib:undamped:CN4a"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
v^{n+1}  = v^n -\frac{1}{2}\Delta t\omega^2 (u^{n+1} + u^n),
\label{vib:undamped:CN4a} \tag{40}
\end{equation}
\]</div>
<p>and add the latter at the previous time level as well:</p>
<!-- Equation labels as ordinary links -->
<div id="vib:undamped:CN4b1"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
v^{n}  = v^{n-1} -\frac{1}{2}\Delta t\omega^2(u^{n} + u^{n-1})
\label{vib:undamped:CN4b1} \tag{41}
\end{equation}
\]</div>
<p>We can also rewrite (<a class="reference external" href="#vib:undamped:CN3a">39</a>) at the previous time level
as</p>
<!-- Equation labels as ordinary links -->
<div id="vib:undamped:CN4b"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
v^{n} + v^{n-1} = \frac{2}{\Delta t}(u^{n} - u^{n-1})\thinspace .
\label{vib:undamped:CN4b} \tag{42}
\end{equation}
\]</div>
<p>Inserting (<a class="reference external" href="#vib:undamped:CN4a">40</a>) for <span class="math notranslate nohighlight">\(v^{n+1}\)</span> in
(<a class="reference external" href="#vib:undamped:CN3a">39</a>) and
(<a class="reference external" href="#vib:undamped:CN4b1">41</a>) for <span class="math notranslate nohighlight">\(v^{n}\)</span> in
(<a class="reference external" href="#vib:undamped:CN3a">39</a>) yields after some reordering:</p>
<div class="math notranslate nohighlight">
\[
u^{n+1} - u^n = \frac{1}{2}(-\frac{1}{2}\Delta t\omega^2
(u^{n+1} + 2u^n + u^{n-1}) + v^n + v^{n-1})\thinspace .
\]</div>
<p>Now, <span class="math notranslate nohighlight">\(v^n + v^{n-1}\)</span> can be eliminated by means of
(<a class="reference external" href="#vib:undamped:CN4b">42</a>). The result becomes</p>
<!-- Equation labels as ordinary links -->
<div id="vib:undamped:CN5"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u^{n+1} - 2u^n + u^{n-1} = -\Delta t^2\omega^2
\frac{1}{4}(u^{n+1} + 2u^n + u^{n-1})\thinspace .
\label{vib:undamped:CN5} \tag{43}
\end{equation}
\]</div>
<p>It can be shown that</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{4}(u^{n+1} + 2u^n + u^{n-1}) \approx u^n + \mathcal{O}{\Delta t^2},
\]</div>
<p>meaning that (<a class="reference external" href="#vib:undamped:CN5">43</a>) is an approximation to
the centered scheme (<a class="reference external" href="#vib:ode1:step4">7</a>) for the second-order ODE where
the sampling error in the term <span class="math notranslate nohighlight">\(\Delta t^2\omega^2 u^n\)</span> is of the same
order as the approximation errors in the finite differences, i.e.,
<span class="math notranslate nohighlight">\(\mathcal{O}{\Delta t^2}\)</span>. The Crank-Nicolson scheme written as
(<a class="reference external" href="#vib:undamped:CN5">43</a>) therefore has consistent sampling of all
terms at the same time point <span class="math notranslate nohighlight">\(t_n\)</span>.</p>
</div>
<div class="section" id="comparison-of-schemes">
<h2><span class="section-number">5.4. </span>Comparison of schemes<a class="headerlink" href="#comparison-of-schemes" title="Permalink to this headline">¶</a></h2>
<div id="vib:model2x2:compare"></div>
<p>We can easily compare methods like the ones above (and many more!)
with the aid of the
<a class="reference external" href="https://github.com/hplgit/odespy">Odespy</a> package. Below is
a sketch of the code.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">odespy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># v, u numbering for EulerCromer to work well</span>
    <span class="n">v</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">u</span>  <span class="c1"># u is array of length 2 holding our [v, u]</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">-</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">run_solvers_and_plot</span><span class="p">(</span><span class="n">solvers</span><span class="p">,</span> <span class="n">timesteps_per_period</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                         <span class="n">num_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">):</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>  <span class="c1"># duration of one period</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">P</span><span class="o">/</span><span class="n">timesteps_per_period</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="n">num_periods</span><span class="o">*</span><span class="n">timesteps_per_period</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span>
    <span class="n">t_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">legends</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">solver</span> <span class="ow">in</span> <span class="n">solvers</span><span class="p">:</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">f_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="n">w</span><span class="p">})</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">I</span><span class="p">])</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">t_mesh</span><span class="p">)</span>
</pre></div>
</div>
<p>There is quite some more code dealing with plots also, and we refer
to the source file <span class="xref myst"><code class="docutils literal notranslate"><span class="pre">vib_undamped_odespy.py</span></code></span>
for details. Observe that keyword arguments in <code class="docutils literal notranslate"><span class="pre">f(u,t,w=1)</span></code> can
be supplied through a solver parameter <code class="docutils literal notranslate"><span class="pre">f_kwargs</span></code> (dictionary of
additional keyword arguments to <code class="docutils literal notranslate"><span class="pre">f</span></code>).</p>
<p>Specification of the Forward Euler, Backward Euler, and
Crank-Nicolson schemes is done like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">solvers</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">odespy</span><span class="o">.</span><span class="n">ForwardEuler</span><span class="p">(</span><span class="n">f</span><span class="p">),</span>
    <span class="c1"># Implicit methods must use Newton solver to converge</span>
    <span class="n">odespy</span><span class="o">.</span><span class="n">BackwardEuler</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nonlinear_solver</span><span class="o">=</span><span class="s1">&#39;Newton&#39;</span><span class="p">),</span>
    <span class="n">odespy</span><span class="o">.</span><span class="n">CrankNicolson</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nonlinear_solver</span><span class="o">=</span><span class="s1">&#39;Newton&#39;</span><span class="p">),</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">vib_undamped_odespy.py</span></code> program makes two plots of the computed
solutions with the various methods in the <code class="docutils literal notranslate"><span class="pre">solvers</span></code> list: one plot
with <span class="math notranslate nohighlight">\(u(t)\)</span> versus <span class="math notranslate nohighlight">\(t\)</span>, and one <em>phase plane plot</em> where <span class="math notranslate nohighlight">\(v\)</span> is
plotted against <span class="math notranslate nohighlight">\(u\)</span>.  That is, the phase plane plot is the curve
<span class="math notranslate nohighlight">\((u(t),v(t))\)</span> parameterized by <span class="math notranslate nohighlight">\(t\)</span>. Analytically, <span class="math notranslate nohighlight">\(u=I\cos(\omega t)\)</span>
and <span class="math notranslate nohighlight">\(v=u^{\prime}=-\omega I\sin(\omega t)\)</span>.  The exact curve
<span class="math notranslate nohighlight">\((u(t),v(t))\)</span> is therefore an ellipse, which often looks like a circle
in a plot if the axes are automatically scaled. The important feature,
however, is that the exact curve <span class="math notranslate nohighlight">\((u(t),v(t))\)</span> is closed and repeats
itself for every period. Not all numerical schemes are capable of
doing that, meaning that the amplitude instead shrinks or grows with
time.</p>
<p><a class="reference external" href="#vib:ode1:1st:odespy:theta:phaseplane">Figure</a> show the
results. Note that Odespy applies the label MidpointImplicit for what
we have specified as <code class="docutils literal notranslate"><span class="pre">CrankNicolson</span></code> in the code (<code class="docutils literal notranslate"><span class="pre">CrankNicolson</span></code> is
just a synonym for class <code class="docutils literal notranslate"><span class="pre">MidpointImplicit</span></code> in the Odespy code).  The
Forward Euler scheme in <a class="reference external" href="#vib:ode1:1st:odespy:theta:phaseplane">Figure</a> has a pronounced spiral
curve, pointing to the fact that the amplitude steadily grows, which
is also evident in <a class="reference external" href="#vib:ode1:1st:odespy:theta">Figure</a>.  The
Backward Euler scheme has a similar feature, except that the spriral
goes inward and the amplitude is significantly damped.  The changing
amplitude and the spiral form decreases with decreasing time step.
The Crank-Nicolson scheme looks much more accurate.  In fact, these
plots tell that the Forward and Backward Euler schemes are not
suitable for solving our ODEs with oscillating solutions.</p>
<!-- dom:FIGURE: [fig-vib/vib_theta_1_pp.png, width=800 frac=1.0] Comparison of classical schemes in the phase plane for two time step values. <div id="vib:ode1:1st:odespy:theta:phaseplane"></div> -->
<!-- begin figure -->
<div id="vib:ode1:1st:odespy:theta:phaseplane"></div>
<p>Comparison of classical schemes in the phase plane for two time step values.</p>
<img src="fig-vib/vib_theta_1_pp.png" width=800>
<!-- end figure -->
<!-- dom:FIGURE: [fig-vib/vib_theta_1_u.png, width=800 frac=1.0] Comparison of solution curves for classical schemes. <div id="vib:ode1:1st:odespy:theta"></div> -->
<!-- begin figure -->
<div id="vib:ode1:1st:odespy:theta"></div>
<p>Comparison of solution curves for classical schemes.</p>
<img src="fig-vib/vib_theta_1_u.png" width=800>
<!-- end figure -->
</div>
<div class="section" id="runge-kutta-methods">
<h2><span class="section-number">5.5. </span>Runge-Kutta methods<a class="headerlink" href="#runge-kutta-methods" title="Permalink to this headline">¶</a></h2>
<p>We may run two other popular standard methods for first-order ODEs,
the 2nd- and 4th-order Runge-Kutta methods, to see how they
perform. The figures below show the solutions with larger <span class="math notranslate nohighlight">\(\Delta t\)</span>
values than what was used in the previous two plots.</p>
<!-- dom:FIGURE: [fig-vib/vib_RK_1_pp.png, width=800 frac=1.0] Comparison of Runge-Kutta schemes in the phase plane. <div id="vib:ode1:1st:odespy:RK:phaseplane"></div> -->
<!-- begin figure -->
<div id="vib:ode1:1st:odespy:RK:phaseplane"></div>
<p>Comparison of Runge-Kutta schemes in the phase plane.</p>
<img src="fig-vib/vib_RK_1_pp.png" width=800>
<!-- end figure -->
<!-- dom:FIGURE: [fig-vib/vib_RK_1_u.png, width=800 frac=1.0] Comparison of Runge-Kutta schemes. <div id="vib:ode1:1st:odespy:RK"></div> -->
<!-- begin figure -->
<div id="vib:ode1:1st:odespy:RK"></div>
<p>Comparison of Runge-Kutta schemes.</p>
<img src="fig-vib/vib_RK_1_u.png" width=800>
<!-- end figure -->
<p>The visual impression is that the 4th-order Runge-Kutta method is very
accurate, under all circumstances in these tests, while the 2nd-order
scheme suffers from amplitude errors unless the time step is very
small.</p>
<p>The corresponding results for the Crank-Nicolson scheme are shown in
<a class="reference external" href="#vib:ode1:1st:odespy:CN:long:phaseplane">Figure</a>.  It is clear that
the Crank-Nicolson scheme outhinspace .erforms the 2nd-order Runge-Kutta
method. Both schemes have the same order of accuracy <span class="math notranslate nohighlight">\(\mathcal{O}{\Delta
t^2}\)</span>, but their differences in the accuracy that matters in a real
physical application is very clearly pronounced in this example.
<a class="reference external" href="#vib:exer:undamped:odespy">Exercise 13: Investigate the amplitude errors of many solvers</a> invites you to investigate how
the amplitude is computed by a series of famous methods for
first-order ODEs.</p>
<!-- dom:FIGURE: [fig-vib/vib_CN_10_pp.png, width=800 frac=1.0] Long-time behavior of the Crank-Nicolson scheme in the phase plane. <div id="vib:ode1:1st:odespy:CN:long:phaseplane"></div> -->
<!-- begin figure -->
<div id="vib:ode1:1st:odespy:CN:long:phaseplane"></div>
<p>Long-time behavior of the Crank-Nicolson scheme in the phase plane.</p>
<img src="fig-vib/vib_CN_10_pp.png" width=800>
<!-- end figure -->
</div>
<div class="section" id="analysis-of-the-forward-euler-scheme">
<h2><span class="section-number">5.6. </span>Analysis of the Forward Euler scheme<a class="headerlink" href="#analysis-of-the-forward-euler-scheme" title="Permalink to this headline">¶</a></h2>
<p>We may try to find exact solutions of the discrete equations
(<a class="reference external" href="#vib:undamped:FE1">28</a>)-(<a class="reference external" href="#vib:undamped:FE2">29</a>) in the Forward Euler
method to better understand why this otherwise useful method has so
bad performance for vibration ODEs. An “ansatz” for the solution of
the discrete equations is</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
u^n &amp;= IA^n,\\ 
v^n &amp;= qIA^n,
\end{align*}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(q\)</span> and <span class="math notranslate nohighlight">\(A\)</span> are scalars to be determined. We could have used a complex
exponential form <span class="math notranslate nohighlight">\(e^{i\tilde\omega n\Delta t}\)</span> since we get
oscillatory solutions, but the oscillations grow in the Forward Euler
method, so the numerical frequency <span class="math notranslate nohighlight">\(\tilde\omega\)</span> will be complex
anyway (producing an exponentially growing amplitude). Therefore, it is
easier to just work with potentially complex <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(q\)</span> as introduced
above.</p>
<p>The Forward Euler scheme leads to</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
A &amp;= 1 + \Delta t q,\\ 
A &amp;= 1 - \Delta t\omega^2 q^{-1}\thinspace .
\end{align*}
\end{split}\]</div>
<p>We can easily eliminate <span class="math notranslate nohighlight">\(A\)</span>, get <span class="math notranslate nohighlight">\(q^2 + \omega^2=0\)</span>, and solve for</p>
<div class="math notranslate nohighlight">
\[
q = \pm i\omega,
\]</div>
<p>which gives</p>
<div class="math notranslate nohighlight">
\[
A = 1 \pm \Delta t i\omega\thinspace .
\]</div>
<p>We shall take the real part of <span class="math notranslate nohighlight">\(A^n\)</span> as the solution. The two values
of <span class="math notranslate nohighlight">\(A\)</span> are complex conjugates, and the real part of <span class="math notranslate nohighlight">\(A^n\)</span> will be the
same for both roots. This is easy to realize if we rewrite the complex
numbers in polar form, which is also convenient for further analysis
and understanding.  The polar form <span class="math notranslate nohighlight">\(re^{i\theta}\)</span> of a complex number
<span class="math notranslate nohighlight">\(x+iy\)</span> has <span class="math notranslate nohighlight">\(r=\sqrt{x^2+y^2}\)</span> and <span class="math notranslate nohighlight">\(\theta = \tan^{-1}(y/x)\)</span>.  Hence,
the polar form of the two values for <span class="math notranslate nohighlight">\(A\)</span> becomes</p>
<div class="math notranslate nohighlight">
\[
1 \pm \Delta t i\omega = \sqrt{1+\omega^2\Delta t^2}e^{\pm i\tan^{-1}(\omega\Delta t)}\thinspace .
\]</div>
<p>Now it is very easy to compute <span class="math notranslate nohighlight">\(A^n\)</span>:</p>
<div class="math notranslate nohighlight">
\[
(1 \pm \Delta t i\omega)^n = (1+\omega^2\Delta t^2)^{n/2}e^{\pm ni\tan^{-1}(\omega\Delta t)}\thinspace .
\]</div>
<p>Since <span class="math notranslate nohighlight">\(\cos (\theta n) = \cos (-\theta n)\)</span>, the real parts of the two
numbers become the same. We therefore continue with the solution that has
the plus sign.</p>
<p>The general solution is <span class="math notranslate nohighlight">\(u^n = CA^n\)</span>, where <span class="math notranslate nohighlight">\(C\)</span> is a constant
determined from the initial condition: <span class="math notranslate nohighlight">\(u^0=C=I\)</span>. We have <span class="math notranslate nohighlight">\(u^n=IA^n\)</span>
and <span class="math notranslate nohighlight">\(v^n=qIA^n\)</span>. The final solutions are just the real part of the
expressions in polar form:</p>
<!-- Equation labels as ordinary links -->
<div id="_auto17"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u^n  =
I(1+\omega^2\Delta t^2)^{n/2}\cos (n\tan^{-1}(\omega\Delta t)),
\label{_auto17} \tag{44}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto18"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
v^n =- \omega
I(1+\omega^2\Delta t^2)^{n/2}\sin (n\tan^{-1}(\omega\Delta t))\thinspace .
\label{_auto18} \tag{45}
\end{equation}
\]</div>
<p>The expression <span class="math notranslate nohighlight">\((1+\omega^2\Delta t^2)^{n/2}\)</span> causes growth of
the amplitude, since a number greater than one is raised to a positive
exponent <span class="math notranslate nohighlight">\(n/2\)</span>. We can develop a series expression to better understand
the formula for the amplitude. Introducing <span class="math notranslate nohighlight">\(p=\omega\Delta t\)</span> as the
key variable and using <code class="docutils literal notranslate"><span class="pre">sympy</span></code> gives</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">amplitude</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="n">amplitude</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle 1 + \frac{n p^{2}}{2} + O\left(p^{4}\right)\]</div>
</div>
</div>
<p>The amplitude goes like <span class="math notranslate nohighlight">\(1 + \frac{1}{2} n\omega^2\Delta t^2\)</span>, clearly growing
linearly in time (with <span class="math notranslate nohighlight">\(n\)</span>).</p>
<p>We can also investigate the error in the angular frequency by a
series expansion:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n</span><span class="o">*</span><span class="n">atan</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle n \left(p - \frac{p^{3}}{3} + O\left(p^{4}\right)\right)\]</div>
</div>
</div>
<p>This means that the solution for <span class="math notranslate nohighlight">\(u^n\)</span> can be written as</p>
<div class="math notranslate nohighlight">
\[
u^n = (1 + \frac{1}{2} n\omega^2\Delta t^2 + \mathcal{O}{\Delta t^4})
\cos\left(\omega t - \frac{1}{3}\omega t\Delta t^2 + \mathcal{O}{\Delta t^4}\right)
\thinspace .
\]</div>
<p>The error in the angular frequency is of the same order as in the
scheme (<a class="reference external" href="#vib:ode1:step4">7</a>) for the second-order ODE, but the error
in the amplitude is severe.</p>
</div>
</div>
<div class="section" id="energy-considerations">
<h1><span class="section-number">6. </span>Energy considerations<a class="headerlink" href="#energy-considerations" title="Permalink to this headline">¶</a></h1>
<div id="vib:model1:energy"></div>
<p>The observations of various methods in the previous section can be
better interpreted if we compute a quantity reflecting
the total <em>energy of the system</em>. mathcal{I}_t turns out that this quantity,</p>
<div class="math notranslate nohighlight">
\[
E(t) = \frac{1}{2}(u^{\prime})^2 + \frac{1}{2}\omega^2u^2,
\]</div>
<p>is <em>constant</em> for all <span class="math notranslate nohighlight">\(t\)</span>. Checking that <span class="math notranslate nohighlight">\(E(t)\)</span> really remains constant
brings evidence that the numerical computations are sound.
mathcal{I}_t turns out that <span class="math notranslate nohighlight">\(E\)</span> is proportional to the mechanical energy
in the system. Conservation of energy is
much used to check numerical simulations, so it is well invested time to
dive into this subject.</p>
<div class="section" id="derivation-of-the-energy-expression">
<h2><span class="section-number">6.1. </span>Derivation of the energy expression<a class="headerlink" href="#derivation-of-the-energy-expression" title="Permalink to this headline">¶</a></h2>
<div id="vib:model1:energy:expr"></div>
<p>We start out with multiplying</p>
<div class="math notranslate nohighlight">
\[
u^{\prime\prime} + \omega^2 u = 0,
\]</div>
<p>by <span class="math notranslate nohighlight">\(u^{\prime}\)</span> and integrating from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(T\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\int_0^T u^{\prime\prime}u^{\prime} dt + \int_0^T\omega^2 u u^{\prime} dt = 0\thinspace .
\]</div>
<p>Observing that</p>
<div class="math notranslate nohighlight">
\[
u^{\prime\prime}u^{\prime} = \frac{d}{dt}\frac{1}{2}(u^{\prime})^2,\quad uu^{\prime} = \frac{d}{dt} {\frac{1}{2}}u^2,
\]</div>
<p>we get</p>
<div class="math notranslate nohighlight">
\[
\int_0^T (\frac{d}{dt}\frac{1}{2}(u^{\prime})^2 + \frac{d}{dt} \frac{1}{2}\omega^2u^2)dt = E(T) - E(0)=0,
\]</div>
<p>where we have introduced</p>
<!-- Equation labels as ordinary links -->
<div id="vib:model1:energy:balance1"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
E(t) = \frac{1}{2}(u^{\prime})^2 + \frac{1}{2}\omega^2u^2\thinspace .
\label{vib:model1:energy:balance1} \tag{46}
\end{equation}
\]</div>
<p>The important result from this derivation is that the total energy
is constant:</p>
<div class="math notranslate nohighlight">
\[
E(t) = E(0)\thinspace .
\]</div>
<p><strong><span class="math notranslate nohighlight">\(E(t)\)</span> is closely related to the system’s energy.</strong></p>
<p>The quantity <span class="math notranslate nohighlight">\(E(t)\)</span> derived above is physically not the mechanical energy of a
vibrating mechanical system, but the energy per unit mass. To see this,
we start with Newton’s second law <span class="math notranslate nohighlight">\(F=ma\)</span> (<span class="math notranslate nohighlight">\(F\)</span> is the sum of forces, <span class="math notranslate nohighlight">\(m\)</span>
is the mass of the system, and <span class="math notranslate nohighlight">\(a\)</span> is the acceleration).
The displacement <span class="math notranslate nohighlight">\(u\)</span> is related to <span class="math notranslate nohighlight">\(a\)</span> through
<span class="math notranslate nohighlight">\(a=u^{\prime\prime}\)</span>. With a spring force as the only force we have <span class="math notranslate nohighlight">\(F=-ku\)</span>, where
<span class="math notranslate nohighlight">\(k\)</span> is a spring constant measuring the stiffness of the spring.
Newton’s second law then implies the differential equation</p>
<div class="math notranslate nohighlight">
\[
-ku = mu^{\prime\prime}\quad\Rightarrow mu^{\prime\prime} + ku = 0\thinspace .
\]</div>
<p>This equation of motion can be turned into an energy balance equation
by finding the work done by each term during a time interval <span class="math notranslate nohighlight">\([0,T]\)</span>.
To this end, we multiply the equation by <span class="math notranslate nohighlight">\(du=u^{\prime}dt\)</span> and integrate:</p>
<div class="math notranslate nohighlight">
\[
\int_0^T muu^{\prime}dt + \int_0^T kuu^{\prime}dt = 0\thinspace .
\]</div>
<p>The result is</p>
<div class="math notranslate nohighlight">
\[
\tilde E(t) = E_k(t) + E_p(t) = 0,
\]</div>
<p>where</p>
<!-- Equation labels as ordinary links -->
<div id="vib:model1:energy:kinetic"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
E_k(t) = \frac{1}{2}mv^2,\quad v=u^{\prime},
\label{vib:model1:energy:kinetic} \tag{47}
\end{equation}
\]</div>
<p>is the <em>kinetic energy</em> of the system, and</p>
<!-- Equation labels as ordinary links -->
<div id="vib:model1:energy:potential"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
E_p(t) = {\frac{1}{2}}ku^2
\label{vib:model1:energy:potential} \tag{48}
\end{equation}
\]</div>
<p>is the <em>potential energy</em>. The sum <span class="math notranslate nohighlight">\(\tilde E(t)\)</span> is the total mechanical energy.
The derivation demonstrates the famous energy principle that, under
the right physical circumstances, any
change in the kinetic energy is due to a change in potential energy
and vice versa. (This principle breaks down when we introduce damping
in the system, as we do in the section <a class="reference external" href="vib_gen.ipynb#vib:model2">Generalization: damping, nonlinearities, and
excitation</a>.)</p>
<p>The equation <span class="math notranslate nohighlight">\(mu^{\prime\prime}+ku=0\)</span> can be divided by <span class="math notranslate nohighlight">\(m\)</span> and written as
<span class="math notranslate nohighlight">\(u^{\prime\prime} + \omega^2u=0\)</span> for <span class="math notranslate nohighlight">\(\omega=\sqrt{k/m}\)</span>. The energy expression
<span class="math notranslate nohighlight">\(E(t)=\frac{1}{2}(u^{\prime})^2 + \frac{1}{2}\omega^2u^2\)</span> derived earlier is then
<span class="math notranslate nohighlight">\(\tilde E(t)/m\)</span>, i.e., mechanical energy per unit mass.</p>
<div class="section" id="energy-of-the-exact-solution">
<h3><span class="section-number">6.1.1. </span>Energy of the exact solution<a class="headerlink" href="#energy-of-the-exact-solution" title="Permalink to this headline">¶</a></h3>
<p>Analytically, we have <span class="math notranslate nohighlight">\(u(t)=I\cos\omega t\)</span>, if <span class="math notranslate nohighlight">\(u(0)=I\)</span> and <span class="math notranslate nohighlight">\(u^{\prime}(0)=0\)</span>,
so we can easily check the energy evolution and confirm that <span class="math notranslate nohighlight">\(E(t)\)</span>
is constant:</p>
<div class="math notranslate nohighlight">
\[
E(t) = {\frac{1}{2}}I^2 (-\omega\sin\omega t)^2
+ \frac{1}{2}\omega^2 I^2 \cos^2\omega t
= \frac{1}{2}\omega^2 (\sin^2\omega t + \cos^2\omega t) = \frac{1}{2}\omega^2
\thinspace .
\]</div>
</div>
<div class="section" id="growth-of-energy-in-the-forward-euler-scheme">
<h3><span class="section-number">6.1.2. </span>Growth of energy in the Forward Euler scheme<a class="headerlink" href="#growth-of-energy-in-the-forward-euler-scheme" title="Permalink to this headline">¶</a></h3>
<p>mathcal{I}_t is easy to show that the energy in the Forward Euler scheme increases
when stepping from time level <span class="math notranslate nohighlight">\(n\)</span> to <span class="math notranslate nohighlight">\(n+1\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
E^{n+1} &amp;= \frac{1}{2}(v^{n+1})^2 + \frac{1}{2}\omega^2 (u^{n+1})^2\\ 
&amp;= \frac{1}{2}(v^n - \omega^2\Delta t u^n)^2 + \frac{1}{2}\omega^2(u^n + \Delta t v^n)^2\\ 
&amp;= (1 + \Delta t^2\omega^2)E^n\thinspace .
\end{align*}
\end{split}\]</div>
</div>
</div>
<div class="section" id="an-error-measure-based-on-energy">
<h2><span class="section-number">6.2. </span>An error measure based on energy<a class="headerlink" href="#an-error-measure-based-on-energy" title="Permalink to this headline">¶</a></h2>
<div id="vib:model1:energy:measure"></div>
<p>The constant energy is well expressed by its initial value <span class="math notranslate nohighlight">\(E(0)\)</span>, so that
the error in mechanical energy can be computed as a mesh function by</p>
<!-- Equation labels as ordinary links -->
<div id="_auto19"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
e_E^n = \frac{1}{2}\left(\frac{u^{n+1}-u^{n-1}}{2\Delta t}\right)^2
+ \frac{1}{2}\omega^2 (u^n)^2 - E(0),
\quad n=1,\ldots,N_t-1,
\label{_auto19} \tag{49}
\end{equation}
\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[
E(0) = {\frac{1}{2}}V^2 + \frac{1}{2}\omega^2I^2,
\]</div>
<p>if <span class="math notranslate nohighlight">\(u(0)=I\)</span> and <span class="math notranslate nohighlight">\(u^{\prime}(0)=V\)</span>. Note that we have used a centered
approximation to <span class="math notranslate nohighlight">\(u^{\prime}\)</span>: <span class="math notranslate nohighlight">\(u^{\prime}(t_n)\approx [D_{2t}u]^n\)</span>.</p>
<p>A useful norm of the mesh function <span class="math notranslate nohighlight">\(e_E^n\)</span> for the discrete mechanical
energy can be the maximum absolute value of <span class="math notranslate nohighlight">\(e_E^n\)</span>:</p>
<div class="math notranslate nohighlight">
\[
||e_E^n||_{\ell^\infty} = \max_{1\leq n &lt;N_t} |e_E^n|\thinspace .
\]</div>
<p>Alternatively, we can compute other norms involving integration over
all mesh points, but we are often interested in worst case deviation
of the energy, and then the maximum value is of particular relevance.</p>
<p>A vectorized Python implementation of <span class="math notranslate nohighlight">\(e_E^n\)</span> takes the form</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># import numpy as np and compute u, t</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">E</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">((</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
<span class="n">E0</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">V</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">**</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="o">**</span><span class="mi">2</span>
<span class="n">e_E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">-</span> <span class="n">E0</span>
<span class="n">e_E_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">e_E</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
</pre></div>
</div>
<p>The convergence rates of the quantity <code class="docutils literal notranslate"><span class="pre">e_E_norm</span></code> can be used for
verification.  The value of <code class="docutils literal notranslate"><span class="pre">e_E_norm</span></code> is also useful for comparing
schemes through their ability to preserve energy. Below is a table
demonstrating the relative error in total energy for various schemes
(computed by the <span class="xref myst"><code class="docutils literal notranslate"><span class="pre">vib_undamped_odespy.py</span></code></span> program). The test problem is
<span class="math notranslate nohighlight">\(u^{\prime\prime} + 4\pi^2 u =0\)</span> with <span class="math notranslate nohighlight">\(u(0)=1\)</span> and <span class="math notranslate nohighlight">\(u'(0)=0\)</span>, so the
period is 1 and <span class="math notranslate nohighlight">\(E(t)\approx 4.93\)</span>. We clearly see that the
Crank-Nicolson and the Runge-Kutta schemes are superior to the Forward
and Backward Euler schemes already after one period.</p>
<table border="1">
<thead>
<tr><th align="center">        Method       </th> <th align="center">$T$</th> <th align="center">$\Delta t$</th> <th align="center">$\max \left\vert e_E^n\right\vert/e_E^0$</th> </tr>
</thead>
<tbody>
<tr><td align="left">   Forward Euler            </td> <td align="left">   $1$    </td> <td align="left">   $0.025$       </td> <td align="left">   $1.678\cdot 10^{0}$                         </td> </tr>
<tr><td align="left">   Backward Euler           </td> <td align="left">   $1$    </td> <td align="left">   $0.025$       </td> <td align="left">   $6.235\cdot 10^{-1}$                        </td> </tr>
<tr><td align="left">   Crank-Nicolson           </td> <td align="left">   $1$    </td> <td align="left">   $0.025$       </td> <td align="left">   $1.221\cdot 10^{-2}$                        </td> </tr>
<tr><td align="left">   Runge-Kutta 2nd-order    </td> <td align="left">   $1$    </td> <td align="left">   $0.025$       </td> <td align="left">   $6.076\cdot 10^{-3}$                        </td> </tr>
<tr><td align="left">   Runge-Kutta 4th-order    </td> <td align="left">   $1$    </td> <td align="left">   $0.025$       </td> <td align="left">   $8.214\cdot 10^{-3}$                        </td> </tr>
</tbody>
</table>
However, after 10 periods, the picture is much more dramatic:
<table border="1">
<thead>
<tr><th align="center">        Method       </th> <th align="center">$T$ </th> <th align="center">$\Delta t$</th> <th align="center">$\max \left\vert e_E^n\right\vert/e_E^0$</th> </tr>
</thead>
<tbody>
<tr><td align="left">   Forward Euler            </td> <td align="left">   $10$    </td> <td align="left">   $0.025$       </td> <td align="left">   $1.788\cdot 10^{4}$                         </td> </tr>
<tr><td align="left">   Backward Euler           </td> <td align="left">   $10$    </td> <td align="left">   $0.025$       </td> <td align="left">   $1.000\cdot 10^{0}$                         </td> </tr>
<tr><td align="left">   Crank-Nicolson           </td> <td align="left">   $10$    </td> <td align="left">   $0.025$       </td> <td align="left">   $1.221\cdot 10^{-2}$                        </td> </tr>
<tr><td align="left">   Runge-Kutta 2nd-order    </td> <td align="left">   $10$    </td> <td align="left">   $0.025$       </td> <td align="left">   $6.250\cdot 10^{-2}$                        </td> </tr>
<tr><td align="left">   Runge-Kutta 4th-order    </td> <td align="left">   $10$    </td> <td align="left">   $0.025$       </td> <td align="left">   $8.288\cdot 10^{-3}$                        </td> </tr>
</tbody>
</table>
The Runge-Kutta and Crank-Nicolson methods hardly change their energy
error with $T$, while the error in the Forward Euler method grows to
huge levels and a relative error of 1 in the Backward Euler method
points to $E(t)\rightarrow 0$ as $t$ grows large.
<p>Running multiple values of <span class="math notranslate nohighlight">\(\Delta t\)</span>, we can get some insight into
the convergence of the energy error:</p>
<table border="1">
<thead>
<tr><th align="center">        Method       </th> <th align="center">$T$ </th> <th align="center">$\Delta t$</th> <th align="center">$\max \left\vert e_E^n\right\vert/e_E^0$</th> </tr>
</thead>
<tbody>
<tr><td align="left">   Forward Euler            </td> <td align="left">   $10$    </td> <td align="left">   $0.05$        </td> <td align="left">   $1.120\cdot 10^{8}$                         </td> </tr>
<tr><td align="left">   Forward Euler            </td> <td align="left">   $10$    </td> <td align="left">   $0.025$       </td> <td align="left">   $1.788\cdot 10^{4}$                         </td> </tr>
<tr><td align="left">   Forward Euler            </td> <td align="left">   $10$    </td> <td align="left">   $0.0125$      </td> <td align="left">   $1.374\cdot 10^{2}$                         </td> </tr>
<tr><td align="left">   Backward Euler           </td> <td align="left">   $10$    </td> <td align="left">   $0.05$        </td> <td align="left">   $1.000\cdot 10^{0}$                         </td> </tr>
<tr><td align="left">   Backward Euler           </td> <td align="left">   $10$    </td> <td align="left">   $0.025$       </td> <td align="left">   $1.000\cdot 10^{0}$                         </td> </tr>
<tr><td align="left">   Backward Euler           </td> <td align="left">   $10$    </td> <td align="left">   $0.0125$      </td> <td align="left">   $9.928\cdot 10^{-1}$                        </td> </tr>
<tr><td align="left">   Crank-Nicolson           </td> <td align="left">   $10$    </td> <td align="left">   $0.05$        </td> <td align="left">   $4.756\cdot 10^{-2}$                        </td> </tr>
<tr><td align="left">   Crank-Nicolson           </td> <td align="left">   $10$    </td> <td align="left">   $0.025$       </td> <td align="left">   $1.221\cdot 10^{-2}$                        </td> </tr>
<tr><td align="left">   Crank-Nicolson           </td> <td align="left">   $10$    </td> <td align="left">   $0.0125$      </td> <td align="left">   $3.125\cdot 10^{-3}$                        </td> </tr>
<tr><td align="left">   Runge-Kutta 2nd-order    </td> <td align="left">   $10$    </td> <td align="left">   $0.05$        </td> <td align="left">   $6.152\cdot 10^{-1}$                        </td> </tr>
<tr><td align="left">   Runge-Kutta 2nd-order    </td> <td align="left">   $10$    </td> <td align="left">   $0.025$       </td> <td align="left">   $6.250\cdot 10^{-2}$                        </td> </tr>
<tr><td align="left">   Runge-Kutta 2nd-order    </td> <td align="left">   $10$    </td> <td align="left">   $0.0125$      </td> <td align="left">   $7.631\cdot 10^{-3}$                        </td> </tr>
<tr><td align="left">   Runge-Kutta 4th-order    </td> <td align="left">   $10$    </td> <td align="left">   $0.05$        </td> <td align="left">   $3.510\cdot 10^{-2}$                        </td> </tr>
<tr><td align="left">   Runge-Kutta 4th-order    </td> <td align="left">   $10$    </td> <td align="left">   $0.025$       </td> <td align="left">   $8.288\cdot 10^{-3}$                        </td> </tr>
<tr><td align="left">   Runge-Kutta 4th-order    </td> <td align="left">   $10$    </td> <td align="left">   $0.0125$      </td> <td align="left">   $2.058\cdot 10^{-3}$                        </td> </tr>
</tbody>
</table>
A striking fact from this table is that the error of the Forward Euler
method is reduced by the same factor as $\Delta t$ is reduced by,
while the error in the Crank-Nicolson method has a reduction
proportional to $\Delta t^2$ (we cannot say anything for the Backward
Euler method). However, for the RK2 method, halving $\Delta t$ reduces
the error by almost a factor of 10 (!), and for the RK4 method the
reduction seems proportional to $\Delta t^2$ only (and the trend is
confirmed by running smaller time steps, so for $\Delta t = 3.9\cdot
10^{-4}$ the relative error of RK2 is a factor 10 smaller than that of
RK4!).
<!-- Should build a verification test on the energy error. -->
<!-- Link phase plane plot to energy -->
<!-- A phase plane plot shows the curve $(u(t), u^{\prime}(t))$. -->
</div>
</div>
<div class="section" id="the-euler-cromer-method">
<h1><span class="section-number">7. </span>The Euler-Cromer method<a class="headerlink" href="#the-euler-cromer-method" title="Permalink to this headline">¶</a></h1>
<div id="vib:model2x2:EulerCromer"></div>
<p>While the Runge-Kutta methods and the Crank-Nicolson scheme work well
for the vibration equation modeled as a first-order ODE system, both
were inferior to the straightforward centered difference scheme for
the second-order equation <span class="math notranslate nohighlight">\(u^{\prime\prime}+\omega^2u=0\)</span>. However,
there is a similarly successful scheme available for the first-order
system <span class="math notranslate nohighlight">\(u^{\prime}=v\)</span>, <span class="math notranslate nohighlight">\(v^{\prime}=-\omega^2u\)</span>, to be presented below.
The ideas of the scheme and their further developments have become
very popular in particle and rigid body dynamics and hence are widely
used by physicists.</p>
<div class="section" id="forward-backward-discretization">
<h2><span class="section-number">7.1. </span>Forward-backward discretization<a class="headerlink" href="#forward-backward-discretization" title="Permalink to this headline">¶</a></h2>
<p>The idea is to apply a Forward Euler discretization to the first
equation and a Backward Euler discretization to the second. In
operator notation this is stated as</p>
<!-- Equation labels as ordinary links -->
<div id="_auto20"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\lbrack D_t^+u = v\rbrack^n,
\label{_auto20} \tag{50}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto21"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
\lbrack D_t^-v = -\omega^2 u\rbrack^{n+1}
\thinspace .
\label{_auto21} \tag{51}
\end{equation}
\]</div>
<p>We can write out the formulas and collect the unknowns on the left-hand side:</p>
<!-- Equation labels as ordinary links -->
<div id="vib:model2x2:EulerCromer:ueq1"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u^{n+1} = u^n + \Delta t v^n,
\label{vib:model2x2:EulerCromer:ueq1} \tag{52}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="vib:model2x2:EulerCromer:veq1"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
v^{n+1} = v^n -\Delta t \omega^2u^{n+1}
\label{vib:model2x2:EulerCromer:veq1} \tag{53}
\thinspace .
\end{equation}
\]</div>
<p>We realize that after <span class="math notranslate nohighlight">\(u^{n+1}\)</span> has been computed from
(<a class="reference external" href="#vib:model2x2:EulerCromer:ueq1">52</a>), it may be used directly
in
(<a class="reference external" href="#vib:model2x2:EulerCromer:veq1">53</a>) to compute <span class="math notranslate nohighlight">\(v^{n+1}\)</span>.</p>
<p>In physics, it is more common to update the <span class="math notranslate nohighlight">\(v\)</span> equation first, with a
forward difference, and thereafter the <span class="math notranslate nohighlight">\(u\)</span> equation, with a backward
difference that applies the most recently computed <span class="math notranslate nohighlight">\(v\)</span> value:</p>
<!-- Equation labels as ordinary links -->
<div id="vib:model2x2:EulerCromer:veq1b"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
v^{n+1} = v^n -\Delta t \omega^2u^{n},
\label{vib:model2x2:EulerCromer:veq1b} \tag{54}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="vib:model2x2:EulerCromer:ueq1b"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
u^{n+1} = u^n + \Delta t v^{n+1}\thinspace .
\label{vib:model2x2:EulerCromer:ueq1b} \tag{55}
\end{equation}
\]</div>
<p>The advantage of ordering the ODEs as in
(<a class="reference external" href="#vib:model2x2:EulerCromer:veq1b">54</a>)-(<a class="reference external" href="#vib:model2x2:EulerCromer:ueq1b">55</a>)
becomes evident when considering complicated models. Such models are
included if we write our vibration ODE more generally as</p>
<div class="math notranslate nohighlight">
\[
u^{\prime\prime} + g(u, u^{\prime}, t)=0\thinspace .
\]</div>
<p>We can rewrite this second-order ODE as two first-order ODEs,</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
v^{\prime} &amp;= -g(u,v,t),\\ 
u^{\prime} &amp;= v\thinspace .
\end{align*}
\end{split}\]</div>
<p>This rewrite allows the following scheme to be used:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
v^{n+1} &amp;= v^n -\Delta t\, g(u^n,v^n,t),\\ 
u^{n+1} &amp;= u^n + \Delta t\, v^{n+1}\thinspace .
\end{align*}
\end{split}\]</div>
<p>We realize that the first update works well with any <span class="math notranslate nohighlight">\(g\)</span> since old
values <span class="math notranslate nohighlight">\(u^n\)</span> and <span class="math notranslate nohighlight">\(v^n\)</span> are used. Switching the equations would
demand <span class="math notranslate nohighlight">\(u^{n+1}\)</span> and <span class="math notranslate nohighlight">\(v^{n+1}\)</span> values in <span class="math notranslate nohighlight">\(g\)</span> and result in nonlinear
algebraic equations to be solved at each time level.</p>
<!-- Despite using a backward difference, there is no need to solve a coupled -->
<!-- system for $u^{n+1}$ and $v^{n+1}$ because the structure of the ODEs -->
<!-- allows ([52](#vib:model2x2:EulerCromer:ueq1)) -->
<p>The scheme
(<a class="reference external" href="#vib:model2x2:EulerCromer:veq1b">54</a>)-(<a class="reference external" href="#vib:model2x2:EulerCromer:ueq1b">55</a>)
goes under several names: forward-backward scheme, <a class="reference external" href="http://en.wikipedia.org/wiki/Semi-implicit_Euler_method">semi-implicit
Euler method</a>,
semi-explicit Euler, symplectic Euler,
Newton-Stoermer-Verlet,
and Euler-Cromer.  We shall stick to the latter name.</p>
<p>How does the Euler-Cromer method preserve the total energy?
We may run the example from the section <a class="reference external" href="#vib:model1:energy:measure">An error measure based on energy</a>:</p>
<table border="1">
<thead>
<tr><th align="center">   Method   </th> <th align="center">$T$ </th> <th align="center">$\Delta t$</th> <th align="center">$\max \left\vert e_E^n\right\vert/e_E^0$</th> </tr>
</thead>
<tbody>
<tr><td align="left">   Euler-Cromer    </td> <td align="left">   $10$    </td> <td align="left">   $0.05$        </td> <td align="left">   $2.530\cdot 10^{-2}$                        </td> </tr>
<tr><td align="left">   Euler-Cromer    </td> <td align="left">   $10$    </td> <td align="left">   $0.025$       </td> <td align="left">   $6.206\cdot 10^{-3}$                        </td> </tr>
<tr><td align="left">   Euler-Cromer    </td> <td align="left">   $10$    </td> <td align="left">   $0.0125$      </td> <td align="left">   $1.544\cdot 10^{-3}$                        </td> </tr>
</tbody>
</table>
The relative error in the total energy decreases as $\Delta t^2$,
and the error level is slightly lower than for the Crank-Nicolson and
Runge-Kutta methods.
</div>
<div class="section" id="equivalence-with-the-scheme-for-the-second-order-ode">
<h2><span class="section-number">7.2. </span>Equivalence with the scheme for the second-order ODE<a class="headerlink" href="#equivalence-with-the-scheme-for-the-second-order-ode" title="Permalink to this headline">¶</a></h2>
<div id="vib:model2x2:EulerCromer:equiv"></div>
<p>We shall now show that the Euler-Cromer scheme for the system of
first-order equations is equivalent to the centered finite difference
method for the second-order vibration ODE (!).</p>
<p>We may eliminate the <span class="math notranslate nohighlight">\(v^n\)</span> variable from
(<a class="reference external" href="#vib:model2x2:EulerCromer:ueq1">52</a>)-(<a class="reference external" href="#vib:model2x2:EulerCromer:veq1">53</a>)
or
(<a class="reference external" href="#vib:model2x2:EulerCromer:veq1b">54</a>)-(<a class="reference external" href="#vib:model2x2:EulerCromer:ueq1b">55</a>).
The <span class="math notranslate nohighlight">\(v^{n+1}\)</span> term in (<a class="reference external" href="#vib:model2x2:EulerCromer:veq1b">54</a>) can
be eliminated from (<a class="reference external" href="#vib:model2x2:EulerCromer:ueq1b">55</a>):</p>
<!-- Equation labels as ordinary links -->
<div id="vib:model2x2:EulerCromer:elim1"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u^{n+1} = u^n + \Delta t (v^n - \omega^2\Delta t u^n)\thinspace .
\label{vib:model2x2:EulerCromer:elim1} \tag{56}
\end{equation}
\]</div>
<p>The <span class="math notranslate nohighlight">\(v^{n}\)</span> quantity can be expressed by <span class="math notranslate nohighlight">\(u^n\)</span> and <span class="math notranslate nohighlight">\(u^{n-1}\)</span>
using (<a class="reference external" href="#vib:model2x2:EulerCromer:ueq1b">55</a>):</p>
<div class="math notranslate nohighlight">
\[
v^{n} = \frac{u^n - u^{n-1}}{\Delta t},
\]</div>
<p>and when this is inserted in (<a class="reference external" href="#vib:model2x2:EulerCromer:elim1">56</a>) we get</p>
<!-- Equation labels as ordinary links -->
<div id="_auto22"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u^{n+1} = 2u^n - u^{n-1} - \Delta t^2 \omega^2u^{n},
\label{_auto22} \tag{57}
\end{equation}
\]</div>
<p>which is nothing but the centered scheme (<a class="reference external" href="#vib:ode1:step4">7</a>)!  The
two seemingly different numerical methods are mathematically
equivalent. Consequently, the previous analysis of
(<a class="reference external" href="#vib:ode1:step4">7</a>) also applies to the Euler-Cromer method. In
particular, the amplitude is constant, given that the stability
criterion is fulfilled, but there is always an angular frequency error
(<a class="reference external" href="#vib:ode1:tildeomega:series">19</a>). <a class="reference external" href="#vib:exer:EulerCromer:analysis">Exercise 18: Analysis of the Euler-Cromer scheme</a> gives guidance on how to derive the
exact discrete solution of the two equations in the Euler-Cromer
method.</p>
<p>Although the Euler-Cromer scheme and the method (<a class="reference external" href="#vib:ode1:step4">7</a>)
are equivalent, there could be differences in the way they handle the
initial conditions. Let us look into this topic.  The initial
condition <span class="math notranslate nohighlight">\(u^{\prime}=0\)</span> means <span class="math notranslate nohighlight">\(u^{\prime}=v=0\)</span>.  From
(<a class="reference external" href="#vib:model2x2:EulerCromer:veq1b">54</a>) we get</p>
<div class="math notranslate nohighlight">
\[
v^1=v^0-\Delta t\omega^2 u^0
=\Delta t\omega^2 u^0,
\]</div>
<p>and from (<a class="reference external" href="#vib:model2x2:EulerCromer:ueq1b">55</a>)
it follows that</p>
<div class="math notranslate nohighlight">
\[
u^1=u^0 + \Delta t v^1 = u^0 - \omega^2\Delta t^2 u^0\thinspace .
\]</div>
<p>When we previously used a centered approximation of <span class="math notranslate nohighlight">\(u^{\prime}(0)=0\)</span>
combined with the discretization (<a class="reference external" href="#vib:ode1:step4">7</a>) of the
second-order ODE, we got a slightly different result: <span class="math notranslate nohighlight">\(u^1=u^0 -
\frac{1}{2}\omega^2\Delta t^2 u^0\)</span>. The difference is
<span class="math notranslate nohighlight">\(\frac{1}{2}\omega^2\Delta t^2 u^0\)</span>, which is of second order in
<span class="math notranslate nohighlight">\(\Delta t\)</span>, seemingly consistent with the overall error in the scheme
for the differential equation model.</p>
<p>A different view can also be taken.  If we approximate
<span class="math notranslate nohighlight">\(u^{\prime}(0)=0\)</span> by a backward difference, <span class="math notranslate nohighlight">\((u^0-u^{-1})/\Delta t
=0\)</span>, we get <span class="math notranslate nohighlight">\(u^{-1}=u^0\)</span>, and when combined with
(<a class="reference external" href="#vib:ode1:step4">7</a>), it results in <span class="math notranslate nohighlight">\(u^1=u^0 - \omega^2\Delta t^2
u^0\)</span>. This means that the Euler-Cromer method based on
(<a class="reference external" href="#vib:model2x2:EulerCromer:ueq1b">55</a>)-(<a class="reference external" href="#vib:model2x2:EulerCromer:veq1b">54</a>)
corresponds to using only a first-order approximation to the initial
condition in the method from the section <a class="reference external" href="#vib:ode1:fdm">A centered finite difference scheme</a>.</p>
<p>Correspondingly, using the formulation
(<a class="reference external" href="#vib:model2x2:EulerCromer:ueq1">52</a>)-(<a class="reference external" href="#vib:model2x2:EulerCromer:veq1">53</a>)
with <span class="math notranslate nohighlight">\(v^n=0\)</span> leads to <span class="math notranslate nohighlight">\(u^1=u^0\)</span>, which can be interpreted as using a
forward difference approximation for the initial condition
<span class="math notranslate nohighlight">\(u^{\prime}(0)=0\)</span>.  Both Euler-Cromer formulations lead to slightly
different values for <span class="math notranslate nohighlight">\(u^1\)</span> compared to the method in the section <a class="reference external" href="#vib:ode1:fdm">A centered finite difference scheme</a>.  The error is <span class="math notranslate nohighlight">\(\frac{1}{2}\omega^2\Delta t^2 u^0\)</span>.</p>
</div>
<div class="section" id="id1">
<h2><span class="section-number">7.3. </span>Implementation<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<div id="vib:model2x2:EulerCromer:impl"></div>
<div class="section" id="solver-function">
<h3><span class="section-number">7.3.1. </span>Solver function<a class="headerlink" href="#solver-function" title="Permalink to this headline">¶</a></h3>
<p>The function below, found in <span class="xref myst"><code class="docutils literal notranslate"><span class="pre">vib_undamped_EulerCromer.py</span></code></span>, implements the Euler-Cromer scheme
(<a class="reference external" href="#vib:model2x2:EulerCromer:veq1b">54</a>)-(<a class="reference external" href="#vib:model2x2:EulerCromer:ueq1b">55</a>):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">devito</span> <span class="kn">import</span> <span class="n">Dimension</span><span class="p">,</span> <span class="n">TimeFunction</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">solve</span><span class="p">,</span> <span class="n">Operator</span><span class="p">,</span> <span class="n">Constant</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load -s solver, src-vib/vib_undamped_EulerCromer.py</span>
<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;=v, v&#39; = - w**2*u for t in (0,T], u(0)=I and v(0)=0,</span>
<span class="sd">    by an Euler-Cromer method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    
    <span class="n">t</span> <span class="o">=</span> <span class="n">Dimension</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="n">Constant</span><span class="p">(</span><span class="s1">&#39;h_t&#39;</span><span class="p">))</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">TimeFunction</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="p">(</span><span class="n">t</span><span class="p">,),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">,),</span> <span class="n">space_order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">TimeFunction</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="p">(</span><span class="n">t</span><span class="p">,),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">,),</span> <span class="n">space_order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">v</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>    
    <span class="n">u</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">I</span>

    <span class="n">eq_v</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">)</span>
    <span class="n">eq_u</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">forward</span><span class="p">)</span>
    
    <span class="n">stencil_v</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">eq_v</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">forward</span><span class="p">)</span>
    <span class="n">stencil_u</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">eq_u</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">forward</span><span class="p">)</span>
    
    <span class="n">update_v</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">forward</span><span class="p">,</span> <span class="n">stencil_v</span><span class="p">)</span>
    <span class="n">update_u</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">forward</span><span class="p">,</span> <span class="n">stencil_u</span><span class="p">)</span>
    

    <span class="n">op</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">([</span><span class="n">update_v</span><span class="p">,</span> <span class="n">update_u</span><span class="p">])</span>
    <span class="n">op</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">h_t</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">t_M</span><span class="o">=</span><span class="n">Nt</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">u</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can now compare the output from this function with the exact solution to the original second-order vibration ODE using our <code class="docutils literal notranslate"><span class="pre">visualize</span></code> function from before:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">I</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">w</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">num_periods</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>    <span class="c1">#  one period</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">num_periods</span>
<span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>

<span class="n">visualize</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Operator `Kernel` run in 0.01 s
</pre></div>
</div>
<img alt="../../_images/vib_undamped_293_1.png" src="../../_images/vib_undamped_293_1.png" />
</div>
</div>
</div>
<div class="section" id="id2">
<h3><span class="section-number">7.3.2. </span>Verification<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>Since the Euler-Cromer scheme is equivalent to the finite difference
method for the second-order ODE <span class="math notranslate nohighlight">\(u^{\prime\prime}+\omega^2u=0\)</span> (see the section <a class="reference external" href="#vib:model2x2:EulerCromer:equiv">Equivalence with the scheme for the second-order ODE</a>), the performance of the above
<code class="docutils literal notranslate"><span class="pre">solver</span></code> function is the same as for the <code class="docutils literal notranslate"><span class="pre">solver</span></code> function in the section <a class="reference external" href="#vib:impl1">Implementation</a>. The only difference is the formula for the first time
step, as discussed above.  This deviation in the Euler-Cromer scheme
means that the discrete solution listed in the section <a class="reference external" href="#vib:ode1:analysis:sol">Exact discrete solution</a> is not a solution of the Euler-Cromer
scheme!</p>
<p>To verify the implementation of the Euler-Cromer method we can adjust
<code class="docutils literal notranslate"><span class="pre">v[1]</span></code> so that the computer-generated values can be compared with the
formula (<a class="reference external" href="#vib:ode1:un:exact">20</a>) from in the section <a class="reference external" href="#vib:ode1:analysis:sol">Exact discrete solution</a>. This adjustment is done in an alternative
solver function, <code class="docutils literal notranslate"><span class="pre">solver_ic_fix</span></code> in <span class="xref myst"><code class="docutils literal notranslate"><span class="pre">vib_undamped_EulerCromer.py</span></code></span>. Since we now
have an exact solution of the discrete equations available, we can
write a test function <code class="docutils literal notranslate"><span class="pre">test_solver</span></code> for checking the equality of
computed values with the formula (<a class="reference external" href="#vib:ode1:un:exact">20</a>):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load -s test_solver, src-vib/vib_undamped_EulerCromer.py</span>
<span class="k">def</span> <span class="nf">test_solver</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test solver with fixed initial condition against</span>
<span class="sd">    equivalent scheme for the 2nd-order ODE u&#39;&#39; + u = 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">I</span> <span class="o">=</span> <span class="mf">1.2</span><span class="p">;</span> <span class="n">w</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span> <span class="n">T</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="n">w</span>  <span class="c1"># longest possible time step</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver_ic_fix</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">vib_undamped</span> <span class="kn">import</span> <span class="n">solver</span> <span class="k">as</span> <span class="n">solver2</span>  <span class="c1"># 2nd-order ODE</span>
    <span class="n">u2</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">solver2</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u2</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">assert</span> <span class="n">error</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
</div>
</div>
<p>Another function, <code class="docutils literal notranslate"><span class="pre">demo</span></code>, visualizes the difference between the
Euler-Cromer scheme and the scheme (<a class="reference external" href="#vib:ode1:step4">7</a>) for the
second-oder ODE, arising from the mismatch in the first time level.</p>
</div>
<div class="section" id="convergence-rates">
<h3><span class="section-number">7.3.3. </span>Convergence rates<a class="headerlink" href="#convergence-rates" title="Permalink to this headline">¶</a></h3>
<p>We may use the <code class="docutils literal notranslate"><span class="pre">convergence_rates</span></code> function in the file
<span class="xref myst"><code class="docutils literal notranslate"><span class="pre">vib_undamped.py</span></code></span> to investigate the convergence rate of the
Euler-Cromer method, see the <code class="docutils literal notranslate"><span class="pre">convergence_rate</span></code> function in the file
<span class="xref myst"><code class="docutils literal notranslate"><span class="pre">vib_undamped_EulerCromer.py</span></code></span>.  Since we could eliminate <span class="math notranslate nohighlight">\(v\)</span> to get a
scheme for <span class="math notranslate nohighlight">\(u\)</span> that is equivalent to the finite difference method for
the second-order equation in <span class="math notranslate nohighlight">\(u\)</span>, we would expect the convergence
rates to be the same, i.e., <span class="math notranslate nohighlight">\(r = 2\)</span>. However,
measuring the convergence rate of <span class="math notranslate nohighlight">\(u\)</span> in the Euler-Cromer scheme shows
that <span class="math notranslate nohighlight">\(r = 1\)</span> only!  Adjusting the initial condition
does not change the rate. Adjusting <span class="math notranslate nohighlight">\(\omega\)</span>, as outlined in the section <a class="reference external" href="#vib:ode1:analysis:numfreq">The error in the numerical frequency</a>, gives a 4th-order method there, while
there is no increase in the measured rate in the Euler-Cromer
scheme. It is obvious that the Euler-Cromer scheme is dramatically
much better than the two other first-order methods, Forward Euler and
Backward Euler, but this is not reflected in the convergence rate of
<span class="math notranslate nohighlight">\(u\)</span>.</p>
<!-- is anything really gained? is v of higher order compared -->
<!-- with differentiating u in the 2nd order ODE? most likely, -->
<!-- v is 2nd order, v from 2nd-order ODE is 1st order -->
</div>
</div>
<div class="section" id="the-stoermer-verlet-algorithm">
<h2><span class="section-number">7.4. </span>The Stoermer-Verlet algorithm<a class="headerlink" href="#the-stoermer-verlet-algorithm" title="Permalink to this headline">¶</a></h2>
<div id="vib:model2x2:StormerVerlet"></div>
<!-- See velverlet_EulerCromer_....pdf for discussion and relation to EC -->
<p>Another very popular algorithm for vibration problems, especially
for long time simulations, is the
Stoermer-Verlet
algorithm. It has become <em>the</em> method among physicists
for molecular simulations as well as particle and rigid body dynamics.</p>
<p>The method can be derived by applying the Euler-Cromer idea
twice, in a symmetric fashion, during the interval <span class="math notranslate nohighlight">\([t_n,t_{n+1}]\)</span>:</p>
<ol class="simple">
<li><p>solve <span class="math notranslate nohighlight">\(v^{\prime}=-\omega u\)</span> by a Forward Euler step in <span class="math notranslate nohighlight">\([t_n,t_{n+\frac{1}{2}}]\)</span></p></li>
<li><p>solve <span class="math notranslate nohighlight">\(u^{\prime}=v\)</span> by a Backward Euler step in <span class="math notranslate nohighlight">\([t_n,t_{n+\frac{1}{2}}]\)</span></p></li>
<li><p>solve <span class="math notranslate nohighlight">\(u^{\prime}=v\)</span> by a Forward Euler step in <span class="math notranslate nohighlight">\([t_{n+\frac{1}{2}}, t_{n+1}]\)</span></p></li>
<li><p>solve <span class="math notranslate nohighlight">\(v^{\prime}=-\omega u\)</span> by a Backward Euler step in <span class="math notranslate nohighlight">\([t_{n+\frac{1}{2}}, t_{n+1}]\)</span></p></li>
</ol>
<p>With mathematics,</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
\frac{v^{n+\frac{1}{2}}-v^n}{\frac{1}{2}\Delta t} &amp;= -\omega^2 u^n,\\ 
\frac{u^{n+\frac{1}{2}}-u^n}{\frac{1}{2}\Delta t} &amp;= v^{n+\frac{1}{2}},\\ 
\frac{u^{n+1}-u^{n+\frac{1}{2}}}{\frac{1}{2}\Delta t} &amp;= v^{n+\frac{1}{2}},\\ 
\frac{v^{n+1}-v^{n+\frac{1}{2}}}{\frac{1}{2}\Delta t} &amp;= -\omega^2 u^{n+1}\thinspace .
\end{align*}
\end{split}\]</div>
<p>The two steps in the middle can be combined to</p>
<div class="math notranslate nohighlight">
\[
\frac{u^{n+1}-u^{n}}{\Delta t} = v^{n+\frac{1}{2}},
\]</div>
<p>and consequently</p>
<!-- Equation labels as ordinary links -->
<div id="_auto23"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
v^{n+\frac{1}{2}} = v^n - \frac{1}{2}\Delta t \omega^2 u^n,
\label{_auto23} \tag{58}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto24"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
u^{n+1} = u^{n} + \Delta t v^{n+\frac{1}{2}},
\label{_auto24} \tag{59}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto25"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
v^{n+1} = v^{n+\frac{1}{2}} - \frac{1}{2}\Delta t \omega^2 u^{n+1}\thinspace .
\label{_auto25} \tag{60}
\end{equation}
\]</div>
<p>Writing the last equation as <span class="math notranslate nohighlight">\(v^n = v^{n-\frac{1}{2}} - \frac{1}{2}\Delta
t\omega^2 u^n\)</span> and using this <span class="math notranslate nohighlight">\(v^n\)</span> in the first equation gives
<span class="math notranslate nohighlight">\(v^{n+\frac{1}{2}} = v^{n-\frac{1}{2}} - \Delta t\omega^2 u^n\)</span>, and the scheme can
be written as two steps:</p>
<!-- Equation labels as ordinary links -->
<div id="vib:model2x2:StormerVerlet:eqv"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
v^{n+\frac{1}{2}} = v^{n-\frac{1}{2}} - \Delta t \omega^2 u^n,
\label{vib:model2x2:StormerVerlet:eqv} \tag{61}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="vib:model2x2:StormerVerlet:equ"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
u^{n+1} = u^{n} + \Delta t v^{n+\frac{1}{2}},
\label{vib:model2x2:StormerVerlet:equ} \tag{62}
\end{equation}
\]</div>
<p>which is nothing but straightforward centered differences for the
<span class="math notranslate nohighlight">\(2\times 2\)</span> ODE system on a <em>staggered mesh</em>, see
the section <a class="reference external" href="#vib:model2x2:staggered">The Euler-Cromer scheme on a staggered mesh</a>. We have thus seen that
four different reasonings (discretizing <span class="math notranslate nohighlight">\(u^{\prime\prime}+\omega^2 u\)</span>
directly, using Euler-Cromer, using
Stoermer-Verlet,
and using centered differences for the <span class="math notranslate nohighlight">\(2\times 2\)</span> system on a staggered
mesh) all end up with the same equations! The main difference is that
the traditional Euler-Cromer displays first-order convergence in <span class="math notranslate nohighlight">\(\Delta t\)</span>
(due to less symmetry in the way <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> are treated)
while the others are <span class="math notranslate nohighlight">\(\mathcal{O}{\Delta t^2}\)</span> schemes.</p>
<p>The most numerically stable scheme, with respect to accumulation of
rounding errors, is
(<a class="reference external" href="#vib:model2x2:StormerVerlet:eqv">61</a>)-(<a class="reference external" href="#vib:model2x2:StormerVerlet:equ">62</a>).
It has, according to <a class="reference external" href="#Hairer_Wanner_Norsett_bookI">[Hairer_Wanner_Norsett_bookI]</a>, better
properties in this regard than the direct scheme for the second-order
ODE.</p>
</div>
</div>
<div class="section" id="staggered-mesh">
<h1><span class="section-number">8. </span>Staggered mesh<a class="headerlink" href="#staggered-mesh" title="Permalink to this headline">¶</a></h1>
<p>A more intuitive discretization than the Euler-Cromer method, yet
equivalent, employs solely centered differences in a natural way
for the <span class="math notranslate nohighlight">\(2\times 2\)</span> first-order ODE system.
The scheme is in fact fully equivalent to the second-order scheme for
<span class="math notranslate nohighlight">\(u''+\omega u=0\)</span>, also for the first time step.
Such a scheme needs to operate on a <em>staggered mesh</em> in time.
Staggered meshes are very popular in many physical application, maybe foremost
fluid dynamics and electromagnetics, so the topic is important to learn.</p>
<div class="section" id="the-euler-cromer-scheme-on-a-staggered-mesh">
<h2><span class="section-number">8.1. </span>The Euler-Cromer scheme on a staggered mesh<a class="headerlink" href="#the-euler-cromer-scheme-on-a-staggered-mesh" title="Permalink to this headline">¶</a></h2>
<div id="vib:model2x2:staggered"></div>
<p>In a staggered mesh, the unknowns are sought at different points in
the mesh. Specifically, <span class="math notranslate nohighlight">\(u\)</span> is sought at
integer time points <span class="math notranslate nohighlight">\(t_n\)</span> and <span class="math notranslate nohighlight">\(v\)</span> is sought at <span class="math notranslate nohighlight">\(t_{n+1/2}\)</span>
<em>between</em> two <span class="math notranslate nohighlight">\(u\)</span> points.
The unknowns are then <span class="math notranslate nohighlight">\(u^1, v^{3/2}, u^2, v^{5/2}\)</span>, and so on.
We typically use the notation
<span class="math notranslate nohighlight">\(u^n\)</span> and <span class="math notranslate nohighlight">\(v^{n+\frac{1}{2}}\)</span> for the two unknown mesh functions.
<a class="reference external" href="#staggered:EC:fig1">Figure</a> presents a graphical sketch of two
mesh functions <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> on a staggered mesh.</p>
<!-- dom:FIGURE: [fig-vib/staggered_time.png, width=500 frac=0.8] Examples on mesh functions on a staggered mesh in time. <div id="staggered:EC:fig1"></div> -->
<!-- begin figure -->
<div id="staggered:EC:fig1"></div>
<p>Examples on mesh functions on a staggered mesh in time.</p>
<img src="fig-vib/staggered_time.png" width=500>
<!-- end figure -->
<p>On a staggered mesh it is natural to
use centered difference approximations, expressed
in operator notation as</p>
<!-- Equation labels as ordinary links -->
<div id="_auto26"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\lbrack D_t u = v\rbrack^{n+\frac{1}{2}},
\label{_auto26} \tag{63}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto27"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
\lbrack D_t v = -\omega^2 u\rbrack^{n+1}
\thinspace .
\label{_auto27} \tag{64}
\end{equation}
\]</div>
<p>or if we switch the sequence of the equations:</p>
<!-- Equation labels as ordinary links -->
<div id="_auto28"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\lbrack D_t v = -\omega^2 u\rbrack^{n},
\label{_auto28} \tag{65}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto29"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
\lbrack D_t u = v\rbrack^{n+\frac{1}{2}}
\thinspace .
\label{_auto29} \tag{66}
\end{equation}
\]</div>
<p>Writing out the formulas gives</p>
<!-- Equation labels as ordinary links -->
<div id="vib:model2x2:EulerCromer:veq1s2"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
v^{n+\frac{1}{2}} = v^{n-\frac{1}{2}} -\Delta t \omega^2u^{n}
\label{vib:model2x2:EulerCromer:veq1s2} \tag{67},
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="vib:model2x2:EulerCromer:ueq1s2"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
u^{n+1} = u^{n} + \Delta t v^{n+\frac{1}{2}}
\label{vib:model2x2:EulerCromer:ueq1s2} \tag{68}
\thinspace .
\end{equation}
\]</div>
<!-- We shall use the names -->
<!-- *forward-backward Euler-Cromer* and *staggered Euler-Cromer* -->
<!-- to distinguish the two schemes. -->
<p>We can eliminate the <span class="math notranslate nohighlight">\(v\)</span>
values and get back the centered scheme based on the second-order
differential equation <span class="math notranslate nohighlight">\(u^{\prime\prime} +\omega^2 u = 0\)</span>,
so all these three schemes are equivalent.
However, they differ somewhat in the treatment of the initial
conditions.</p>
<p>Suppose we have <span class="math notranslate nohighlight">\(u(0)=I\)</span> and <span class="math notranslate nohighlight">\(u'(0)=v(0)=0\)</span> as mathematical
initial conditions. This means <span class="math notranslate nohighlight">\(u^0=I\)</span> and</p>
<div class="math notranslate nohighlight">
\[
v(0)\approx \frac{1}{2}(v^{-\frac{1}{2}} + v^{\frac{1}{2}}) = 0,
\quad\Rightarrow\quad v^{-\frac{1}{2}} =- v^\frac{1}{2}\thinspace .
\]</div>
<p>Using the discretized equation (<a class="reference external" href="#vib:model2x2:EulerCromer:veq1s2">67</a>) for
<span class="math notranslate nohighlight">\(n=0\)</span> yields</p>
<div class="math notranslate nohighlight">
\[
v^\frac{1}{2} = v^{-\frac{1}{2}} -\Delta t\omega^2 I,
\]</div>
<p>and eliminating <span class="math notranslate nohighlight">\(v^{-\frac{1}{2}} =- v^{\frac{1}{2}}\)</span>
results in</p>
<div class="math notranslate nohighlight">
\[
v^\frac{1}{2} = -\frac{1}{2}\Delta t\omega^2I,
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
u^1 = u^0 - \frac{1}{2}\Delta t^2\omega^2 I,
\]</div>
<p>which is exactly the same equation for <span class="math notranslate nohighlight">\(u^1\)</span> as we had in the
centered scheme based on the second-order differential equation
(and hence corresponds to a centered difference approximation of
the initial condition for <span class="math notranslate nohighlight">\(u'(0)\)</span>).
The conclusion is that a staggered mesh is fully equivalent with
that scheme, while the forward-backward version gives a slight
deviation in the computation of <span class="math notranslate nohighlight">\(u^1\)</span>.</p>
<p>We can redo the derivation of the initial conditions when <span class="math notranslate nohighlight">\(u'(0)=V\)</span>:</p>
<div class="math notranslate nohighlight">
\[
v(0)\approx \frac{1}{2}(v^{-\frac{1}{2}} + v^{\frac{1}{2}}) = V,
\quad\Rightarrow\quad v^{-\frac{1}{2}} = 2V - v^\frac{1}{2}\thinspace .
\]</div>
<p>Using this <span class="math notranslate nohighlight">\(v^{-\frac{1}{2}}\)</span> in</p>
<div class="math notranslate nohighlight">
\[
v^\frac{1}{2} = v^{-\frac{1}{2}} -\Delta t\omega^2 I,
\]</div>
<p>then gives <span class="math notranslate nohighlight">\(v^\frac{1}{2} = V - \frac{1}{2}\Delta t\omega^2 I\)</span>.
The general initial conditions are therefore</p>
<!-- Equation labels as ordinary links -->
<div id="vib:ode2:staggered:u0"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u^0 = I,
\label{vib:ode2:staggered:u0} \tag{69}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="vib:ode2:staggered:v0"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
v^\frac{1}{2} = V - \frac{1}{2}\Delta t\omega^2I
\label{vib:ode2:staggered:v0} \tag{70}\thinspace .
\end{equation}
\]</div>
</div>
<div class="section" id="implementation-of-the-scheme-on-a-staggered-mesh">
<h2><span class="section-number">8.2. </span>Implementation of the scheme on a staggered mesh<a class="headerlink" href="#implementation-of-the-scheme-on-a-staggered-mesh" title="Permalink to this headline">¶</a></h2>
<p>The algorithm goes like this:</p>
<ol class="simple">
<li><p>Set the initial values (<a class="reference external" href="#vib:ode2:staggered:u0">69</a>) and
(<a class="reference external" href="#vib:ode2:staggered:v0">70</a>).</p></li>
<li><p>For <span class="math notranslate nohighlight">\(n=1,2,\ldots\)</span>:</p></li>
</ol>
<p>a. Compute <span class="math notranslate nohighlight">\(u^{n}\)</span> from (<a class="reference external" href="#vib:model2x2:EulerCromer:ueq1s2">68</a>).</p>
<p>b. Compute <span class="math notranslate nohighlight">\(v^{n+\frac{1}{2}}\)</span> from (<a class="reference external" href="#vib:model2x2:EulerCromer:veq1s2">67</a>).</p>
<div class="section" id="implementation-with-integer-indices">
<h3><span class="section-number">8.2.1. </span>Implementation with integer indices<a class="headerlink" href="#implementation-with-integer-indices" title="Permalink to this headline">¶</a></h3>
<p>Translating the schemes (<a class="reference external" href="#vib:model2x2:EulerCromer:ueq1s2">68</a>)
and (<a class="reference external" href="#vib:model2x2:EulerCromer:veq1s2">67</a>) to computer code
faces the problem of how to store and access <span class="math notranslate nohighlight">\(v^{n+\frac{1}{2}}\)</span>,
since arrays only allow integer indices with base 0.
We must then introduce a convention: <span class="math notranslate nohighlight">\(v^{1+\frac{1}{2}}\)</span> is stored
in <code class="docutils literal notranslate"><span class="pre">v[n]</span></code> while <span class="math notranslate nohighlight">\(v^{1-\frac{1}{2}}\)</span> is stored in <code class="docutils literal notranslate"><span class="pre">v[n-1]</span></code>.
We can then write the algorithm in Python as</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %load -s solver_v1, src-vib/vib_undamped_staggered.py</span>
<span class="k">def</span> <span class="nf">solver_v1</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;=v, v&#39; = - w**2*u for t in (0,T], u(0)=I and v(0)=0,</span>
<span class="sd">    by a central finite difference method with time step dt.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    
    <span class="n">t</span> <span class="o">=</span> <span class="n">Dimension</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="n">Constant</span><span class="p">(</span><span class="s1">&#39;h_t&#39;</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">TimeFunction</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="p">(</span><span class="n">t</span><span class="p">,),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">,),</span> <span class="n">space_order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">TimeFunction</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="p">(</span><span class="n">t</span><span class="p">,),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">,),</span> <span class="n">space_order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">u</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">v</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span>
    
    <span class="n">eq_u</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">eq_v</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">forward</span><span class="p">)</span>
    
    <span class="n">stencil_u</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">eq_u</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">forward</span><span class="p">)</span>
    <span class="n">stencil_v</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">eq_v</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">forward</span><span class="p">)</span>
    
    <span class="n">update_u</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">forward</span><span class="p">,</span> <span class="n">stencil_u</span><span class="p">)</span>
    <span class="n">update_v</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">forward</span><span class="p">,</span> <span class="n">stencil_v</span><span class="p">)</span>
    
    <span class="n">op</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">([</span><span class="n">update_u</span><span class="p">,</span> <span class="n">update_v</span><span class="p">])</span>
    <span class="n">op</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">h_t</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">t_M</span><span class="o">=</span><span class="n">Nt</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">t_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>    <span class="c1"># mesh for u</span>
    <span class="n">t_v_mesh</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_mesh</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>         <span class="c1"># mesh for v</span>

    <span class="k">return</span> <span class="n">u</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">t_mesh</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">t_v_mesh</span>
</pre></div>
</div>
</div>
</div>
<p>Note that <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> are returned together with the mesh points such
that the complete mesh function for <span class="math notranslate nohighlight">\(u\)</span> is described by <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">t_mesh</span></code>,
while <code class="docutils literal notranslate"><span class="pre">v</span></code> and <code class="docutils literal notranslate"><span class="pre">t_v_mesh</span></code> represent the mesh function for <span class="math notranslate nohighlight">\(v\)</span>.</p>
<p>Once again, we can compare with the exact solution using the <code class="docutils literal notranslate"><span class="pre">visualize</span></code> function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">I</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">w</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">num_periods</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>    <span class="c1">#  one period</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">num_periods</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t_v</span> <span class="o">=</span> <span class="n">solver_v1</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>

<span class="n">visualize</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Operator `Kernel` run in 0.01 s
</pre></div>
</div>
<img alt="../../_images/vib_undamped_335_1.png" src="../../_images/vib_undamped_335_1.png" />
</div>
</div>
<p>Verification of this code is easy as we can just compare the computed
<code class="docutils literal notranslate"><span class="pre">u</span></code> with the <code class="docutils literal notranslate"><span class="pre">u</span></code> produced by the <code class="docutils literal notranslate"><span class="pre">solver</span></code> function in
<code class="docutils literal notranslate"><span class="pre">vib_undamped.py</span></code> (which solves <span class="math notranslate nohighlight">\(u''+\omega^2u=0\)</span> directly).  The
values should coincide to machine precision since the two numerical
methods are mathematically equivalent.  We refer to the file
<span class="xref myst"><code class="docutils literal notranslate"><span class="pre">vib_undamped_staggered.py</span></code></span>
for the details of a unit test (<code class="docutils literal notranslate"><span class="pre">test_staggered</span></code>) that checks this property.</p>
</div>
</div>
</div>
<div class="section" id="exercises-and-problems">
<h1><span class="section-number">9. </span>Exercises and Problems<a class="headerlink" href="#exercises-and-problems" title="Permalink to this headline">¶</a></h1>
<!-- --- begin exercise --- -->
<div class="section" id="problem-1-use-linear-quadratic-functions-for-verification">
<h2><span class="section-number">9.1. </span>Problem 1: Use linear/quadratic functions for verification<a class="headerlink" href="#problem-1-use-linear-quadratic-functions-for-verification" title="Permalink to this headline">¶</a></h2>
<div id="vib:exer:undamped:verify:linquad"></div>
<p>Consider the ODE problem</p>
<div class="math notranslate nohighlight">
\[
u^{\prime\prime} + \omega^2u=f(t), \quad u(0)=I,\ u^{\prime}(0)=V,\ t\in(0,T]\thinspace .
\]</div>
<p><strong>a)</strong>
Discretize this equation according to <span class="math notranslate nohighlight">\([D_tD_t u + \omega^2 u = f]^n\)</span> and
derive the equation for the first time step (<span class="math notranslate nohighlight">\(u^1\)</span>).</p>
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong>
For the requested discretization, we get</p>
<div class="math notranslate nohighlight">
\[
\frac{u^{n+1} - 2u^n + u^{n-1}}{\Delta t^2} + \omega^2u^n = f^n\thinspace .
\]</div>
<p>To derive the equation for <span class="math notranslate nohighlight">\(u^1\)</span>, we first find the expression for <span class="math notranslate nohighlight">\(u^{n+1}\)</span> from the
discretized form of the equation. Isolating <span class="math notranslate nohighlight">\(u^{n+1}\)</span>, we get</p>
<div class="math notranslate nohighlight">
\[
u^{n+1} = \left(2 - (\Delta t\omega)^2\right)u^n - u^{n-1} + \Delta t^2 f^n\thinspace .
\]</div>
<p>With <span class="math notranslate nohighlight">\(n = 0\)</span>, this expression gives</p>
<div class="math notranslate nohighlight">
\[
u^1 = \left(2 - (\Delta t\omega)^2\right)u^0 - u^{-1} + \Delta t^2 f^n\thinspace .
\]</div>
<p>Here, however, we get a problem with <span class="math notranslate nohighlight">\(u^{-1}\)</span>, which appears on the right hand side.
To get around that problem, we realize that the initial condition <span class="math notranslate nohighlight">\(u^{\prime} = V\)</span> might
be approximated by use of a centered difference approximation as</p>
<div class="math notranslate nohighlight">
\[
\frac{u^1 - u^{-1}}{2\Delta t} = V,
\]</div>
<p>which means that</p>
<div class="math notranslate nohighlight">
\[
u^{-1} = u^1 - 2\Delta t V\thinspace .
\]</div>
<p>Inserting this expression for <span class="math notranslate nohighlight">\(u^{-1}\)</span> into the expression for <span class="math notranslate nohighlight">\(u^1\)</span>, we get</p>
<div class="math notranslate nohighlight">
\[
u^1 = \left(2 - (\Delta t\omega)^2\right)u^0 - (u^1 - 2\Delta t V) + \Delta t^2 f^n\thinspace .
\]</div>
<p>Finally, after isolating <span class="math notranslate nohighlight">\(u^1\)</span> on the left hand side, we arrive at
[ u^1 = \left(1 - \frac{1}{2}(\Delta t\omega)^2\right)u^0 + \Delta t V + \frac{1}{2}\Delta t^2 f^n\thinspace .]</p>
<!-- --- end solution of exercise --- -->
<p><strong>b)</strong>
For verification purposes, we use the method of manufactured solutions (MMS) with the
choice of <span class="math notranslate nohighlight">\(\uex(t)= ct+d\)</span>. Find restrictions on <span class="math notranslate nohighlight">\(c\)</span> and <span class="math notranslate nohighlight">\(d\)</span> from
the initial conditions. Compute the corresponding source term <span class="math notranslate nohighlight">\(f\)</span>.
Show that <span class="math notranslate nohighlight">\([D_tD_t t]^n=0\)</span> and use the fact
that the <span class="math notranslate nohighlight">\(D_tD_t\)</span> operator is linear,
<span class="math notranslate nohighlight">\([D_tD_t (ct+d)]^n = c[D_tD_t t]^n + [D_tD_t d]^n = 0\)</span>, to show that
<span class="math notranslate nohighlight">\(\uex\)</span> is also a perfect solution of the discrete equations.</p>
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong>
The initial conditions <span class="math notranslate nohighlight">\(u(0)=I\)</span> and <span class="math notranslate nohighlight">\(u^{\prime}(0)=V\)</span> give demands
<span class="math notranslate nohighlight">\(\uex(0)=I\)</span> and <span class="math notranslate nohighlight">\(\uex^{\prime}(0)=V\)</span>, which imply that
<span class="math notranslate nohighlight">\(d = I\)</span> and {c = V}.</p>
<p>To compute the source term <span class="math notranslate nohighlight">\(f\)</span>, we insert the chosen solution <span class="math notranslate nohighlight">\(\uex\)</span> into
the ODE. This gives</p>
<div class="math notranslate nohighlight">
\[
0 + \omega^2(ct+d)=f(t),
\]</div>
<p>which implies that</p>
<div class="math notranslate nohighlight">
\[
f(t)=\omega^2(Vt+I)\thinspace .
\]</div>
<p>To show that <span class="math notranslate nohighlight">\([D_tD_t t]^n=0\)</span>, we proceed as</p>
<div class="math notranslate nohighlight">
\[
[D_tD_t t]^n = \frac{t^{n+1} - 2t^n + t^{n-1}}{\Delta t^2}, \nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
= \frac{(n+1)\Delta t - 2n\Delta t + (n-1)\Delta t}{\Delta t^2}, \nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
= \frac{n\Delta t + \Delta t - 2n\Delta t + n\Delta t - \Delta t}{\Delta t^2}, \nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
= 0\thinspace . \nonumber
\]</div>
<p>Finally, we show that the chosen <span class="math notranslate nohighlight">\(\uex\)</span> is also a perfect solution of the discrete equations.
If we start by inserting <span class="math notranslate nohighlight">\(\uex\)</span> into</p>
<div class="math notranslate nohighlight">
\[
[D_tD_t u + \omega^2u = f]^n,
\]</div>
<p>as well as the expression found for <span class="math notranslate nohighlight">\(f\)</span>.
We get</p>
<div class="math notranslate nohighlight">
\[
[D_tD_t (Vt+I) + \omega^2(Vt+I) = \omega^2(Vt+I)]^n,
\]</div>
<p>which can be rewritten as</p>
<div class="math notranslate nohighlight">
\[
[D_tD_t (Vt+I)]^n + [\omega^2(Vt+I)]^n = [\omega^2(Vt+I)]^n\thinspace .
\]</div>
<p>Now, since the first term here is zero, we see that the discrete equation is
fulfilled exactly for the chosen <span class="math notranslate nohighlight">\(\uex\)</span> function.</p>
<!-- --- end solution of exercise --- -->
<p><strong>c)</strong>
Use <code class="docutils literal notranslate"><span class="pre">sympy</span></code> to do the symbolic calculations above. Here is a
sketch of the program <code class="docutils literal notranslate"><span class="pre">vib_undamped_verify_mms.py</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="nn">sym</span>
<span class="n">V</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;V t I w dt&#39;</span><span class="p">)</span>  <span class="c1"># global symbols</span>
<span class="n">f</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># global variable for the source term in the ODE</span>

<span class="k">def</span> <span class="nf">ode_source_term</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the terms in the ODE that the source term</span>
<span class="sd">    must balance, here u&#39;&#39; + w**2*u.</span>
<span class="sd">    u is symbolic Python function of t.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">residual_discrete_eq</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the residual of the discrete eq. with u inserted.&quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">return</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">residual_discrete_eq_step1</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the residual of the discrete eq. at the first</span>
<span class="sd">    step with u inserted.&quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">return</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DtDt</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return 2nd-order finite difference for u_tt.</span>
<span class="sd">    u is a symbolic Python function of t.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given some chosen solution u (as a function of t, implemented</span>
<span class="sd">    as a Python function), use the method of manufactured solutions</span>
<span class="sd">    to compute the source term f, and check if u also solves</span>
<span class="sd">    the discrete equations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span> <span class="s1">&#39;=== Testing exact solution: </span><span class="si">%s</span><span class="s1"> ===&#39;</span> <span class="o">%</span> <span class="n">u</span>
    <span class="nb">print</span> <span class="s2">&quot;Initial conditions u(0)=</span><span class="si">%s</span><span class="s2">, u&#39;(0)=</span><span class="si">%s</span><span class="s2">:&quot;</span> <span class="o">%</span> \
          <span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c1"># Method of manufactured solution requires fitting f</span>
    <span class="k">global</span> <span class="n">f</span>  <span class="c1"># source term in the ODE</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">ode_lhs</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>

    <span class="c1"># Residual in discrete equations (should be 0)</span>
    <span class="nb">print</span> <span class="s1">&#39;residual step1:&#39;</span><span class="p">,</span> <span class="n">residual_discrete_eq_step1</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="nb">print</span> <span class="s1">&#39;residual:&#39;</span><span class="p">,</span> <span class="n">residual_discrete_eq</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">linear</span><span class="p">():</span>
    <span class="n">main</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">V</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">I</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">linear</span><span class="p">()</span>
</pre></div>
</div>
<p>Fill in the various functions such that the calls in the <code class="docutils literal notranslate"><span class="pre">main</span></code>
function works.</p>
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong>
This part of the code goes as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="nn">sym</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">V</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;V t I w dt&#39;</span><span class="p">)</span>  <span class="c1"># global symbols</span>
<span class="n">f</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># global variable for the source term in the ODE</span>

<span class="k">def</span> <span class="nf">ode_source_term</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the terms in the ODE that the source term</span>
<span class="sd">    must balance, here u&#39;&#39; + w**2*u.</span>
<span class="sd">    u is symbolic Python function of t.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">residual_discrete_eq</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the residual of the discrete eq. with u inserted.&quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">DtDt</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span>
    <span class="k">return</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">residual_discrete_eq_step1</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the residual of the discrete eq. at the first</span>
<span class="sd">    step with u inserted.&quot;&quot;&quot;</span>
    <span class="n">half</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">dt</span><span class="p">)</span> <span class="o">-</span> <span class="n">I</span> <span class="o">-</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span> <span class="o">-</span> \
        <span class="n">half</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">half</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># t=0 in the rhs of the first step eq.</span>
    <span class="k">return</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DtDt</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return 2nd-order finite difference for u_tt.</span>
<span class="sd">    u is a symbolic Python function of t.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">dt</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">dt</span><span class="p">))</span><span class="o">/</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given some chosen solution u (as a function of t, implemented</span>
<span class="sd">    as a Python function), use the method of manufactured solutions</span>
<span class="sd">    to compute the source term f, and check if u also solves</span>
<span class="sd">    the discrete equations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span> <span class="s1">&#39;=== Testing exact solution: </span><span class="si">%s</span><span class="s1"> ===&#39;</span> <span class="o">%</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="nb">print</span> <span class="s2">&quot;Initial conditions u(0)=</span><span class="si">%s</span><span class="s2">, u&#39;(0)=</span><span class="si">%s</span><span class="s2">:&quot;</span> <span class="o">%</span> \
          <span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c1"># Method of manufactured solution requires fitting f</span>
    <span class="k">global</span> <span class="n">f</span>  <span class="c1"># source term in the ODE</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">ode_source_term</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>

    <span class="c1"># Residual in discrete equations (should be 0)</span>
    <span class="nb">print</span> <span class="s1">&#39;residual step1:&#39;</span><span class="p">,</span> <span class="n">residual_discrete_eq_step1</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="nb">print</span> <span class="s1">&#39;residual:&#39;</span><span class="p">,</span> <span class="n">residual_discrete_eq</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<!-- --- end solution of exercise --- -->
<p><strong>d)</strong>
The purpose now is to choose a quadratic function
<span class="math notranslate nohighlight">\(\uex = bt^2 + ct + d\)</span> as exact solution. Extend the <code class="docutils literal notranslate"><span class="pre">sympy</span></code>
code above with a function <code class="docutils literal notranslate"><span class="pre">quadratic</span></code> for fitting <code class="docutils literal notranslate"><span class="pre">f</span></code> and checking
if the discrete equations are fulfilled. (The function is very similar
to <code class="docutils literal notranslate"><span class="pre">linear</span></code>.)</p>
<!-- Check with hand calculations that the `sympy` implementation -->
<!-- is correct. -->
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong>
Yes, a quadratic function will fulfill the discrete equations exactly.
The implementation becomes</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">quadratic</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Test quadratic function q*t**2 + V*t + I.&quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;q&#39;</span><span class="p">)</span>  <span class="c1"># arbitrary constant in t**2 term</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">q</span><span class="o">*</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">V</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">I</span>
    <span class="n">main</span><span class="p">(</span><span class="n">u_e</span><span class="p">)</span>
</pre></div>
</div>
<p>Calling <code class="docutils literal notranslate"><span class="pre">quadratic()</span></code> shows that the residual vanishes, and the quadratic
function is an exact solution of the discrete equations.</p>
<!-- --- end solution of exercise --- -->
<p><strong>e)</strong>
Will a polynomial of degree three fulfill the discrete equations?</p>
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong>
We can easily make a test:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cubic</span><span class="p">():</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;r q&#39;</span><span class="p">)</span>
    <span class="n">main</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">r</span><span class="o">*</span><span class="n">t</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">q</span><span class="o">*</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">V</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">I</span><span class="p">)</span>
</pre></div>
</div>
<p>When running the final code presented below, the printout shows that the
step1 residual for the cubic function is not zero.</p>
<!-- --- end solution of exercise --- -->
<p><strong>f)</strong>
Implement a <code class="docutils literal notranslate"><span class="pre">solver</span></code> function for computing the numerical
solution of this problem.</p>
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong>
The <code class="docutils literal notranslate"><span class="pre">solver</span></code> function may take the form</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># NBVAL_SKIP</span>
<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;&#39; + w**2*u = f for t in (0,T], u(0)=I and u&#39;(0)=V,</span>
<span class="sd">    by a central finite difference method with time step dt.</span>
<span class="sd">    f(t) is a callable Python function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
</div>
</div>
<p>We can verify the implementation by the following test function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_quadratic_exact_solution</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Verify solver function via quadratic solution.&quot;&quot;&quot;</span>
    <span class="c1"># Transform global symbolic variables to functions and numbers</span>
    <span class="c1"># for numerical computations</span>
    <span class="k">global</span> <span class="n">p</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="mf">2.3</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.5</span>
    <span class="k">global</span> <span class="n">f</span><span class="p">,</span> <span class="n">t</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">p</span><span class="o">*</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">V</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">I</span> <span class="c1"># use p, V, I, w as numbers</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">ode_source_term</span><span class="p">(</span><span class="n">u_e</span><span class="p">)</span>         <span class="c1"># fit source term</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>           <span class="c1"># make function numerical</span>

    <span class="n">dt</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">/</span><span class="n">w</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="o">=</span><span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_e</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-12</span>
    <span class="k">assert</span> <span class="n">error</span> <span class="o">&lt;</span> <span class="n">tol</span>
    <span class="nb">print</span> <span class="s1">&#39;Error in computing a quadratic solution:&#39;</span><span class="p">,</span> <span class="n">error</span>
</pre></div>
</div>
<!-- --- end solution of exercise --- -->
<p><strong>g)</strong>
Write a test function for checking that the quadratic solution
is computed correctly (to machine precision, but the
round-off errors accumulate and increase with <span class="math notranslate nohighlight">\(T\)</span>) by the <code class="docutils literal notranslate"><span class="pre">solver</span></code>
function.</p>
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong>
Here is the complete code for this exercise:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="nn">sym</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">V</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;V t I w dt&#39;</span><span class="p">)</span>  <span class="c1"># global symbols</span>
<span class="n">f</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># global variable for the source term in the ODE</span>

<span class="k">def</span> <span class="nf">ode_source_term</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the terms in the ODE that the source term</span>
<span class="sd">    must balance, here u&#39;&#39; + w**2*u.</span>
<span class="sd">    u is symbolic Python function of t.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">residual_discrete_eq</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the residual of the discrete eq. with u inserted.&quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">DtDt</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span>
    <span class="k">return</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">residual_discrete_eq_step1</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the residual of the discrete eq. at the first</span>
<span class="sd">    step with u inserted.&quot;&quot;&quot;</span>
    <span class="n">half</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">dt</span><span class="p">)</span> <span class="o">-</span> <span class="n">I</span> <span class="o">-</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span> <span class="o">-</span> \
        <span class="n">half</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">half</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># t=0 in the rhs of the first step eq.</span>
    <span class="k">return</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DtDt</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return 2nd-order finite difference for u_tt.</span>
<span class="sd">    u is a symbolic Python function of t.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">dt</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">dt</span><span class="p">))</span><span class="o">/</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given some chosen solution u (as a function of t, implemented</span>
<span class="sd">    as a Python function), use the method of manufactured solutions</span>
<span class="sd">    to compute the source term f, and check if u also solves</span>
<span class="sd">    the discrete equations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span> <span class="s1">&#39;=== Testing exact solution: </span><span class="si">%s</span><span class="s1"> ===&#39;</span> <span class="o">%</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="nb">print</span> <span class="s2">&quot;Initial conditions u(0)=</span><span class="si">%s</span><span class="s2">, u&#39;(0)=</span><span class="si">%s</span><span class="s2">:&quot;</span> <span class="o">%</span> \
          <span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c1"># Method of manufactured solution requires fitting f</span>
    <span class="k">global</span> <span class="n">f</span>  <span class="c1"># source term in the ODE</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">ode_source_term</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>

    <span class="c1"># Residual in discrete equations (should be 0)</span>
    <span class="nb">print</span> <span class="s1">&#39;residual step1:&#39;</span><span class="p">,</span> <span class="n">residual_discrete_eq_step1</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="nb">print</span> <span class="s1">&#39;residual:&#39;</span><span class="p">,</span> <span class="n">residual_discrete_eq</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">linear</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Test linear function V*t+I: u(0)=I, u&#39;(0)=V.&quot;&quot;&quot;</span>
    <span class="n">main</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">V</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">I</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">quadratic</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Test quadratic function q*t**2 + V*t + I.&quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;q&#39;</span><span class="p">)</span>  <span class="c1"># arbitrary constant in t**2 term</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">q</span><span class="o">*</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">V</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">I</span>
    <span class="n">main</span><span class="p">(</span><span class="n">u_e</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cubic</span><span class="p">():</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;r q&#39;</span><span class="p">)</span>
    <span class="n">main</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">r</span><span class="o">*</span><span class="n">t</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">q</span><span class="o">*</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">V</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">I</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;&#39; + w**2*u = f for t in (0,T], u(0)=I and u&#39;(0)=V,</span>
<span class="sd">    by a central finite difference method with time step dt.</span>
<span class="sd">    f(t) is a callable Python function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>

<span class="k">def</span> <span class="nf">test_quadratic_exact_solution</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Verify solver function via quadratic solution.&quot;&quot;&quot;</span>
    <span class="c1"># Transform global symbolic variables to functions and numbers</span>
    <span class="c1"># for numerical computations</span>
    <span class="k">global</span> <span class="n">p</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="mf">2.3</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.5</span>
    <span class="k">global</span> <span class="n">f</span><span class="p">,</span> <span class="n">t</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">p</span><span class="o">*</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">V</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">I</span> <span class="c1"># use p, V, I, w as numbers</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">ode_source_term</span><span class="p">(</span><span class="n">u_e</span><span class="p">)</span>         <span class="c1"># fit source term</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>           <span class="c1"># make function numerical</span>

    <span class="n">dt</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">/</span><span class="n">w</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="o">=</span><span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_e</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-12</span>
    <span class="k">assert</span> <span class="n">error</span> <span class="o">&lt;</span> <span class="n">tol</span>
    <span class="nb">print</span> <span class="s1">&#39;Error in computing a quadratic solution:&#39;</span><span class="p">,</span> <span class="n">error</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">linear</span><span class="p">()</span>
    <span class="n">quadratic</span><span class="p">()</span>
    <span class="n">cubic</span><span class="p">()</span>
    <span class="n">test_quadratic_exact_solution</span><span class="p">()</span>
</pre></div>
</div>
<!-- --- end solution of exercise --- -->
<p>Filename: <code class="docutils literal notranslate"><span class="pre">vib_undamped_verify_mms</span></code>.</p>
<!-- --- end exercise --- -->
<!-- --- begin exercise --- -->
</div>
<div class="section" id="exercise-2-show-linear-growth-of-the-phase-with-time">
<h2><span class="section-number">9.2. </span>Exercise 2: Show linear growth of the phase with time<a class="headerlink" href="#exercise-2-show-linear-growth-of-the-phase-with-time" title="Permalink to this headline">¶</a></h2>
<div id="vib:exer:phase:err:growth"></div>
<p>Consider an exact solution <span class="math notranslate nohighlight">\(I\cos (\omega t)\)</span> and an
approximation <span class="math notranslate nohighlight">\(I\cos(\tilde\omega t)\)</span>.
Define the phase error as the time lag between the peak <span class="math notranslate nohighlight">\(I\)</span>
in the exact solution and the corresponding peak in the approximation
after <span class="math notranslate nohighlight">\(m\)</span> periods of oscillations. Show that this phase error
is linear in <span class="math notranslate nohighlight">\(m\)</span>.</p>
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong>
From (<a class="reference external" href="#vib:ode1:tildeomega:series">19</a>) we have that</p>
<div class="math notranslate nohighlight">
\[
\tilde\omega = \omega\left( 1 + \frac{1}{24}\omega^2\Delta t^2\right)
+ \mathcal{O}{\Delta t^4}
\thinspace .
\nonumber
\]</div>
<p>Dropping the <span class="math notranslate nohighlight">\(\mathcal{O}{\Delta t^4}\)</span> term, and since <span class="math notranslate nohighlight">\(\omega=\frac{2\pi}{P}\)</span> and <span class="math notranslate nohighlight">\(\tilde\omega=\frac{2\pi}{\tilde P}\)</span>, we have that</p>
<div class="math notranslate nohighlight">
\[
\frac{2\pi}{\tilde P} \approx \frac{2\pi}{P}\left( 1 + \frac{1}{24}\omega^2\Delta t^2\right)
\thinspace .
\nonumber
\]</div>
<p>Now, <span class="math notranslate nohighlight">\(2\pi\)</span> cancels and the remaining equation may be rewritten as</p>
<div class="math notranslate nohighlight">
\[
P - \tilde P \approx \frac{1}{24}\omega^2\Delta t^2
\thinspace .
\nonumber
\]</div>
<p>This implies that the periods differ by a constant. Since the exact and the numerical
solution start out identically, the phase error <span class="math notranslate nohighlight">\(P - \tilde P\)</span> will become
<span class="math notranslate nohighlight">\(m\frac{1}{24}\omega^2\Delta t^2\)</span> after <span class="math notranslate nohighlight">\(m\)</span> periods, i.e. the phase error is linear in <span class="math notranslate nohighlight">\(m\)</span>.</p>
<!-- --- end solution of exercise --- -->
<p>Filename: <code class="docutils literal notranslate"><span class="pre">vib_phase_error_growth</span></code>.</p>
<!-- --- end exercise --- -->
<!-- --- begin exercise --- -->
</div>
<div class="section" id="exercise-3-improve-the-accuracy-by-adjusting-the-frequency">
<h2><span class="section-number">9.3. </span>Exercise 3: Improve the accuracy by adjusting the frequency<a class="headerlink" href="#exercise-3-improve-the-accuracy-by-adjusting-the-frequency" title="Permalink to this headline">¶</a></h2>
<div id="vib:exer:w:adjust"></div>
<p>According to (<a class="reference external" href="#vib:ode1:tildeomega:series">19</a>), the numerical
frequency deviates from the exact frequency by a (dominating) amount
<span class="math notranslate nohighlight">\(\omega^3\Delta t^2/24 &gt;0\)</span>. Replace the <code class="docutils literal notranslate"><span class="pre">w</span></code> parameter in the algorithm
in the <code class="docutils literal notranslate"><span class="pre">solver</span></code> function in <code class="docutils literal notranslate"><span class="pre">vib_undamped.py</span></code> by <code class="docutils literal notranslate"><span class="pre">w*(1</span> <span class="pre">-</span> <span class="pre">(1./24)*w**2*dt**2</span></code> and test how this adjustment in the numerical
algorithm improves the accuracy (use <span class="math notranslate nohighlight">\(\Delta t =0.1\)</span> and simulate
for 80 periods, with and without adjustment of <span class="math notranslate nohighlight">\(\omega\)</span>).</p>
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong>
We may take a copy of the <code class="docutils literal notranslate"><span class="pre">vib_undamped.py</span></code> file and edit the <code class="docutils literal notranslate"><span class="pre">solver</span></code>
function to</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># NBVAL_SKIP</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">adjust_w</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;&#39; + w**2*u = 0 for t in (0,T], u(0)=I and u&#39;(0)=0,</span>
<span class="sd">    by a central finite difference method with time step dt.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">adjust_w</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">24</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
</div>
</div>
<p>The modified code was run for 80 periods with, and without,
the given adjustment of <span class="math notranslate nohighlight">\(\omega\)</span>. A substantial difference in accuracy
was observed between the two,
showing that the frequency adjustment improves the situation.</p>
<!-- --- end solution of exercise --- -->
<p>Filename: <code class="docutils literal notranslate"><span class="pre">vib_adjust_w</span></code>.</p>
<!-- How does this go if -->
<!-- --- end exercise --- -->
<!-- --- begin exercise --- -->
</div>
<div class="section" id="exercise-4-see-if-adaptive-methods-improve-the-phase-error">
<h2><span class="section-number">9.4. </span>Exercise 4: See if adaptive methods improve the phase error<a class="headerlink" href="#exercise-4-see-if-adaptive-methods-improve-the-phase-error" title="Permalink to this headline">¶</a></h2>
<div id="vib:exer:undamped:adaptive"></div>
<p>Adaptive methods for solving ODEs aim at adjusting <span class="math notranslate nohighlight">\(\Delta t\)</span> such
that the error is within a user-prescribed tolerance. Implement the
equation <span class="math notranslate nohighlight">\(u^{\prime\prime}+u=0\)</span> in the <a class="reference external" href="https://github.com/hplgit/odespy">Odespy</a>
software. Use the example from Section 3.2.11 in <a class="reference external" href="#Langtangen_decay">[Langtangen_decay]</a>.<br />
Run the scheme with a very low
tolerance (say <span class="math notranslate nohighlight">\(10^{-14}\)</span>) and for a long time, check the number of
time points in the solver’s mesh (<code class="docutils literal notranslate"><span class="pre">len(solver.t_all)</span></code>), and compare
the phase error with that produced by the simple finite difference
method from the section <a class="reference external" href="#vib:ode1:fdm">A centered finite difference scheme</a> with the same number of (equally
spaced) mesh points. The question is whether it pays off to use an
adaptive solver or if equally many points with a simple method gives
about the same accuracy.</p>
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong>
Here is a code where we define the test problem, solve it by the
Dormand-Prince adaptive method from Odespy, and then call <code class="docutils literal notranslate"><span class="pre">solver</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">odespy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="c1">#import matplotlib.pyplot as plt</span>
<span class="kn">import</span> <span class="nn">scitools.std</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">s</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v</span><span class="p">,</span> <span class="o">-</span><span class="n">u</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="n">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">V</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">u0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">])</span>
<span class="n">w</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">T</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">tol</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">DormandPrince</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">0.1</span><span class="o">*</span><span class="n">tol</span><span class="p">)</span>

<span class="n">Nt</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># just one step - let scheme find its intermediate points</span>
<span class="n">t_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">t_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">10001</span><span class="p">)</span>

<span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">u0</span><span class="p">)</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">t_mesh</span><span class="p">)</span>

<span class="c1"># u and t will only consist of [I, u^Nt] and [0,T], i.e. 2 values</span>
<span class="c1"># each, while solver.u_all and solver.t_all contain all computed</span>
<span class="c1"># points. solver.u_all is a list with arrays, one array (with 2</span>
<span class="c1"># values) for each point in time.</span>
<span class="n">u_adaptive</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">u_all</span><span class="p">)</span>

<span class="c1"># For comparison, we solve also with simple FDM method</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">pardir</span><span class="p">,</span> <span class="s1">&#39;src-vib&#39;</span><span class="p">))</span>
<span class="kn">from</span> <span class="nn">vib_undamped</span> <span class="kn">import</span> <span class="n">solver</span> <span class="k">as</span> <span class="n">simple_solver</span>
<span class="n">Nt_simple</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">t_all</span><span class="p">)</span>
<span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">/</span><span class="n">Nt_simple</span>
<span class="n">u_simple</span><span class="p">,</span> <span class="n">t_simple</span> <span class="o">=</span> <span class="n">simple_solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>

<span class="c1"># Compare in plot: adaptive, constant dt, exact</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">t_all</span><span class="p">,</span> <span class="n">u_adaptive</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;k-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s1">&#39;on&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_simple</span><span class="p">,</span> <span class="n">u_simple</span><span class="p">,</span> <span class="s1">&#39;r--&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t_fine</span><span class="p">),</span> <span class="s1">&#39;b-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;tol=</span><span class="si">%.0E</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">tol</span><span class="p">,</span> <span class="s1">&#39;u simple&#39;</span><span class="p">,</span> <span class="s1">&#39;exact&#39;</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;tmp_odespy_adaptive.png&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;tmp_odespy_adaptive.pdf&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="n">raw_input</span><span class="p">()</span>
</pre></div>
</div>
<p>The program may produce the plots seen in
the figure below,
which shows how the adaptive solution clearly outhinspace .erforms the simpler method,
regardless of the accuracy level.</p>
<!-- dom:FIGURE: [fig-vib/vib_undamped_adaptive.png, width=800 frac=1.0] -->
<!-- begin figure -->
<p></p>
<img src="fig-vib/vib_undamped_adaptive.png" width=800>
<!-- end figure -->
<!-- --- end solution of exercise --- -->
<p>Filename: <code class="docutils literal notranslate"><span class="pre">vib_undamped_adaptive</span></code>.</p>
<!-- --- end exercise --- -->
<!-- --- begin exercise --- -->
</div>
<div class="section" id="exercise-5-use-a-taylor-polynomial-to-compute-u-1">
<h2><span class="section-number">9.5. </span>Exercise 5: Use a Taylor polynomial to compute <span class="math notranslate nohighlight">\(u^1\)</span><a class="headerlink" href="#exercise-5-use-a-taylor-polynomial-to-compute-u-1" title="Permalink to this headline">¶</a></h2>
<div id="vib:exer:step4b:alt"></div>
<p>As an alternative to computing <span class="math notranslate nohighlight">\(u^1\)</span> by (<a class="reference external" href="#vib:ode1:step4b">8</a>),
one can use a Taylor polynomial with three terms:</p>
<div class="math notranslate nohighlight">
\[
u(t_1) \approx u(0) + u^{\prime}(0)\Delta t + {\frac{1}{2}}u^{\prime\prime}(0)\Delta t^2
\]</div>
<p>With <span class="math notranslate nohighlight">\(u^{\prime\prime}=-\omega^2 u\)</span> and <span class="math notranslate nohighlight">\(u^{\prime}(0)=0\)</span>, show that this method also leads to
(<a class="reference external" href="#vib:ode1:step4b">8</a>). Generalize the condition on <span class="math notranslate nohighlight">\(u^{\prime}(0)\)</span> to
be <span class="math notranslate nohighlight">\(u^{\prime}(0)=V\)</span> and compute <span class="math notranslate nohighlight">\(u^1\)</span> in this case with both methods.</p>
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong>
With <span class="math notranslate nohighlight">\(u^{\prime\prime}(0)=-\omega^2 u(0)\)</span> and <span class="math notranslate nohighlight">\(u^{\prime}(0)=0\)</span>, the given Taylor series
becomes</p>
<div class="math notranslate nohighlight">
\[
u(t_1) \approx u(0) + {\frac{1}{2}}(-\omega^2 u(0))\Delta t^2
\]</div>
<p>which may be written as</p>
<div class="math notranslate nohighlight">
\[
u^1 \approx u^0 - {\frac{1}{2}}\Delta t^2\omega^2 u^0
\]</div>
<p>but this is nothing but (<a class="reference external" href="#vib:ode1:step4b">8</a>).</p>
<p>Now, consider <span class="math notranslate nohighlight">\(u^{\prime}(0)=V\)</span>.
With a centered difference approximation, this initial condition becomes</p>
<div class="math notranslate nohighlight">
\[
\frac{u^1 - u^{-1}}{2\Delta t} \approx V
\]</div>
<p>which implies that</p>
<div class="math notranslate nohighlight">
\[
u^{-1} \approx u^1 - 2\Delta t V
\]</div>
<p>When <span class="math notranslate nohighlight">\(n=0\)</span>, (<a class="reference external" href="#vib:ode1:step4">7</a>) reads</p>
<div class="math notranslate nohighlight">
\[
u^1 = 2u^0 - u^{-1} - \Delta t^2\omega^2 u^0
\]</div>
<p>Inserting the expression for <span class="math notranslate nohighlight">\(u^{-1}\)</span>, we get</p>
<div class="math notranslate nohighlight">
\[
u^1 = 2u^0 - (u^1 - 2\Delta t V) - \Delta t^2\omega^2 u^0
\]</div>
<p>which implies that</p>
<div class="math notranslate nohighlight">
\[
u^1 = u^0 + \Delta t V - \frac{1}{2}\Delta t^2\omega^2 u^0
\]</div>
<p>With the Taylor series approach, we now get</p>
<div class="math notranslate nohighlight">
\[
u(t_1) \approx u(0) + V\Delta t + {\frac{1}{2}}(-\omega^2 u(0))\Delta t^2
\]</div>
<p>which also gives</p>
<div class="math notranslate nohighlight">
\[
u^1 = u^0 + \Delta t V - \frac{1}{2}\Delta t^2\omega^2 u^0
\]</div>
<!-- --- end solution of exercise --- -->
<p>Filename: <code class="docutils literal notranslate"><span class="pre">vib_first_step</span></code>.</p>
<!-- --- end exercise --- -->
<!-- --- begin exercise --- -->
</div>
<div class="section" id="problem-6-derive-and-investigate-the-velocity-verlet-method">
<h2><span class="section-number">9.6. </span>Problem 6: Derive and investigate the velocity Verlet method<a class="headerlink" href="#problem-6-derive-and-investigate-the-velocity-verlet-method" title="Permalink to this headline">¶</a></h2>
<p>The velocity Verlet method for <span class="math notranslate nohighlight">\(u^{\prime\prime} + \omega^2u=0\)</span> is
based on the following ideas:</p>
<ol class="simple">
<li><p>step <span class="math notranslate nohighlight">\(u\)</span> forward from <span class="math notranslate nohighlight">\(t_n\)</span> to <span class="math notranslate nohighlight">\(t_{n+1}\)</span> using a three-term Taylor
series,</p></li>
<li><p>replace <span class="math notranslate nohighlight">\(u^{\prime\prime}\)</span> by <span class="math notranslate nohighlight">\(-\omega^2u\)</span></p></li>
<li><p>discretize <span class="math notranslate nohighlight">\(v^{\prime}=-\omega^2u\)</span> by a Crank-Nicolson method.</p></li>
</ol>
<p>Derive the scheme, implement it, and determine empirically the convergence rate.</p>
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong>
Stepping <span class="math notranslate nohighlight">\(u\)</span> forward from <span class="math notranslate nohighlight">\(t_n\)</span> to <span class="math notranslate nohighlight">\(t_{n+1}\)</span> using a three-term Taylor
series gives</p>
<div class="math notranslate nohighlight">
\[
u(t_{n+1}) = u(t_n) + u^{\prime}(t_n)\Delta t + \frac{1}{2}u^{\prime\prime}(t_n)\Delta t^2\thinspace .
\]</div>
<p>Using <span class="math notranslate nohighlight">\(u^{\prime}=v\)</span> and <span class="math notranslate nohighlight">\(u^{\prime\prime}=-\omega^2u\)</span>, we get the updating formula</p>
<div class="math notranslate nohighlight">
\[
u^{n+1} = u^n + v^n\Delta t - \frac{1}{2}\Delta t^2\omega^2u^n\thinspace .
\]</div>
<p>Second, the first-order equation for <span class="math notranslate nohighlight">\(v\)</span>,</p>
<div class="math notranslate nohighlight">
\[
v^{\prime}=-\omega^2u,
\]</div>
<p>is discretized by a centered difference in a Crank-Nicolson fashion at
<span class="math notranslate nohighlight">\(t_{n+\frac{1}{2}}\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\frac{v^{n+1}-v^n}{\Delta t} = -\omega^2\frac{1}{2}(u^n + u^{n+1})\thinspace .
\]</div>
<p>To summarize, we have the scheme</p>
<!-- Equation labels as ordinary links -->
<div id="_auto30"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u^{n+1} = u^n + v^n\Delta t - \frac{1}{2}\Delta t^2\omega^2u^n,
\label{_auto30} \tag{71}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="_auto31"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
v^{n+1} = v^n -\frac{1}{2}\Delta t\omega^2 (u^n + u^{n+1}),
\label{_auto31} \tag{72}
\end{equation}
\]</div>
<p>known as the velocity Verlet algorithm.
Observe that this scheme is explicit since <span class="math notranslate nohighlight">\(u^{n+1}\)</span> in the second
equation is already computed by the first equation.</p>
<p>The algorithm can be straightforwardly implemented as shown below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">vib_undamped</span> <span class="kn">import</span> <span class="n">convergence_rates</span><span class="p">,</span> <span class="n">main</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">return_v</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;=v, v&#39;=-w**2*u for t in (0,T], u(0)=I and v(0)=0,</span>
<span class="sd">    by the velocity Verlet method with time step dt.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nt</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">*</span><span class="n">dt</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">return_v</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Return just u and t as in the vib_undamped.py&#39;s solver</span>
        <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>We provide the option that this <code class="docutils literal notranslate"><span class="pre">solver</span></code> function returns the same data
as the <code class="docutils literal notranslate"><span class="pre">solver</span></code> function from the section <a class="reference external" href="#vib:impl1:solver">Making a solver function</a> (if <code class="docutils literal notranslate"><span class="pre">return_v</span></code>
is <code class="docutils literal notranslate"><span class="pre">False</span></code>), but alternatively, it may return <code class="docutils literal notranslate"><span class="pre">v</span></code> along with <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<p>The error in the Taylor series expansion behind the first equation
is <span class="math notranslate nohighlight">\(\mathcal{O}{\Delta t^3}\)</span>, while the error
in the central difference for <span class="math notranslate nohighlight">\(v\)</span> is <span class="math notranslate nohighlight">\(\mathcal{O}{\Delta t^2}\)</span>.  The overall
error is then no better than <span class="math notranslate nohighlight">\(\mathcal{O}{\Delta t^2}\)</span>, which can be verified
empirically using the <code class="docutils literal notranslate"><span class="pre">convergence_rates</span></code> function from
the section <a class="reference external" href="#vib:ode1:verify">Verification</a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">vib_undamped_velocity_Verlet</span> <span class="k">as</span> <span class="nn">m</span>
<span class="n">m</span><span class="o">.</span><span class="n">convergence_rates</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">solver_function</span><span class="o">=</span><span class="n">m</span><span class="o">.</span><span class="n">solver</span><span class="p">)</span>
</pre></div>
</div>
<p>The output confirms that the overall convergence rate is 2.</p>
<!-- --- end solution of exercise --- -->
<!-- How can the scheme be extended to the general case $mu^{\prime\prime} -->
<!-- + f(u^{\prime}) + s(u) =F(t)$? No, that's too complicated because of -->
<!-- the substitution in the Taylor series. -->
<!-- --- end exercise --- -->
<!-- --- begin exercise --- -->
</div>
<div class="section" id="problem-7-find-the-minimal-resolution-of-an-oscillatory-function">
<h2><span class="section-number">9.7. </span>Problem 7: Find the minimal resolution of an oscillatory function<a class="headerlink" href="#problem-7-find-the-minimal-resolution-of-an-oscillatory-function" title="Permalink to this headline">¶</a></h2>
<div id="vib:exer:wdt:limit"></div>
<!-- Short: Find the largest relevant value of $\omega\Delta t$ -->
<p>Sketch the function on a given mesh which has the highest possible
frequency. That is, this oscillatory “cos-like” function has its
maxima and minima at every two grid points.  Find an expression for
the frequency of this function, and use the result to find the largest
relevant value of <span class="math notranslate nohighlight">\(\omega\Delta t\)</span> when <span class="math notranslate nohighlight">\(\omega\)</span> is the frequency
of an oscillating function and <span class="math notranslate nohighlight">\(\Delta t\)</span> is the mesh spacing.</p>
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong>
The smallest period must be <span class="math notranslate nohighlight">\(2\Delta t\)</span>. Since the period <span class="math notranslate nohighlight">\(P\)</span> is related
to the angular frequency <span class="math notranslate nohighlight">\(\omega\)</span> by <span class="math notranslate nohighlight">\(P=2\pi/\omega\)</span>, it means that
<span class="math notranslate nohighlight">\(\omega = \frac{2\pi}{2\Delta t} = \frac{\pi}{\Delta t}\)</span> is the smallest
meaningful angular frequency.
This further means that the largest value for <span class="math notranslate nohighlight">\(\omega\Delta t\)</span> is <span class="math notranslate nohighlight">\(\pi\)</span>.</p>
<!-- --- end solution of exercise --- -->
<p>Filename: <code class="docutils literal notranslate"><span class="pre">vib_largest_wdt</span></code>.</p>
<!-- --- end exercise --- -->
<!-- --- begin exercise --- -->
</div>
<div class="section" id="exercise-8-visualize-the-accuracy-of-finite-differences-for-a-cosine-function">
<h2><span class="section-number">9.8. </span>Exercise 8: Visualize the accuracy of finite differences for a cosine function<a class="headerlink" href="#exercise-8-visualize-the-accuracy-of-finite-differences-for-a-cosine-function" title="Permalink to this headline">¶</a></h2>
<div id="vib:exer:fd:exp:plot"></div>
<!-- Short: Visualize the accuracy of finite differences -->
<p>We introduce the error fraction</p>
<div class="math notranslate nohighlight">
\[
E = \frac{[D_tD_t u]^n}{u^{\prime\prime}(t_n)}
\]</div>
<p>to measure the error in the finite difference approximation <span class="math notranslate nohighlight">\(D_tD_tu\)</span> to
<span class="math notranslate nohighlight">\(u^{\prime\prime}\)</span>.
Compute <span class="math notranslate nohighlight">\(E\)</span>
for the specific choice of a cosine/sine function of the
form <span class="math notranslate nohighlight">\(u=\exp{(i\omega t)}\)</span> and show that</p>
<div class="math notranslate nohighlight">
\[
E = \left(\frac{2}{\omega\Delta t}\right)^2
\sin^2(\frac{\omega\Delta t}{2})
\thinspace .
\]</div>
<p>Plot <span class="math notranslate nohighlight">\(E\)</span> as a function of <span class="math notranslate nohighlight">\(p=\omega\Delta t\)</span>. The relevant
values of <span class="math notranslate nohighlight">\(p\)</span> are <span class="math notranslate nohighlight">\([0,\pi]\)</span> (see <a class="reference external" href="#vib:exer:wdt:limit">Problem 7: Find the minimal resolution of an oscillatory function</a>
for why <span class="math notranslate nohighlight">\(p&gt;\pi\)</span> does not make sense).
The deviation of the curve from unity visualizes the error in the
approximation. Also expand <span class="math notranslate nohighlight">\(E\)</span> as a Taylor polynomial in <span class="math notranslate nohighlight">\(p\)</span> up to
fourth degree (use, e.g., <code class="docutils literal notranslate"><span class="pre">sympy</span></code>).</p>
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong></p>
<div class="math notranslate nohighlight">
\[
E = \frac{[D_tD_t u]^n}{u^{\prime\prime}(t_n)}, \nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
= \frac{u^{n+1} - 2u^n + u^{n-1}}{u^{\prime\prime}(t_n)\Delta t^2}, \nonumber
\]</div>
<p>Since <span class="math notranslate nohighlight">\(u(t)=\exp{(i\omega t)}\)</span>, we have that <span class="math notranslate nohighlight">\(u^{\prime}(t)=i\omega\exp{(i\omega t)}\)</span>
and <span class="math notranslate nohighlight">\(u^{\prime\prime}(t)=(i\omega)^2\exp{(i\omega t)}=-\omega^2\exp{(i\omega t)}\)</span>, so we may proceed with <span class="math notranslate nohighlight">\(E\)</span> as</p>
<div class="math notranslate nohighlight">
\[
E = \frac{e^{i\omega(t_n+\Delta t)} - 2e^{i\omega t_n} + e^{i\omega(t_n-\Delta t)}}{-\omega^2e^{i\omega t_n}\Delta t^2}, \nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
=\frac{e^{i\omega t_n}e^{i\omega \Delta t} -2e^{i\omega t_n} + e^{i\omega t_n}e^{-i\omega\Delta t}}{-\omega^2e^{i\omega t_n}\Delta t^2}, \nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
= \frac{e^{i\omega\Delta t} - 2 + e^{-i\omega\Delta t}}{-\omega^2 \Delta t^2}, \nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
= \frac{1}{-\omega^2 \Delta t^2}\frac{4}{4}\left(e^{i\omega\Delta t} - 2 + e^{-i\omega\Delta t}\right), \nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
= \left(\frac{2}{\omega\Delta t}\right)^2 \left(-\frac{e^{i\omega\Delta t} - 2 + e^{-i\omega\Delta t}}{4}\right), \nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
= \left(\frac{2}{\omega\Delta t}\right)^2 \left(-\frac{1}{2}\left(\frac{1}{2}e^{i\omega\Delta t} + e^{-i\omega\Delta t} - 1\right)\right), \nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
= \left(\frac{2}{\omega\Delta t}\right)^2 \left(-\frac{1}{2}\left( \cos(\omega\Delta t) - 1\right)\right). \nonumber
\]</div>
<p>Now, since <span class="math notranslate nohighlight">\(\cos(\omega\Delta t)=1-2\sin^2\left(\frac{\omega\Delta t}{2}\right)\)</span>, we finally get</p>
<div class="math notranslate nohighlight">
\[
E = \left(\frac{2}{\omega\Delta t}\right)^2 \left(-\frac{1}{2}\left( \left(1-2\sin^2\left(\frac{\omega\Delta t}{2}\right)\right) - 1\right)\right), \nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
= \left(\frac{2}{\omega\Delta t}\right)^2 \sin^2\left(\frac{\omega\Delta t}{2}\right). \nonumber
\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="nn">sym</span>

<span class="k">def</span> <span class="nf">E_fraction</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="mf">2.</span><span class="o">/</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">p</span><span class="o">/</span><span class="mf">2.</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>

<span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">E_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>

<span class="c1"># create 4th degree Taylor polynomial (also plotted)</span>
<span class="n">p_</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p_&#39;</span><span class="p">)</span>
<span class="n">E</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span><span class="o">/</span><span class="n">p_</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">p_</span><span class="o">/</span><span class="mf">2.</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
<span class="n">E_series</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p_</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">E_series</span><span class="p">)</span>
<span class="n">E_pyfunc</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">p_</span><span class="p">],</span> <span class="n">E_series</span><span class="p">,</span> <span class="n">modules</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>

<span class="c1"># To avoid division by zero when p is 0, we rather take the limit</span>
<span class="n">E_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">p_</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>  <span class="c1"># ...when p --&gt; 0, E --&gt; 1</span>
<span class="n">E_values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">E_fraction</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">E_values</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">E_pyfunc</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="s1">&#39;k--&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Error fraction&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;E Taylor&#39;</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;tmp_error_fraction.png&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;tmp_error_fraction.pdf&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.0 - 0.0833333333333333*p_**2
</pre></div>
</div>
<img alt="../../_images/vib_undamped_442_1.png" src="../../_images/vib_undamped_442_1.png" />
</div>
</div>
<p>From the plot seen below, we realize
how the error fraction <span class="math notranslate nohighlight">\(E\)</span> deviates from unity as <span class="math notranslate nohighlight">\(p\)</span> grows.</p>
<!-- dom:FIGURE: [fig-vib/error_fraction.png, width=600 frac=1.0] -->
<!-- begin figure -->
<p></p>
<img src="fig-vib/error_fraction.png" width=600>
<!-- end figure -->
<!-- --- end solution of exercise --- -->
<p>Filename: <code class="docutils literal notranslate"><span class="pre">vib_plot_fd_exp_error</span></code>.</p>
<!-- --- end exercise --- -->
<!-- --- begin exercise --- -->
</div>
<div class="section" id="exercise-9-verify-convergence-rates-of-the-error-in-energy">
<h2><span class="section-number">9.9. </span>Exercise 9: Verify convergence rates of the error in energy<a class="headerlink" href="#exercise-9-verify-convergence-rates-of-the-error-in-energy" title="Permalink to this headline">¶</a></h2>
<div id="vib:exer:energy:convrate"></div>
<p>We consider the ODE problem <span class="math notranslate nohighlight">\(u^{\prime\prime} + \omega^2u=0\)</span>, <span class="math notranslate nohighlight">\(u(0)=I\)</span>, <span class="math notranslate nohighlight">\(u^{\prime}(0)=V\)</span>,
for <span class="math notranslate nohighlight">\(t\in (0,T]\)</span>. The total energy of the solution
<span class="math notranslate nohighlight">\(E(t)=\frac{1}{2}(u^{\prime})^2 + \frac{1}{2}\omega^2 u^2\)</span> should stay
constant.
The error in energy can be computed as explained in
the section <a class="reference external" href="#vib:model1:energy">Energy considerations</a>.</p>
<p>Make a test function in a separate file, where code from
<code class="docutils literal notranslate"><span class="pre">vib_undamped.py</span></code> is imported, but the <code class="docutils literal notranslate"><span class="pre">convergence_rates</span></code> and
<code class="docutils literal notranslate"><span class="pre">test_convergence_rates</span></code> functions are copied and modified to also
incorporate computations of the error in energy and the convergence
rate of this error. The expected rate is 2, just as for the solution
itself.</p>
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong>
The complete code with test functions goes as follows.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">pardir</span><span class="p">,</span> <span class="s1">&#39;src-vib&#39;</span><span class="p">))</span>
<span class="kn">from</span> <span class="nn">vib_undamped</span> <span class="kn">import</span> <span class="n">solver</span><span class="p">,</span> <span class="n">u_exact</span><span class="p">,</span> <span class="n">visualize</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">convergence_rates</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">solver_function</span><span class="p">,</span> <span class="n">num_periods</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return m-1 empirical estimates of the convergence rate</span>
<span class="sd">    based on m simulations, where the time step is halved</span>
<span class="sd">    for each simulation.</span>
<span class="sd">    solver_function(I, w, dt, T) solves each problem, where T</span>
<span class="sd">    is based on simulation for num_periods periods.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mf">0.35</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="mf">0.3</span>       <span class="c1"># just chosen values</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>              <span class="c1"># period</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">P</span><span class="o">/</span><span class="mi">30</span>               <span class="c1"># 30 time step per period 2*pi/w</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">num_periods</span>
    <span class="n">energy_const</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">I</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span>    <span class="c1"># initial energy when V = 0</span>

    <span class="n">dt_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">E_u_values</span> <span class="o">=</span> <span class="p">[]</span>         <span class="c1"># error in u</span>
    <span class="n">E_energy_values</span> <span class="o">=</span> <span class="p">[]</span>    <span class="c1"># error in energy</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver_function</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
        <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">E_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">u_e</span><span class="o">-</span><span class="n">u</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">E_u_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E_u</span><span class="p">)</span>
        <span class="n">energy</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">((</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> \
                                    <span class="mf">0.5</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">E_energy</span> <span class="o">=</span> <span class="n">energy</span> <span class="o">-</span> <span class="n">energy_const</span>
        <span class="n">E_energy_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">E_energy</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">E_energy_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E_energy_norm</span><span class="p">)</span>
        <span class="n">dt_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">/</span><span class="mi">2</span>

    <span class="n">r_u</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">E_u_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">E_u_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span>
         <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="n">r_E</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">E_energy_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">E_energy_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span>
         <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">r_u</span><span class="p">,</span> <span class="n">r_E</span>

<span class="k">def</span> <span class="nf">test_convergence_rates</span><span class="p">():</span>
    <span class="n">r_u</span><span class="p">,</span> <span class="n">r_E</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span>
        <span class="n">m</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">solver_function</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span>
        <span class="n">num_periods</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="c1"># Accept rate to 1 decimal place</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">r_u</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">r_E</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">test_convergence_rates</span><span class="p">()</span>
</pre></div>
</div>
<!-- --- end solution of exercise --- -->
<p>Filename: <code class="docutils literal notranslate"><span class="pre">test_error_conv</span></code>.</p>
<!-- --- end exercise --- -->
<!-- --- begin exercise --- -->
</div>
<div class="section" id="exercise-10-use-linear-quadratic-functions-for-verification">
<h2><span class="section-number">9.10. </span>Exercise 10: Use linear/quadratic functions for verification<a class="headerlink" href="#exercise-10-use-linear-quadratic-functions-for-verification" title="Permalink to this headline">¶</a></h2>
<div id="vib:exer:verify:gen:linear"></div>
<p>This exercise is a generalization of <a class="reference external" href="#vib:exer:undamped:verify:linquad">Problem 1: Use linear/quadratic functions for verification</a> to the extended model problem
(<a class="reference external" href="#vib:ode2">vib:ode2</a>) where the damping term is either linear or quadratic.
Solve the various subproblems and see how the results and problem
settings change with the generalized ODE in case of linear or
quadratic damping. By modifying the code from <a class="reference external" href="#vib:exer:undamped:verify:linquad">Problem 1: Use linear/quadratic functions for verification</a>, <code class="docutils literal notranslate"><span class="pre">sympy</span></code> will do most
of the work required to analyze the generalized problem.</p>
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong>
With a linear spring force, i.e. <span class="math notranslate nohighlight">\(s(u)=cu\)</span> (for constant <span class="math notranslate nohighlight">\(c\)</span>),
our model problem becomes</p>
<div class="math notranslate nohighlight">
\[
mu^{\prime\prime} + f(u^{\prime}) + cu = F(t),\quad u(0)=I,\ u^{\prime}(0)=V,\ t\in (0,T]
\thinspace .
\nonumber
\]</div>
<p>First we consider linear damping, i.e., when <span class="math notranslate nohighlight">\(f(u^{\prime}) =
bu^{\prime}\)</span>, and follow the text in the section <a class="reference external" href="#vib:ode2:fdm:flin">vib:ode2:fdm:flin</a>. Discretizing the equation according to</p>
<div class="math notranslate nohighlight">
\[
[mD_tD_t u + f(D_{2t}u) + cu = F]^n,
\nonumber
\]</div>
<p>implies that</p>
<div class="math notranslate nohighlight">
\[
m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
+ b\frac{u^{n+1}-u^{n-1}}{2\Delta t} + cu^n = F^n.
\nonumber
\]</div>
<p>The explicit formula for <span class="math notranslate nohighlight">\(u\)</span> at each
new time level then becomes</p>
<div class="math notranslate nohighlight">
\[
u^{n+1} = (2mu^n + (\frac{b}{2}\Delta t - m)u^{n-1} +
\Delta t^2(F^n - cu^n))(m + \frac{b}{2}\Delta t)^{-1}
\nonumber
\thinspace .
\]</div>
<p>For the first time step, we use <span class="math notranslate nohighlight">\(n=0\)</span> and a centered difference approximation for the
initial condition on the derivative. This gives</p>
<div class="math notranslate nohighlight">
\[
u^1 = u^0 + \Delta t\, V
+ \frac{\Delta t^2}{2m}(-bV - cu^0 + F^0)
\thinspace .
\nonumber
\]</div>
<p>Next, we consider quadratic damping, i.e., when
<span class="math notranslate nohighlight">\(f(u^{\prime})=bu^{\prime}|u^{\prime}|\)</span>, and follow the
text in the chapter <a class="reference external" href="#vib:ode2:fdm:fquad">vib:ode2:fdm:fquad</a>. Discretizing the
equation according to</p>
<div class="math notranslate nohighlight">
\[
[mD_tD_t u + bD_{2t}u|D_{2t}u| + cu = F]^n\thinspace .
\nonumber
\]</div>
<p>gives us</p>
<div class="math notranslate nohighlight">
\[
m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
+ b\frac{u^{n+1}-u^n}{\Delta t}\frac{|u^n-u^{n-1}|}{\Delta t}
+ cu^n = F^n.
\nonumber
\]</div>
<p>We solve for <span class="math notranslate nohighlight">\(u^{n+1}\)</span> to get the explicit updating formula as</p>
<div class="math notranslate nohighlight">
\[
u^{n+1} =  \left( m + b|u^n-u^{n-1}|\right)^{-1}\times \nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
\qquad \left(2m u^n - mu^{n-1} + bu^n|u^n-u^{n-1}| + \Delta t^2 (F^n - cu^n)
\right)
\thinspace .
\nonumber
\]</div>
<p>and the equation for the first time step as</p>
<div class="math notranslate nohighlight">
\[
u^1 = u^0 + \Delta t V + \frac{\Delta t^2}{2m}\left(-bV|V| - cu^0 + F^0\right)
\thinspace .
\nonumber
\]</div>
<p>Turning to verification with MMS and <span class="math notranslate nohighlight">\(u_e(t)=ct+d\)</span>, we get <span class="math notranslate nohighlight">\(d=I\)</span> and <span class="math notranslate nohighlight">\(c=V\)</span> independent
of the damping term, so these parameter values stay as for the undamped case.</p>
<p>Proceeding with linear damping, we get from the chapter <a class="reference external" href="#vib:ode2:verify">vib:ode2:verify</a> that</p>
<div class="math notranslate nohighlight">
\[
F(t) = bV + c(Vt + I)\thinspace .
\nonumber
\]</div>
<p>(Note that there are two different c parameters here, one from <span class="math notranslate nohighlight">\(u_e=ct+d\)</span> and one from the spring force <span class="math notranslate nohighlight">\(cu\)</span>.
The first one disappears, however, as it is switched with <span class="math notranslate nohighlight">\(V\)</span>.)</p>
<p>To show that <span class="math notranslate nohighlight">\(u_e\)</span> is a perfect solution also to the discrete equations, we insert <span class="math notranslate nohighlight">\(u_e\)</span> and <span class="math notranslate nohighlight">\(F\)</span> into</p>
<div class="math notranslate nohighlight">
\[
[mD_tD_t u + bD_{2t}u + cu = F]^n\thinspace .
\nonumber
\]</div>
<p>This gives</p>
<div class="math notranslate nohighlight">
\[
[mD_tD_t (Vt+I) + bD_{2t}(Vt+I) + c(Vt+I) = bV + c(Vt + I)]^n,
\nonumber
\]</div>
<p>which may be split up as</p>
<div class="math notranslate nohighlight">
\[
m[D_tD_t (Vt+I)]^n + b[D_{2t}(Vt+I)]^n + c[(Vt+I)]^n = b[V]^n + c[(Vt + I)]^n.
\nonumber
\]</div>
<p>Simplifying, we note that the first term is zero and that <span class="math notranslate nohighlight">\(c[(Vt+I)]^n\)</span> appears with the
same sign on each side of the equation. Thus, dropping these terms, and cancelling the common
factor <span class="math notranslate nohighlight">\(b\)</span>, we are left with</p>
<div class="math notranslate nohighlight">
\[
[D_{2t}(Vt+I)]^n = [V]^n.
\nonumber
\]</div>
<p>mathcal{I}_t therefore remains to show that <span class="math notranslate nohighlight">\([D_{2t}(Vt+I)]^n\)</span> is equal to <span class="math notranslate nohighlight">\([V]^n = V\)</span>. We write out
the left hand side as</p>
<div class="math notranslate nohighlight">
\[
[D_{2t}(Vt+I)]^n = \frac{(Vt_{n+1}+I) - (Vt_{n-1}+I)}{2\Delta t} \nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
= \frac{V(t_{n+1}-t_{n-1})}{2\Delta t} \nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
= \frac{V((t_n + \Delta t) - (t_n - \Delta t))}{2\Delta t} \nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
= V, \nonumber
\nonumber
\]</div>
<p>which shows that the two sides of the equation are equal and that the discrete equations
are fulfilled exactly for the given <span class="math notranslate nohighlight">\(u_e\)</span> function.</p>
<p>If the damping is rather quadratic, we find from the chapter <a class="reference external" href="#vib:ode2:verify">vib:ode2:verify</a> that</p>
<div class="math notranslate nohighlight">
\[
F(t) = b|V|V + c(Vt + I)\thinspace .
\nonumber
\]</div>
<p>As with linear damping, we show that <span class="math notranslate nohighlight">\(u_e\)</span> is a perfect solution also to the discrete equations
by inserting <span class="math notranslate nohighlight">\(u_e\)</span> and <span class="math notranslate nohighlight">\(F\)</span> into</p>
<div class="math notranslate nohighlight">
\[
[mD_tD_t u + bD_{2t}u|D_{2t}u| + cu = F]^n\thinspace .
\nonumber
\]</div>
<p>We then get</p>
<div class="math notranslate nohighlight">
\[
[mD_tD_t (Vt+I) + bD_{2t}(Vt+I)|D_{2t}(Vt+I)| + c(Vt+I) = b|V|V + c(Vt+I)]^n,
\nonumber
\]</div>
<p>which simplifies to</p>
<div class="math notranslate nohighlight">
\[
[bD_{2t}(Vt+I)|D_{2t}(Vt+I)| = b|V|V]^n
\nonumber
\]</div>
<p>and further to</p>
<div class="math notranslate nohighlight">
\[
[D_{2t}(Vt+I)]^n [|D_{2t}(Vt+I)|]^n = |V|V
\nonumber
\]</div>
<p>which simply states that</p>
<div class="math notranslate nohighlight">
\[
V|V| = |V|V\thinspace .
\nonumber
\]</div>
<p>Thus, <span class="math notranslate nohighlight">\(u_e\)</span> fulfills the discrete equations exactly also when the damping term
is quadratic.</p>
<p>When the exact solution is changed to become quadratic or cubic, the situation is more complicated.</p>
<p>For a quadratic solution <span class="math notranslate nohighlight">\(u_e\)</span> combined with (zero damping or) linear damping, the output from the program below shows that the discrete equations are fulfilled exactly. However, this is not the case with nonlinear damping, where only the first step gives zero residual.</p>
<p>For a cubic solution <span class="math notranslate nohighlight">\(u_e\)</span>, we get a nonzero residual for (zero damping and) linear and nonlinear damping.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="nn">sym</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># The code in vib_undamped_verify_mms.py is here generalized</span>
<span class="c1"># to treat the model m*u&#39;&#39; + f(u&#39;) + c*u = F(t), where the</span>
<span class="c1"># damping term f(u&#39;) = 0, b*u&#39; or b*V*abs(V).</span>

<span class="k">def</span> <span class="nf">ode_source_term</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">damping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the terms in the ODE that the source term</span>
<span class="sd">    must balance, here m*u&#39;&#39; + f(u&#39;) + c*u.</span>
<span class="sd">    u is a symbolic Python function of t.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">damping</span> <span class="o">==</span> <span class="s1">&#39;zero&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">m</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">damping</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">m</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> \
               <span class="n">b</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># damping is nonlinear</span>
        <span class="k">return</span> <span class="n">m</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> \
               <span class="n">b</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">))</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">residual_discrete_eq</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">damping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the residual of the discrete eq. with u inserted.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">damping</span> <span class="o">==</span> <span class="s1">&#39;zero&#39;</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">m</span><span class="o">*</span><span class="n">DtDt</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span>
    <span class="k">elif</span> <span class="n">damping</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">m</span><span class="o">*</span><span class="n">DtDt</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">D2t</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span>
    <span class="k">else</span><span class="p">:</span>   <span class="c1"># damping is nonlinear</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">m</span><span class="o">*</span><span class="n">DtDt</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">Dt_p_half</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span><span class="o">*</span>\
            <span class="nb">abs</span><span class="p">(</span><span class="n">Dt_m_half</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">))</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span>
    <span class="k">return</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">residual_discrete_eq_step1</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">damping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the residual of the discrete eq. at the first</span>
<span class="sd">    step with u inserted.&quot;&quot;&quot;</span>
    <span class="n">half</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">damping</span> <span class="o">==</span> <span class="s1">&#39;zero&#39;</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">dt</span><span class="p">)</span> <span class="o">-</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span> <span class="o">-</span> \
            <span class="n">half</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="n">half</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">c</span><span class="o">/</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="n">I</span>
    <span class="k">elif</span> <span class="n">damping</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">dt</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">I</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span> <span class="o">+</span> \
            <span class="n">half</span><span class="o">*</span><span class="p">(</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="n">V</span> <span class="o">-</span> <span class="n">c</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="n">F</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>   <span class="c1"># damping is nonlinear</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">dt</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">I</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span> <span class="o">+</span> \
            <span class="n">half</span><span class="o">*</span><span class="p">(</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="n">V</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="n">F</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># t=0 in the rhs of the first step eq.</span>
    <span class="k">return</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DtDt</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return 2nd-order finite difference for u_tt.</span>
<span class="sd">    u is a symbolic Python function of t.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">dt</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">dt</span><span class="p">))</span><span class="o">/</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span>

<span class="k">def</span> <span class="nf">D2t</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return 2nd-order finite difference for u_t.</span>
<span class="sd">    u is a symbolic Python function of t.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">dt</span><span class="p">)</span> <span class="o">-</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">dt</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Dt_p_half</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return 2nd-order finite difference for u_t, sampled at n+1/2,</span>
<span class="sd">    i.e, n pluss one half... u is a symbolic Python function of t.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">dt</span><span class="p">)</span> <span class="o">-</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="o">/</span><span class="n">dt</span>

<span class="k">def</span> <span class="nf">Dt_m_half</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return 2nd-order finite difference for u_t, sampled at n-1/2,</span>
<span class="sd">    i.e, n minus one half.... u is a symbolic Python function of t.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">dt</span><span class="p">))</span><span class="o">/</span><span class="n">dt</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">damping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given some chosen solution u (as a function of t, implemented</span>
<span class="sd">    as a Python function), use the method of manufactured solutions</span>
<span class="sd">    to compute the source term f, and check if u also solves</span>
<span class="sd">    the discrete equations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span> <span class="s1">&#39;=== Testing exact solution: </span><span class="si">%s</span><span class="s1"> ===&#39;</span> <span class="o">%</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="nb">print</span> <span class="s2">&quot;Initial conditions u(0)=</span><span class="si">%s</span><span class="s2">, u&#39;(0)=</span><span class="si">%s</span><span class="s2">:&quot;</span> <span class="o">%</span> \
          <span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c1"># Method of manufactured solution requires fitting F</span>
    <span class="k">global</span> <span class="n">F</span>  <span class="c1"># source term in the ODE</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">ode_source_term</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">damping</span><span class="p">))</span>

    <span class="c1"># Residual in discrete equations (should be 0)</span>
    <span class="nb">print</span> <span class="s1">&#39;residual step1:&#39;</span><span class="p">,</span> <span class="n">residual_discrete_eq_step1</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">damping</span><span class="p">)</span>
    <span class="nb">print</span> <span class="s1">&#39;residual:&#39;</span><span class="p">,</span> <span class="n">residual_discrete_eq</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">damping</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">linear</span><span class="p">(</span><span class="n">damping</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">u_e</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return chosen linear exact solution.&quot;&quot;&quot;</span>
        <span class="c1"># General linear function u_e = c*t + d</span>
        <span class="c1"># Initial conditions u(0)=I, u&#39;(0)=V require c=V, d=I</span>
        <span class="k">return</span> <span class="n">V</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">I</span>

    <span class="n">main</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">damping</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">quadratic</span><span class="p">(</span><span class="n">damping</span><span class="p">):</span>
    <span class="c1"># Extend with quadratic functions</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;q&#39;</span><span class="p">)</span>  <span class="c1"># arbitrary constant in quadratic term</span>

    <span class="k">def</span> <span class="nf">u_e</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">q</span><span class="o">*</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">V</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">I</span>

    <span class="n">main</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">damping</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cubic</span><span class="p">(</span><span class="n">damping</span><span class="p">):</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;r q&#39;</span><span class="p">)</span>

    <span class="n">main</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">r</span><span class="o">*</span><span class="n">t</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">q</span><span class="o">*</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">V</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">I</span><span class="p">,</span> <span class="n">damping</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">damping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve m*u&#39;&#39; + f(u&#39;) + c*u = F for t in (0,T], u(0)=I and u&#39;(0)=V,</span>
<span class="sd">    by a central finite difference method with time step dt.</span>
<span class="sd">    F(t) is a callable Python function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">damping</span> <span class="o">==</span> <span class="s1">&#39;zero&#39;</span><span class="p">:</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">c</span><span class="o">/</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> \
               <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">m</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
            <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> \
                     <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">c</span><span class="o">/</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="o">/</span><span class="n">m</span>
    <span class="k">elif</span> <span class="n">damping</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span> <span class="o">+</span> \
               <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="n">V</span> <span class="o">-</span> <span class="n">c</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
            <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mf">2.</span><span class="o">-</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
                     <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span><span class="o">/</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="n">b</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>    <span class="c1"># damping is quadratic</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span> <span class="o">+</span> \
               <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="n">V</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
            <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="n">b</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span> \
                     <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">*</span>\
                     <span class="nb">abs</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>

<span class="k">def</span> <span class="nf">test_quadratic_exact_solution</span><span class="p">(</span><span class="n">damping</span><span class="p">):</span>
    <span class="c1"># Transform global symbolic variables to functions and numbers</span>
    <span class="c1"># for numerical computations</span>

    <span class="k">global</span> <span class="n">p</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">m</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mf">2.3</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">,</span> <span class="mf">1.6</span><span class="p">,</span> <span class="mf">1.3</span> <span class="c1"># i.e., as numbers</span>
    <span class="k">global</span> <span class="n">F</span><span class="p">,</span> <span class="n">t</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">p</span><span class="o">*</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">V</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">I</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">ode_source_term</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">damping</span><span class="p">)</span> <span class="c1"># fit source term</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>            <span class="c1"># ...numerical Python function</span>

    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sqrt</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="o">/</span><span class="n">m</span><span class="p">)</span><span class="o">/</span><span class="mi">10</span>   <span class="c1"># 10 steps per period 2*pi/w, w=sqrt(c/m)</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="o">=</span><span class="n">V</span><span class="p">,</span> <span class="n">F</span><span class="o">=</span><span class="n">F</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span>
                  <span class="n">T</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="o">/</span><span class="n">m</span><span class="p">))</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_e</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-12</span>
    <span class="k">assert</span> <span class="n">error</span> <span class="o">&lt;</span> <span class="n">tol</span>    
    <span class="nb">print</span> <span class="s1">&#39;Error in computing a quadratic solution:&#39;</span><span class="p">,</span> <span class="n">error</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">damping</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;zero&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">damping</span><span class="p">:</span>
        <span class="n">V</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;V t I dt m b c&#39;</span><span class="p">)</span>  <span class="c1"># global</span>
        <span class="n">F</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># global variable for the source term in the ODE</span>
        <span class="nb">print</span> <span class="s1">&#39;---------------------------------------Damping:&#39;</span><span class="p">,</span> <span class="n">e</span>
        <span class="n">linear</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>  	<span class="c1"># linear solution used for MMS</span>
        <span class="n">quadratic</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>   	<span class="c1"># quadratic solution for MMS</span>
        <span class="n">cubic</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>       	<span class="c1"># ... and cubic</span>
        <span class="n">test_quadratic_exact_solution</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<!-- --- end solution of exercise --- -->
<p>Filename: <code class="docutils literal notranslate"><span class="pre">vib_verify_mms</span></code>.</p>
<!-- --- end exercise --- -->
<!-- --- begin exercise --- -->
</div>
<div class="section" id="exercise-11-use-an-exact-discrete-solution-for-verification">
<h2><span class="section-number">9.11. </span>Exercise 11: Use an exact discrete solution for verification<a class="headerlink" href="#exercise-11-use-an-exact-discrete-solution-for-verification" title="Permalink to this headline">¶</a></h2>
<div id="vib:exer:discrete:omega"></div>
<p>Write a test function in a separate file
that employs the exact discrete solution
(<a class="reference external" href="#vib:ode1:un:exact">20</a>) to verify the implementation of the
<code class="docutils literal notranslate"><span class="pre">solver</span></code> function in the file <code class="docutils literal notranslate"><span class="pre">vib_undamped.py</span></code>.</p>
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong>
The code goes like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">vib_undamped</span> <span class="kn">import</span> <span class="n">solver</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">arcsin</span> <span class="k">as</span> <span class="n">asin</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="nb">abs</span>

<span class="k">def</span> <span class="nf">test_solver_exact_discrete_solution</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">tilde_w</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">2.</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span><span class="o">*</span><span class="n">asin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">u_numerical_exact</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">tilde_w</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

    <span class="n">w</span> <span class="o">=</span> <span class="mf">2.5</span>
    <span class="n">I</span> <span class="o">=</span> <span class="mf">1.5</span>

    <span class="c1"># Estimate period and time step</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>
    <span class="n">num_periods</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">num_periods</span><span class="o">*</span><span class="n">P</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">5</span>               <span class="c1"># time steps per period</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">P</span><span class="o">/</span><span class="n">N</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_numerical_exact</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">error</span><span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="c1"># Make a plot in a file, but not on the screen</span>
    <span class="kn">from</span> <span class="nn">scitools.std</span> <span class="kn">import</span> <span class="n">plot</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s1">&#39;bo&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s1">&#39;r-&#39;</span><span class="p">,</span>
         <span class="n">legend</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;numerical&#39;</span><span class="p">,</span> <span class="s1">&#39;exact&#39;</span><span class="p">),</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
         <span class="n">savefig</span><span class="o">=</span><span class="s1">&#39;tmp.png&#39;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">error</span> <span class="o">&lt;</span> <span class="mf">1E-14</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">test_solver_exact_discrete_solution</span><span class="p">()</span>
</pre></div>
</div>
<!-- --- end solution of exercise --- -->
<p>Filename: <code class="docutils literal notranslate"><span class="pre">test_vib_undamped_exact_discrete_sol</span></code>.</p>
<!-- --- end exercise --- -->
<!-- --- begin exercise --- -->
</div>
<div class="section" id="exercise-12-use-analytical-solution-for-convergence-rate-tests">
<h2><span class="section-number">9.12. </span>Exercise 12: Use analytical solution for convergence rate tests<a class="headerlink" href="#exercise-12-use-analytical-solution-for-convergence-rate-tests" title="Permalink to this headline">¶</a></h2>
<div id="vib:exer:conv:rate"></div>
<p>The purpose of this exercise is to perform convergence tests of the
problem (<a class="reference external" href="#vib:ode2">vib:ode2</a>) when <span class="math notranslate nohighlight">\(s(u)=cu\)</span>, <span class="math notranslate nohighlight">\(F(t)=A\sin\phi t\)</span> and there
is no damping.  Find the complete analytical solution to the problem
in this case (most textbooks on mechanics or ordinary differential
equations list the various elements you need to write down the exact
solution, or you can use symbolic tools like <code class="docutils literal notranslate"><span class="pre">sympy</span></code> or <code class="docutils literal notranslate"><span class="pre">wolframalpha.com</span></code>).
Modify the <code class="docutils literal notranslate"><span class="pre">convergence_rate</span></code> function from the
<code class="docutils literal notranslate"><span class="pre">vib_undamped.py</span></code> program to perform experiments with the extended
model.  Verify that the error is of order <span class="math notranslate nohighlight">\(\Delta t^2\)</span>.</p>
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong>
The code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">vib_verify_mms</span> <span class="kn">import</span> <span class="n">solver</span>

<span class="k">def</span> <span class="nf">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Found by solving mu&#39;&#39; + cu = F in Wolfram alpha.&quot;&quot;&quot;</span>
    <span class="n">k_1</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">k_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">V</span> <span class="o">-</span> <span class="n">A</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">/</span><span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">))</span><span class="o">*</span>\
                                        <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">m</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="o">+</span> \
           <span class="n">k_2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">m</span><span class="p">))</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> \
           <span class="n">k_1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">m</span><span class="p">))</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">convergence_rates</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">solver_function</span><span class="p">,</span> <span class="n">num_periods</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns N-1 empirical estimates of the convergence rate</span>
<span class="sd">    based on N simulations, where the time step is halved</span>
<span class="sd">    for each simulation.</span>
<span class="sd">    solver_function(I, V, F, c, m, dt, T, damping) solves</span>
<span class="sd">    each problem, where T is based on simulation for</span>
<span class="sd">    num_periods periods.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;External driving force&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

    <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.6</span><span class="p">,</span> <span class="mf">1.3</span>  <span class="c1"># just some chosen values</span>
    <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span>                  <span class="c1"># init. cond. u(0)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="mi">0</span>                  <span class="c1"># init. cond. u&#39;(0)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="mf">1.0</span>                <span class="c1"># amplitude of driving force</span>
    <span class="n">f</span> <span class="o">=</span> <span class="mf">1.0</span>                <span class="c1"># chosen frequency of driving force</span>
    <span class="n">damping</span> <span class="o">=</span> <span class="s1">&#39;zero&#39;</span>

    <span class="n">P</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">f</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">P</span><span class="o">/</span><span class="mi">30</span>              <span class="c1"># 30 time step per period 2*pi/w</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">num_periods</span>

    <span class="n">dt_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">E_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver_function</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">damping</span><span class="p">)</span>
        <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">u_e</span><span class="o">-</span><span class="n">u</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">dt_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">E_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">/</span><span class="mi">2</span>

    <span class="c1">#plt.plot(t, u, &#39;b--&#39;, t, u_e, &#39;r-&#39;); plt.grid(); plt.show()</span>

    <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">E_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">E_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span>
         <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span>

<span class="k">def</span> <span class="nf">test_convergence_rates</span><span class="p">():</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span>
        <span class="n">N</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">solver_function</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span>
        <span class="n">num_periods</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="c1"># Accept rate to 1 decimal place</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">test_convergence_rates</span><span class="p">()</span>
</pre></div>
</div>
<p>The output from the program shows that <span class="math notranslate nohighlight">\(r\)</span> approaches 2.</p>
<!-- --- end solution of exercise --- -->
<p>Filename: <code class="docutils literal notranslate"><span class="pre">vib_conv_rate</span></code>.</p>
<!-- --- end exercise --- -->
<!-- --- begin exercise --- -->
</div>
<div class="section" id="exercise-13-investigate-the-amplitude-errors-of-many-solvers">
<h2><span class="section-number">9.13. </span>Exercise 13: Investigate the amplitude errors of many solvers<a class="headerlink" href="#exercise-13-investigate-the-amplitude-errors-of-many-solvers" title="Permalink to this headline">¶</a></h2>
<div id="vib:exer:undamped:odespy"></div>
<p>Use the program <code class="docutils literal notranslate"><span class="pre">vib_undamped_odespy.py</span></code> from the section <a class="reference external" href="#vib:model2x2:compare">Comparison of schemes</a> (utilize the function <code class="docutils literal notranslate"><span class="pre">amplitudes</span></code>) to investigate
how well famous methods for 1st-order ODEs can preserve the amplitude of <span class="math notranslate nohighlight">\(u\)</span> in undamped
oscillations.  Test, for example, the 3rd- and 4th-order Runge-Kutta
methods (<code class="docutils literal notranslate"><span class="pre">RK3</span></code>, <code class="docutils literal notranslate"><span class="pre">RK4</span></code>), the Crank-Nicolson method (<code class="docutils literal notranslate"><span class="pre">CrankNicolson</span></code>),
the 2nd- and 3rd-order Adams-Bashforth methods (<code class="docutils literal notranslate"><span class="pre">AdamsBashforth2</span></code>,
<code class="docutils literal notranslate"><span class="pre">AdamsBashforth3</span></code>), and a 2nd-order Backwards scheme
(<code class="docutils literal notranslate"><span class="pre">Backward2Step</span></code>).  The relevant governing equations are listed in
the beginning of the section <a class="reference external" href="#vib:model2x2">Alternative schemes based on 1st-order equations</a>.</p>
<p>Running the code, we get the plots seen in <a class="reference external" href="#vib:exer:fig:ampl_RK34">Figure</a>,
<a class="reference external" href="#vib:exer:fig:ampl_CNB2">vib:exer:fig:ampl_CNB2</a>, and <a class="reference external" href="#vib:exer:fig:ampl_AB">vib:exer:fig:ampl_AB</a>. They
show that <code class="docutils literal notranslate"><span class="pre">RK4</span></code> is superior to the others, but that also <code class="docutils literal notranslate"><span class="pre">CrankNicolson</span></code> performs well. In fact, with <code class="docutils literal notranslate"><span class="pre">RK4</span></code> the amplitude changes by less than <span class="math notranslate nohighlight">\(0.1\)</span> per cent over the interval.</p>
<!-- dom:FIGURE: [fig-vib/Amplitudes_RK3_RK4.png, width=600 frac=1.0] The amplitude as it changes over 100 periods for RK3 and RK4. <div id="vib:exer:fig:ampl_RK34"></div> -->
<!-- begin figure -->
<div id="vib:exer:fig:ampl_RK34"></div>
<p>The amplitude as it changes over 100 periods for RK3 and RK4.</p>
<img src="fig-vib/Amplitudes_RK3_RK4.png" width=600>
<!-- end figure -->
<!-- dom:FIGURE: [fig-vib/Amplitudes_CrankNicolson_Backward2Step.png, width=600 frac=1.0] The amplitude as it changes over 100 periods for Crank-Nicolson and Backward 2 step. <div id="vib:exer:fig:ampl_CNB2"></div> -->
<!-- begin figure -->
<div id="vib:exer:fig:ampl_CNB2"></div>
<p>The amplitude as it changes over 100 periods for Crank-Nicolson and Backward 2 step.</p>
<img src="fig-vib/Amplitudes_CrankNicolson_Backward2Step.png" width=600>
<!-- end figure -->
<!-- dom:FIGURE: [fig-vib/Amplitudes_AdamsBashforth2_AdamsBashforth3.png, width=600 frac=1.0] The amplitude as it changes over 100 periods for Adams-Bashforth 2 and 3. <div id="vib:exer:fig:ampl_AB"></div> -->
<!-- begin figure -->
<div id="vib:exer:fig:ampl_AB"></div>
<p>The amplitude as it changes over 100 periods for Adams-Bashforth 2 and 3.</p>
<img src="fig-vib/Amplitudes_AdamsBashforth2_AdamsBashforth3.png" width=600>
<!-- end figure -->
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong>
We modify the proposed code to the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">scitools.std</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="c1">#import matplotlib.pyplot as plt</span>
<span class="kn">from</span> <span class="nn">vib_empirical_analysis</span> <span class="kn">import</span> <span class="n">minmax</span><span class="p">,</span> <span class="n">amplitudes</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">odespy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># v, u numbering for EulerCromer to work well</span>
    <span class="n">v</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">u</span>  <span class="c1"># u is array of length 2 holding our [v, u]</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">-</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">run_solvers_and_check_amplitudes</span><span class="p">(</span><span class="n">solvers</span><span class="p">,</span> <span class="n">timesteps_per_period</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                                     <span class="n">num_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">):</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>  <span class="c1"># duration of one period</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">P</span><span class="o">/</span><span class="n">timesteps_per_period</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="n">num_periods</span><span class="o">*</span><span class="n">timesteps_per_period</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span>
    <span class="n">t_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">file_name</span> <span class="o">=</span> <span class="s1">&#39;Amplitudes&#39;</span>   <span class="c1"># initialize filename for plot</span>
    <span class="k">for</span> <span class="n">solver</span> <span class="ow">in</span> <span class="n">solvers</span><span class="p">:</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">f_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="n">w</span><span class="p">})</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">I</span><span class="p">])</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">t_mesh</span><span class="p">)</span>

        <span class="n">solver_name</span> <span class="o">=</span> \
               <span class="s1">&#39;CrankNicolson&#39;</span> <span class="k">if</span> <span class="n">solver</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> \
               <span class="s1">&#39;MidpointImplicit&#39;</span> <span class="k">else</span> <span class="n">solver</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">file_name</span> <span class="o">=</span> <span class="n">file_name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">solver_name</span>

        <span class="n">minima</span><span class="p">,</span> <span class="n">maxima</span> <span class="o">=</span> <span class="n">minmax</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">amplitudes</span><span class="p">(</span><span class="n">minima</span><span class="p">,</span> <span class="n">maxima</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)),</span> <span class="n">a</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">solver_name</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s1">&#39;on&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Number of periods&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude (absolute value)&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">file_name</span> <span class="o">+</span> <span class="s1">&#39;.png&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">file_name</span> <span class="o">+</span> <span class="s1">&#39;.pdf&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="c1"># Define different sets of experiments</span>
<span class="n">solvers_CNB2</span> <span class="o">=</span> <span class="p">[</span><span class="n">odespy</span><span class="o">.</span><span class="n">CrankNicolson</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nonlinear_solver</span><span class="o">=</span><span class="s1">&#39;Newton&#39;</span><span class="p">),</span>
                <span class="n">odespy</span><span class="o">.</span><span class="n">Backward2Step</span><span class="p">(</span><span class="n">f</span><span class="p">)]</span>
<span class="n">solvers_RK34</span> <span class="o">=</span> <span class="p">[</span><span class="n">odespy</span><span class="o">.</span><span class="n">RK3</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> 
                <span class="n">odespy</span><span class="o">.</span><span class="n">RK4</span><span class="p">(</span><span class="n">f</span><span class="p">)]</span>
<span class="n">solvers_AB</span> <span class="o">=</span> <span class="p">[</span><span class="n">odespy</span><span class="o">.</span><span class="n">AdamsBashforth2</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> 
              <span class="n">odespy</span><span class="o">.</span><span class="n">AdamsBashforth3</span><span class="p">(</span><span class="n">f</span><span class="p">)]</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># Default values</span>
    <span class="n">timesteps_per_period</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="n">solver_collection</span> <span class="o">=</span> <span class="s1">&#39;CNB2&#39;</span>
    <span class="n">num_periods</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="c1"># Override from command line</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Example: python vib_undamped_odespy.py 30 RK34 50</span>
        <span class="n">timesteps_per_period</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">solver_collection</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">num_periods</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
        <span class="k">pass</span> <span class="c1"># default values are ok</span>
    <span class="n">solvers</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;solvers_&#39;</span> <span class="o">+</span> <span class="n">solver_collection</span><span class="p">)</span>  <span class="c1"># list of solvers</span>
    <span class="n">run_solvers_and_check_amplitudes</span><span class="p">(</span><span class="n">solvers</span><span class="p">,</span>
                                     <span class="n">timesteps_per_period</span><span class="p">,</span>
                                     <span class="n">num_periods</span><span class="p">)</span>
</pre></div>
</div>
<!-- --- end solution of exercise --- -->
<p>Filename: <code class="docutils literal notranslate"><span class="pre">vib_amplitude_errors</span></code>.</p>
<!-- --- end exercise --- -->
<!-- --- begin exercise --- -->
</div>
<div class="section" id="problem-14-minimize-memory-usage-of-a-simple-vibration-solver">
<h2><span class="section-number">9.14. </span>Problem 14: Minimize memory usage of a simple vibration solver<a class="headerlink" href="#problem-14-minimize-memory-usage-of-a-simple-vibration-solver" title="Permalink to this headline">¶</a></h2>
<div id="vib:exer:memsave0"></div>
<p>We consider the model problem <span class="math notranslate nohighlight">\(u''+\omega^2 u = 0\)</span>, <span class="math notranslate nohighlight">\(u(0)=I\)</span>, <span class="math notranslate nohighlight">\(u'(0)=V\)</span>,
solved by a second-order finite difference scheme. A standard implementation
typically employs an array <code class="docutils literal notranslate"><span class="pre">u</span></code> for storing all the <span class="math notranslate nohighlight">\(u^n\)</span> values. However,
at some time level <code class="docutils literal notranslate"><span class="pre">n+1</span></code> where we want to compute <code class="docutils literal notranslate"><span class="pre">u[n+1]</span></code>, all we need
of previous <code class="docutils literal notranslate"><span class="pre">u</span></code> values are from level <code class="docutils literal notranslate"><span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">n-1</span></code>. We can therefore avoid
storing the entire array <code class="docutils literal notranslate"><span class="pre">u</span></code>, and instead work with <code class="docutils literal notranslate"><span class="pre">u[n+1]</span></code>, <code class="docutils literal notranslate"><span class="pre">u[n],</span></code>
and <code class="docutils literal notranslate"><span class="pre">u[n-1]</span></code>, named as <code class="docutils literal notranslate"><span class="pre">u</span></code>, <code class="docutils literal notranslate"><span class="pre">u_n</span></code>, <code class="docutils literal notranslate"><span class="pre">u_nmp1</span></code>, for instance. Another
possible naming convention is <code class="docutils literal notranslate"><span class="pre">u</span></code>, <code class="docutils literal notranslate"><span class="pre">u_n[0]</span></code>, <code class="docutils literal notranslate"><span class="pre">u_n[-1]</span></code>.
Store the solution in a file
for later visualization. Make a test function that verifies the implementation
by comparing with the another code for the same problem.</p>
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong>
The modified solver function needs more manual steps initially, and it needs
shuffling of the <code class="docutils literal notranslate"><span class="pre">u_n</span></code> and <code class="docutils literal notranslate"><span class="pre">u_nm1</span></code> variables at each time  level. Otherwise
it is very similar to the previous <code class="docutils literal notranslate"><span class="pre">solver</span></code> function with an array <code class="docutils literal notranslate"><span class="pre">u</span></code> for
the entire mesh function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># NBVAL_SKIP</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">solver_memsave</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;tmp.dat&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    As vib_undamped.solver, but store only the last three</span>
<span class="sd">    u values in the implementation. The solution is written to</span>
<span class="sd">    file `tmp_memsave.dat`.</span>
<span class="sd">    Solve u&#39;&#39; + w**2*u = 0 for t in (0,T], u(0)=I and u&#39;(0)=0,</span>
<span class="sd">    by a central finite difference method with time step dt.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">outfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>

    <span class="n">u_n</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%20.12f</span><span class="s1"> </span><span class="si">%20.12f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">u_n</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">u_n</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u_n</span>
    <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%20.12f</span><span class="s1"> </span><span class="si">%20.12f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span>
    <span class="n">u_nm1</span> <span class="o">=</span> <span class="n">u_n</span>
    <span class="n">u_n</span> <span class="o">=</span> <span class="n">u</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_n</span> <span class="o">-</span> <span class="n">u_nm1</span> <span class="o">-</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u_n</span>
        <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%20.12f</span><span class="s1"> </span><span class="si">%20.12f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">u</span><span class="p">))</span>
        <span class="n">u_nm1</span> <span class="o">=</span> <span class="n">u_n</span>
        <span class="n">u_n</span> <span class="o">=</span> <span class="n">u</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
</div>
</div>
<p>Verification can be done by comparing with the <code class="docutils literal notranslate"><span class="pre">solver</span></code> function in
the <code class="docutils literal notranslate"><span class="pre">vib_undamped</span></code> module. Note that to compare both time series, we need
to load the data written to file in <code class="docutils literal notranslate"><span class="pre">solver_memsave</span></code> back in memory again.
For this purpose, we can use the <code class="docutils literal notranslate"><span class="pre">numpy.loadtxt</span></code> function, which reads
tabular data and returns them as a table <code class="docutils literal notranslate"><span class="pre">data</span></code>. Our interest is in the
second column of the data (the <code class="docutils literal notranslate"><span class="pre">u</span></code> values).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># NBVAL_SKIP</span>
<span class="k">def</span> <span class="nf">test_solver_memsave</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">vib_undamped</span> <span class="kn">import</span> <span class="n">solver</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">solver_memsave</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
    <span class="n">u_expected</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">solver</span>        <span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s1">&#39;tmp.dat&#39;</span><span class="p">)</span>
    <span class="n">u_computed</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_expected</span> <span class="o">-</span> <span class="n">u_computed</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="mf">5E-13</span><span class="p">,</span> <span class="n">diff</span>
</pre></div>
</div>
</div>
</div>
<!-- --- end solution of exercise --- -->
<p>Filename: <code class="docutils literal notranslate"><span class="pre">vib_memsave0</span></code>.</p>
<!-- --- end exercise --- -->
<!-- --- begin exercise --- -->
</div>
<div class="section" id="problem-15-minimize-memory-usage-of-a-general-vibration-solver">
<h2><span class="section-number">9.15. </span>Problem 15: Minimize memory usage of a general vibration solver<a class="headerlink" href="#problem-15-minimize-memory-usage-of-a-general-vibration-solver" title="Permalink to this headline">¶</a></h2>
<div id="vib:exer:memsave"></div>
<p>The program <span class="xref myst"><code class="docutils literal notranslate"><span class="pre">vib.py</span></code></span> stores the complete
solution <span class="math notranslate nohighlight">\(u^0,u^1,\ldots,u^{N_t}\)</span> in memory, which is convenient for
later plotting.  Make a memory minimizing version of this program
where only the last three <span class="math notranslate nohighlight">\(u^{n+1}\)</span>, <span class="math notranslate nohighlight">\(u^n\)</span>, and <span class="math notranslate nohighlight">\(u^{n-1}\)</span> values are
stored in memory under the names <code class="docutils literal notranslate"><span class="pre">u</span></code>, <code class="docutils literal notranslate"><span class="pre">u_n</span></code>, and <code class="docutils literal notranslate"><span class="pre">u_nm1</span></code> (this is the
naming convention used in this book).
Write each computed <span class="math notranslate nohighlight">\((t_{n+1}, u^{n+1})\)</span> pair to
file.  Visualize the data in the file (a cool solution is to read one
line at a time and plot the <span class="math notranslate nohighlight">\(u\)</span> value using the line-by-line plotter
in the <code class="docutils literal notranslate"><span class="pre">visualize_front_ascii</span></code> function - this technique makes it
trivial to visualize very long time simulations).</p>
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong>
Here is the complete program:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scitools.std</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">solve_and_store</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span>
                    <span class="n">F</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve m*u&#39;&#39; + f(u&#39;) + s(u) = F(t) for t in (0,T], u(0)=I and</span>
<span class="sd">    u&#39;(0)=V, by a central finite difference method with time step</span>
<span class="sd">    dt. If damping is &#39;linear&#39;, f(u&#39;)=b*u, while if damping is</span>
<span class="sd">    &#39;quadratic&#39;, f(u&#39;)=b*u&#39;*abs(u&#39;). F(t) and s(u) are Python</span>
<span class="sd">    functions. The solution is written to file (filename).</span>
<span class="sd">    Naming convention: we use the name u for the new solution</span>
<span class="sd">    to be computed, u_n for the solution one time step prior to</span>
<span class="sd">    that and u_nm1 for the solution two time steps prior to that.</span>
<span class="sd">    Returns min and max u values needed for subsequent plotting.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="c1"># avoid integer div.</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">outfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Time          Position</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">u_nm1</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">u_min</span> <span class="o">=</span> <span class="n">u_max</span> <span class="o">=</span> <span class="n">u_nm1</span>
    <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%6.3f</span><span class="s1">         </span><span class="si">%7.5f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">0</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">u_nm1</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">damping</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
        <span class="n">u_n</span> <span class="o">=</span> <span class="n">u_nm1</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span> <span class="o">+</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="n">V</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">u_nm1</span><span class="p">)</span> <span class="o">+</span> <span class="n">F</span><span class="p">(</span><span class="mi">0</span><span class="o">*</span><span class="n">dt</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">damping</span> <span class="o">==</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">:</span>
        <span class="n">u_n</span> <span class="o">=</span> <span class="n">u_nm1</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span> <span class="o">+</span> \
               <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="n">V</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">u_nm1</span><span class="p">)</span> <span class="o">+</span> <span class="n">F</span><span class="p">(</span><span class="mi">0</span><span class="o">*</span><span class="n">dt</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">u_n</span> <span class="o">&lt;</span> <span class="n">u_nm1</span><span class="p">:</span>
        <span class="n">u_min</span> <span class="o">=</span> <span class="n">u_n</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># either equal or u_n &gt; u_nm1</span>
        <span class="n">u_max</span> <span class="o">=</span> <span class="n">u_n</span>
    <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%6.3f</span><span class="s1">         </span><span class="si">%7.5f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">u_n</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="c1"># compute  solution at next time step</span>
        <span class="k">if</span> <span class="n">damping</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">u_n</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="n">u_nm1</span> <span class="o">+</span>
                <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">u_n</span><span class="p">)))</span><span class="o">/</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">damping</span> <span class="o">==</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">u_n</span> <span class="o">-</span> <span class="n">m</span><span class="o">*</span><span class="n">u_nm1</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">u_n</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">u_n</span> <span class="o">-</span> <span class="n">u_nm1</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">u_n</span><span class="p">)))</span><span class="o">/</span>\
                <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">u_n</span> <span class="o">-</span> <span class="n">u_nm1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="n">u_min</span><span class="p">:</span>
            <span class="n">u_min</span> <span class="o">=</span> <span class="n">u</span>
        <span class="k">elif</span> <span class="n">u</span> <span class="o">&gt;</span> <span class="n">u_max</span><span class="p">:</span>
            <span class="n">u_max</span> <span class="o">=</span> <span class="n">u</span>

        <span class="c1"># write solution to file</span>
        <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%6.3f</span><span class="s1">         </span><span class="si">%7.5f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span>
        <span class="c1"># switch references before next step</span>
        <span class="n">u_nm1</span><span class="p">,</span> <span class="n">u_n</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">u_n</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_nm1</span>

    <span class="n">outfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">u_min</span><span class="p">,</span> <span class="n">u_max</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">argparse</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--I&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--V&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--m&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--b&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--s&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--F&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--dt&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--T&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--window_width&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">30.</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Number of periods in a window&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--damping&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--savefig&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">)</span>
    <span class="c1"># Hack to allow --SCITOOLS options</span>
    <span class="c1"># (scitools.std reads this argument at import)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--SCITOOLS_easyviz_backend&#39;</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="s1">&#39;matplotlib&#39;</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
    <span class="kn">from</span> <span class="nn">scitools.std</span> <span class="kn">import</span> <span class="n">StringFunction</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">StringFunction</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">independent_variable</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">StringFunction</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="n">independent_variable</span><span class="o">=</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">window_width</span><span class="p">,</span> <span class="n">savefig</span><span class="p">,</span> <span class="n">damping</span> <span class="o">=</span> \
       <span class="n">a</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">window_width</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">savefig</span><span class="p">,</span> \
       <span class="n">a</span><span class="o">.</span><span class="n">damping</span>

    <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;vibration_sim.dat&#39;</span>
    <span class="n">u_min</span><span class="p">,</span> <span class="n">u_max</span> <span class="o">=</span> <span class="n">solve_and_store</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span>
                                   <span class="n">F</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">damping</span><span class="p">)</span>

    <span class="n">read_and_plot</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">u_min</span><span class="p">,</span> <span class="n">u_max</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">read_and_plot</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">u_min</span><span class="p">,</span> <span class="n">u_max</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read file and plot u vs t line by line in a</span>
<span class="sd">    terminal window (only using ascii characters).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scitools.avplotter</span> <span class="kn">import</span> <span class="n">Plotter</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">umin</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">u_min</span><span class="p">;</span>  <span class="n">umax</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">u_max</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Plotter</span><span class="p">(</span><span class="n">ymin</span><span class="o">=</span><span class="n">umin</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="n">umax</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="s1">&#39;+o&#39;</span><span class="p">)</span>
    <span class="n">fps</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">infile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>

    <span class="c1"># read and treat one line at a time</span>
    <span class="n">infile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>   <span class="c1"># skip header line</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">infile</span><span class="p">:</span>
        <span class="n">time_and_pos</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>  <span class="c1"># gives list with 2 elements</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">time_and_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">u</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">time_and_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1">#print &#39;time: %g   position: %g&#39; % (time, pos)</span>
        <span class="nb">print</span> <span class="n">p</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">),</span> <span class="s1">&#39;</span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">fps</span><span class="p">))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<!-- --- end solution of exercise --- -->
<p>Filename: <code class="docutils literal notranslate"><span class="pre">vib_memsave</span></code>.</p>
<!-- --- end exercise --- -->
<!-- --- begin exercise --- -->
</div>
<div class="section" id="exercise-16-implement-the-euler-cromer-scheme-for-the-generalized-model">
<h2><span class="section-number">9.16. </span>Exercise 16: Implement the Euler-Cromer scheme for the generalized model<a class="headerlink" href="#exercise-16-implement-the-euler-cromer-scheme-for-the-generalized-model" title="Permalink to this headline">¶</a></h2>
<div id="vib:exer:EC_vs_centered"></div>
<p>We consider the generalized model problem</p>
<div class="math notranslate nohighlight">
\[
mu'' + f(u') + s(u) = F(t),\quad u(0)=I,\ u'(0)=V\thinspace .
\]</div>
<p><strong>a)</strong>
Implement the Euler-Cromer method from the section <a class="reference external" href="#vib:ode2:EulerCromer">vib:ode2:EulerCromer</a>.</p>
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong>
A suitable function is</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve m*u&#39;&#39; + f(u&#39;) + s(u) = F(t) for t in (0,T], u(0)=I,</span>
<span class="sd">    u&#39;(0)=V by an Euler-Cromer method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">b</span><span class="o">*</span><span class="n">v</span> <span class="k">if</span> <span class="n">damping</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span> <span class="k">else</span> <span class="n">b</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">v</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">V</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1">#print &#39;F=%g, s=%g, f=%g, v_prev=%g&#39; % (F(t[n]), s(u[n]), f(v[n]), v[n])</span>
        <span class="c1">#print &#39;v[%d]=%g u[%d]=%g&#39; % (n+1,v[n+1],n+1,u[n+1])</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<!-- --- end solution of exercise --- -->
<p><strong>b)</strong>
We expect the Euler-Cromer method to have first-order convergence rate.
Make a unit test based on this expectation.</p>
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong>
We may use SymPy to derive a problem based on a manufactured solution
<span class="math notranslate nohighlight">\(u=3\cos t\)</span>. Then we may run some <span class="math notranslate nohighlight">\(\Delta t\)</span> values, compute the error
divided by <span class="math notranslate nohighlight">\(\Delta t\)</span>, and check that this ratio remains approximately
constant. (An alternative is to compute true convergence rates and check
that they are close to unity.)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_solver</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check 1st order convergence rate.&quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">s</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span>
    <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">b</span><span class="o">*</span><span class="n">v</span>

    <span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="nn">sym</span>
    <span class="k">def</span> <span class="nf">ode</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return source F(t) in ODE for given manufactured u.&quot;&quot;&quot;</span>
        <span class="nb">print</span> <span class="s1">&#39;ode:&#39;</span><span class="p">,</span> <span class="n">m</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">t</span><span class="p">)),</span> <span class="n">s</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">m</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">t</span><span class="p">))</span> <span class="o">+</span> <span class="n">s</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">ode</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
    <span class="nb">print</span> <span class="s1">&#39;F:&#39;</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="s1">&#39;u:&#39;</span><span class="p">,</span> <span class="n">u</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">t</span><span class="p">],</span> <span class="n">F</span><span class="p">,</span> <span class="n">modules</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="n">u_exact</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">t</span><span class="p">],</span> <span class="n">u</span><span class="p">,</span> <span class="n">modules</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nb">print</span> <span class="s1">&#39;V:&#39;</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="s1">&#39;I:&#39;</span><span class="p">,</span> <span class="n">I</span>

    <span class="c1"># Numerical parameters</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>
    <span class="n">dt_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">P</span><span class="o">/</span><span class="mi">20</span><span class="p">,</span> <span class="n">P</span><span class="o">/</span><span class="mi">40</span><span class="p">,</span> <span class="n">P</span><span class="o">/</span><span class="mi">80</span><span class="p">,</span> <span class="n">P</span><span class="o">/</span><span class="mi">160</span><span class="p">,</span> <span class="n">P</span><span class="o">/</span><span class="mi">320</span><span class="p">]</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">8</span><span class="o">*</span><span class="n">P</span>
    <span class="n">error_vs_dt</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">dt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dt_values</span><span class="p">):</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">error_vs_dt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">error</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">error_vs_dt</span><span class="p">)):</span>
        <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">error_vs_dt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span>
                   <span class="n">error_vs_dt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.1</span>
</pre></div>
</div>
<!-- --- end solution of exercise --- -->
<p><strong>c)</strong>
Consider a system with <span class="math notranslate nohighlight">\(m=4\)</span>, <span class="math notranslate nohighlight">\(f(v)=b|v|v\)</span>, <span class="math notranslate nohighlight">\(b=0.2\)</span>, <span class="math notranslate nohighlight">\(s=2u\)</span>, <span class="math notranslate nohighlight">\(F=0\)</span>.
Compute the solution using the centered difference scheme
from the section <a class="reference external" href="#vib:ode2:fdm:flin">vib:ode2:fdm:flin</a> and the Euler-Cromer scheme
for the longest possible time step <span class="math notranslate nohighlight">\(\Delta t\)</span>. We can use the
result from the case without damping, i.e., the largest <span class="math notranslate nohighlight">\(\Delta t= 2/\omega\)</span>,
<span class="math notranslate nohighlight">\(\omega\approx
\sqrt{0.5}\)</span> in this case, but since <span class="math notranslate nohighlight">\(b\)</span> will modify the frequency, we
take the longest possible time step as a safety factor 0.9 times <span class="math notranslate nohighlight">\(2/\omega\)</span>.
Refine <span class="math notranslate nohighlight">\(\Delta t\)</span> three times by a factor of two and compare the
two curves.</p>
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong>
We rely on the module <code class="docutils literal notranslate"><span class="pre">vib</span></code> for the implementation of the method
from the section <a class="reference external" href="#vib:ode2:fdm:flin">vib:ode2:fdm:flin</a>. A suitable function for making
the comparisons is then</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># NBVAL_SKIP</span>
<span class="k">def</span> <span class="nf">demo</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Demonstrate difference between Euler-Cromer and the</span>
<span class="sd">    scheme for the corresponding 2nd-order ODE.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">I</span> <span class="o">=</span> <span class="mf">1.2</span><span class="p">;</span> <span class="n">V</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">;</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">0.2</span>
    <span class="n">s</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span>
    <span class="n">F</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">0</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>   <span class="c1"># approx freq</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.9</span><span class="o">*</span><span class="mi">2</span><span class="o">/</span><span class="n">w</span>  <span class="c1"># longest possible time step</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">P</span>
    <span class="kn">from</span> <span class="nn">vib</span> <span class="kn">import</span> <span class="n">solver</span> <span class="k">as</span> <span class="n">solver2</span>
    <span class="kn">import</span> <span class="nn">scitools.std</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">u2</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">solver2</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">)</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s1">&#39;r-&#39;</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;Euler-Cromer&#39;</span><span class="p">,</span> <span class="s1">&#39;centered scheme&#39;</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;dt=</span><span class="si">%.3g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">raw_input</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;tmp_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">k</span> <span class="o">+</span> <span class="s1">&#39;.png&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;tmp_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">k</span> <span class="o">+</span> <span class="s1">&#39;.pdf&#39;</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">/=</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<!-- --- end solution of exercise --- -->
<p>Filename: <code class="docutils literal notranslate"><span class="pre">vib_EulerCromer</span></code>.</p>
<!-- --- end exercise --- -->
<!-- --- begin exercise --- -->
</div>
<div class="section" id="problem-17-interpret-d-td-t-u-n-as-a-forward-backward-difference">
<h2><span class="section-number">9.17. </span>Problem 17: Interpret <span class="math notranslate nohighlight">\([D_tD_t u]^n\)</span> as a forward-backward difference<a class="headerlink" href="#problem-17-interpret-d-td-t-u-n-as-a-forward-backward-difference" title="Permalink to this headline">¶</a></h2>
<div id="vib:exer:DtDt:asDthinspace .Dtm"></div>
<p>Show that the difference <span class="math notranslate nohighlight">\([D_t D_tu]^n\)</span> is equal to <span class="math notranslate nohighlight">\([D_t^+D_t^-u]^n\)</span>
and <span class="math notranslate nohighlight">\(D_t^-D_t^+u]^n\)</span>. That is, instead of applying a centered difference
twice one can alternatively apply a mixture of forward and backward
differences.</p>
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong></p>
<div class="math notranslate nohighlight">
\[
[D_t^+D_t^-u]^n = [D_t^+\left(\frac{u^n - u^{n-1}}{\Delta t}\right)]^n \nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
= [\left(\frac{u^{n+1} - u^n}{\Delta t}\right) - \left(\frac{u^n - u^{n-1}}{\Delta t}\right)]^n  \nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
= \frac{u^{n+1}-2u^n+u^{n-1}}{\Delta t^2} \nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
= [D_t D_tu]^n. \nonumber
\]</div>
<p>Similarly, we get that</p>
<div class="math notranslate nohighlight">
\[
[D_t^-D_t^+u]^n = [D_t^-\left(\frac{u^{n+1} - u^n}{\Delta t}\right)]^n \nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
= [\left(\frac{u^{n+1} - u^n}{\Delta t}\right) - \left(\frac{u^n - u^{n-1}}{\Delta t}\right)]^n  \nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
= \frac{u^{n+1}-2u^n+u^{n-1}}{\Delta t^2} \nonumber
\]</div>
<div class="math notranslate nohighlight">
\[
= [D_t D_tu]^n. \nonumber
\]</div>
<!-- --- end solution of exercise --- -->
<p>Filename: <code class="docutils literal notranslate"><span class="pre">vib_DtDt_fw_bw</span></code>.</p>
<!-- --- end exercise --- -->
<!-- --- begin exercise --- -->
</div>
<div class="section" id="exercise-18-analysis-of-the-euler-cromer-scheme">
<h2><span class="section-number">9.18. </span>Exercise 18: Analysis of the Euler-Cromer scheme<a class="headerlink" href="#exercise-18-analysis-of-the-euler-cromer-scheme" title="Permalink to this headline">¶</a></h2>
<div id="vib:exer:EulerCromer:analysis"></div>
<p>The Euler-Cromer scheme for the model problem
<span class="math notranslate nohighlight">\(u^{\prime\prime} + \omega^2 u =0\)</span>, <span class="math notranslate nohighlight">\(u(0)=I\)</span>, <span class="math notranslate nohighlight">\(u^{\prime}(0)=0\)</span>, is given in
(<a class="reference external" href="#vib:model2x2:EulerCromer:ueq1b">55</a>)-(<a class="reference external" href="#vib:model2x2:EulerCromer:veq1b">54</a>).
Find the exact discrete solutions of this scheme and show that the solution
for <span class="math notranslate nohighlight">\(u^n\)</span> coincides with that found in the section <a class="reference external" href="#vib:ode1:analysis">Analysis of the numerical scheme</a>.</p>
<!-- --- begin hint in exercise --- -->
<p><strong>Hint.</strong>
Use an “ansatz” <span class="math notranslate nohighlight">\(u^n=I\exp{(i\tilde\omega\Delta t\,n)}\)</span> and
<span class="math notranslate nohighlight">\(v^n=qu^n\)</span>, where <span class="math notranslate nohighlight">\(\tilde\omega\)</span> and <span class="math notranslate nohighlight">\(q\)</span> are unknown parameters. The
following formula is handy:</p>
<div class="math notranslate nohighlight">
\[
\e^{i\tilde\omega\Delta t} + e^{i\tilde\omega(-\Delta t)} - 2
= 2\left(\cosh(i\tilde\omega\Delta t) -1 \right)
=-4\sin^2(\frac{\tilde\omega\Delta t}{2})\thinspace .
\]</div>
<!-- --- end hint in exercise --- -->
<!-- --- begin solution of exercise --- -->
<p><strong>Solution.</strong>
We follow the ideas in the section <a class="reference external" href="#vib:ode1:analysis">Analysis of the numerical scheme</a>. Inserting
<span class="math notranslate nohighlight">\(u^n=I\exp{(i\tilde\omega\Delta t\,n)}\)</span> and
<span class="math notranslate nohighlight">\(v^n=qu^n\)</span> in
(<a class="reference external" href="#vib:model2x2:EulerCromer:ueq1b">55</a>)-(<a class="reference external" href="#vib:model2x2:EulerCromer:veq1b">54</a>)
and dividing by <span class="math notranslate nohighlight">\(I\exp{(i\tilde\omega\Delta t\,n)}\)</span> gives</p>
<!-- Equation labels as ordinary links -->
<div id="vib:exer:EulerCromer:analysis:equ"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
q\exp{(i\tilde\omega\Delta t)} = q - \omega^2 \Delta t,
\label{vib:exer:EulerCromer:analysis:equ} \tag{73} 
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<div id="vib:exer:EulerCromer:analysis:eqv"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
\exp{(i\tilde\omega\Delta t)} = 1 + \Delta t\, q\exp{(i\tilde\omega\Delta t)}
\label{vib:exer:EulerCromer:analysis:eqv} \tag{74}\thinspace .
\end{equation}
\]</div>
<p>Solving (<a class="reference external" href="#vib:exer:EulerCromer:analysis:eqv">74</a>) with respect to <span class="math notranslate nohighlight">\(q\)</span> gives</p>
<div class="math notranslate nohighlight">
\[
q = \frac{1}{\Delta t}\left( 1 - \exp{(i\tilde\omega\Delta t)} \right)\thinspace .
\]</div>
<p>Inserting this expression for <span class="math notranslate nohighlight">\(q\)</span> in (<a class="reference external" href="#vib:exer:EulerCromer:analysis:equ">73</a>)
results in</p>
<div class="math notranslate nohighlight">
\[
\exp{(i\tilde\omega\Delta t)} + \exp{(-i\tilde\omega\Delta t)} -2
= - \omega^2\Delta t^2\thinspace .
\]</div>
<p>Using the relation
<span class="math notranslate nohighlight">\(\exp{(i\tilde\omega(\Delta t))} + \exp{(i\tilde\omega(-\Delta t))} - 2
= -4\sin^2(\frac{\tilde\omega\Delta t}{2})\)</span> gives</p>
<div class="math notranslate nohighlight">
\[
-4\sin^2(\frac{\tilde\omega\Delta t}{2}) = - \omega^2\Delta t^2,
\]</div>
<p>or after dividing by 4,</p>
<div class="math notranslate nohighlight">
\[
\sin^2(\frac{\tilde\omega\Delta t}{2}) = \left(\frac{1}{2}\omega\Delta t\right)^2,
\]</div>
<p>which is the same equation for <span class="math notranslate nohighlight">\(\tilde\omega\)</span> as found in
the section <a class="reference external" href="#vib:ode1:analysis">Analysis of the numerical scheme</a>, such that <span class="math notranslate nohighlight">\(\tilde\omega\)</span> is the
same. The accuracy, stability, and formula for the exact discrete solution
are then all the same as derived in the section <a class="reference external" href="#vib:ode1:analysis">Analysis of the numerical scheme</a>.</p>
<!-- This proves that the solution of the Euler-Cromer scheme -->
<!-- coincides -->
<!-- --- end solution of exercise --- -->
<!-- --- end exercise --- --></div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./notebooks/vib"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="../../index.html" title="previous page">Welcome to the Devito Book!</a>
    <a class='right-next' id="next-link" href="../wave/wave1D_fd1.html" title="next page"><span class="section-number">1. </span>Simulation of waves on a string</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By The Devito Project Community<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    <script src="../../_static/js/index.js"></script>
    
  </body>
</html>