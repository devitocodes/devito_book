
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Wave equations</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Finite Difference Computing with PDEs" href="index.html" />
    <link rel="next" title="Generalization: reflecting boundaries" href="._book006.html" />
    <link rel="prev" title="Applications of vibration models" href="._book004.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._book006.html" title="Generalization: reflecting boundaries"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._book004.html" title="Applications of vibration models"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with PDEs</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="wave-equations-1">
<span id="ch-wave"></span><h1>Wave equations<a class="headerlink" href="#wave-equations-1" title="Permalink to this headline">¶</a></h1>
<p>A very wide range of physical processes lead to wave motion, where
signals are propagated through a medium in space and time, normally
with little or no permanent movement of the medium itself.
The shape of the signals may undergo changes as they travel through
matter, but usually not so much that the signals cannot be recognized
at some later point in space and time.
Many types of wave motion can be described by the equation
<span class="math">\(u_{tt}=\nabla\cdot (c^2\nabla u) + f\)</span>, which we will solve
in the forthcoming text by finite difference methods.</p>
<div class="section" id="simulation-of-waves-on-a-string">
<span id="wave-string"></span><h2>Simulation of waves on a string<a class="headerlink" href="#simulation-of-waves-on-a-string" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-0"></span><p id="index-1">We begin our study of wave equations by simulating one-dimensional
waves on a string, say on a guitar or violin.
Let the string in the deformed state
coincide with the interval
<span class="math">\([0,L]\)</span> on the <span class="math">\(x\)</span> axis, and let <span class="math">\(u(x,t)\)</span> be the displacement at
time <span class="math">\(t\)</span> in the <span class="math">\(y\)</span> direction of a point initially at <span class="math">\(x\)</span>.
The displacement function <span class="math">\(u\)</span> is governed by the mathematical model</p>
<div class="math" id="eq-wave-pde1">
\[\tag{160}
\frac{\partial^2 u}{\partial t^2} =
    c^2 \frac{\partial^2 u}{\partial x^2}, \quad x\in (0,L),\ t\in (0,T]\]</div>
<div class="math" id="eq-wave-pde1-ic-u">
\[\tag{161}
u(x,0) = I(x), \quad x\in [0,L]\]</div>
<div class="math" id="eq-wave-pde1-ic-ut">
\[\tag{162}
\frac{\partial}{\partial t}u(x,0) = 0, \quad x\in [0,L]\]</div>
<div class="math" id="eq-wave-pde1-bc-0">
\[\tag{163}
u(0,t)  = 0, \quad  t\in (0,T]\]</div>
<div class="math" id="eq-wave-pde1-bc-l">
\[\tag{164}
u(L,t)  = 0, \quad  t\in (0,T]\]</div>
<p>The constant <span class="math">\(c\)</span> and the function <span class="math">\(I(x)\)</span> must be prescribed.</p>
<p>Equation <a class="reference internal" href="#eq-wave-pde1"><span class="std std-ref">(160)</span></a> is known as the one-dimensional
<em>wave equation</em>. Since this PDE contains a second-order derivative
in time, we need <em>two initial conditions</em>. The condition
<a class="reference internal" href="#eq-wave-pde1-ic-u"><span class="std std-ref">(161)</span></a> specifies
the initial shape of the string, <span class="math">\(I(x)\)</span>, and
<a class="reference internal" href="#eq-wave-pde1-ic-ut"><span class="std std-ref">(162)</span></a> expresses that the initial velocity of the
string is zero. In addition, PDEs need <em>boundary conditions</em>, given here as
<a class="reference internal" href="#eq-wave-pde1-bc-0"><span class="std std-ref">(163)</span></a> and <a class="reference internal" href="#eq-wave-pde1-bc-l"><span class="std std-ref">(164)</span></a>. These two
conditions specify that
the string is fixed at the ends, i.e., that the displacement <span class="math">\(u\)</span> is zero.</p>
<p>The solution <span class="math">\(u(x,t)\)</span> varies in space and time and describes waves that
move with velocity <span class="math">\(c\)</span> to the left and right.</p>
<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src="_static/mov-wave/guitar_C0.8/movie.webm" type='video/webm; codecs="vp8, vorbis"'>
    <source src="_static/mov-wave/guitar_C0.8/movie.ogg"  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em>Example of waves on a string.</em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script><p>Sometimes we will use a more compact notation for the partial derivatives
to save space:</p>
<div class="math" id="eq-auto59">
\[\tag{165}
u_t = \frac{\partial u}{\partial t}, \quad
    u_{tt} = \frac{\partial^2 u}{\partial t^2},\]</div>
<p>and similar expressions
for derivatives with respect to other variables. Then the
wave equation can be written compactly as <span class="math">\(u_{tt} = c^2u_{xx}\)</span>.</p>
<p id="index-2">The PDE problem <a class="reference internal" href="#eq-wave-pde1"><span class="std std-ref">(160)</span></a>-<a class="reference internal" href="#eq-wave-pde1-bc-l"><span class="std std-ref">(164)</span></a> will now be
discretized in space and time by a finite difference method.</p>
<div class="section" id="discretizing-the-domain">
<span id="wave-string-mesh"></span><span id="index-3"></span><h3>Discretizing the domain<a class="headerlink" href="#discretizing-the-domain" title="Permalink to this headline">¶</a></h3>
<p>The temporal domain <span class="math">\([0,T]\)</span> is represented by a finite number of mesh points</p>
<div class="math" id="eq-auto60">
\[\tag{166}
0 = t_0 &lt; t_1 &lt; t_2 &lt; \cdots &lt; t_{N_t-1} &lt; t_{N_t} = T {\thinspace .}\]</div>
<p>Similarly, the spatial domain <span class="math">\([0,L]\)</span> is replaced by a set of mesh points</p>
<div class="math" id="eq-auto61">
\[\tag{167}
0 = x_0 &lt; x_1 &lt; x_2 &lt; \cdots &lt; x_{N_x-1} &lt; x_{N_x} = L {\thinspace .}\]</div>
<p>One may view the mesh as two-dimensional in the <span class="math">\(x,t\)</span> plane, consisting
of points <span class="math">\((x_i, t_n)\)</span>, with <span class="math">\(i=0,\ldots,N_x\)</span> and <span class="math">\(n=0,\ldots,N_t\)</span>.</p>
<div class="section" id="uniform-meshes">
<h4>Uniform meshes<a class="headerlink" href="#uniform-meshes" title="Permalink to this headline">¶</a></h4>
<p>For uniformly distributed mesh points we can introduce the constant
mesh spacings <span class="math">\(\Delta t\)</span> and <span class="math">\(\Delta x\)</span>. We have that</p>
<div class="math" id="eq-auto62">
\[\tag{168}
x_i = i\Delta x,\ i=0,\ldots,N_x,\quad
    t_n = n\Delta t,\ n=0,\ldots,N_t{\thinspace .}\]</div>
<p>We also have that <span class="math">\(\Delta x = x_i-x_{i-1}\)</span>, <span class="math">\(i=1,\ldots,N_x\)</span>, and
<span class="math">\(\Delta t = t_n - t_{n-1}\)</span>, <span class="math">\(n=1,\ldots,N_t\)</span>. Figure <a class="reference internal" href="#wave-pde1-fig-mesh"><span class="std std-ref">Mesh in space and time. The circles show points connected in a finite difference equation</span></a>
displays a mesh in the <span class="math">\(x,t\)</span> plane with <span class="math">\(N_t=5\)</span>, <span class="math">\(N_x=5\)</span>, and constant
mesh spacings.</p>
</div>
</div>
<div class="section" id="the-discrete-solution">
<span id="wave-string-numerical-sol"></span><h3>The discrete solution<a class="headerlink" href="#the-discrete-solution" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-4"></span><p id="index-5">The solution <span class="math">\(u(x,t)\)</span> is sought at the mesh points. We introduce
the mesh function <span class="math">\(u_i^n\)</span>, which approximates the exact
solution at the
mesh point <span class="math">\((x_i,t_n)\)</span> for <span class="math">\(i=0,\ldots,N_x\)</span> and <span class="math">\(n=0,\ldots,N_t\)</span>.
Using the finite difference method, we shall
develop algebraic equations for computing the mesh function.</p>
</div>
<div class="section" id="fulfilling-the-equation-at-the-mesh-points">
<span id="wave-string-samplingpde"></span><h3>Fulfilling the equation at the mesh points<a class="headerlink" href="#fulfilling-the-equation-at-the-mesh-points" title="Permalink to this headline">¶</a></h3>
<p>In the finite difference method, we relax
the condition that <a class="reference internal" href="#eq-wave-pde1"><span class="std std-ref">(160)</span></a> holds at all points in
the space-time domain <span class="math">\((0,L)\times (0,T]\)</span> to the requirement that the PDE is
fulfilled at the <em>interior</em> mesh points only:</p>
<div class="math" id="eq-wave-pde1-step2">
\[\tag{169}
\frac{\partial^2}{\partial t^2} u(x_i, t_n) =
    c^2\frac{\partial^2}{\partial x^2} u(x_i, t_n),\]</div>
<p>for <span class="math">\(i=1,\ldots,N_x-1\)</span> and <span class="math">\(n=1,\ldots,N_t-1\)</span>. For <span class="math">\(n=0\)</span> we have
the initial conditions <span class="math">\(u=I(x)\)</span> and <span class="math">\(u_t=0\)</span>,
and at the boundaries <span class="math">\(i=0,N_x\)</span> we
have the boundary condition <span class="math">\(u=0\)</span>.</p>
</div>
<div class="section" id="replacing-derivatives-by-finite-differences">
<span id="wave-string-fd"></span><h3>Replacing derivatives by finite differences<a class="headerlink" href="#replacing-derivatives-by-finite-differences" title="Permalink to this headline">¶</a></h3>
<p>The second-order derivatives can be replaced by central
differences. The most widely used difference approximation of
the second-order derivative is</p>
<div class="math">
\[\frac{\partial^2}{\partial t^2}u(x_i,t_n)\approx
\frac{u_i^{n+1} - 2u_i^n + u^{n-1}_i}{\Delta t^2}{\thinspace .}\]</div>
<p>It is convenient to introduce the finite difference operator notation</p>
<div class="math">
\[[D_tD_t u]^n_i = \frac{u_i^{n+1} - 2u_i^n + u^{n-1}_i}{\Delta t^2}{\thinspace .}\]</div>
<p>A similar approximation of the second-order derivative in the <span class="math">\(x\)</span>
direction reads</p>
<div class="math">
\[\frac{\partial^2}{\partial x^2}u(x_i,t_n)\approx
\frac{u_{i+1}^{n} - 2u_i^n + u^{n}_{i-1}}{\Delta x^2} = [D_xD_x u]^n_i
{\thinspace .}\]</div>
<div class="section" id="algebraic-version-of-the-pde">
<h4>Algebraic version of the PDE<a class="headerlink" href="#algebraic-version-of-the-pde" title="Permalink to this headline">¶</a></h4>
<p>We can now replace the derivatives in <a class="reference internal" href="#eq-wave-pde1-step2"><span class="std std-ref">(169)</span></a>
and get</p>
<div class="math" id="eq-wave-pde1-step3b">
\[\tag{170}
\frac{u_i^{n+1} - 2u_i^n + u^{n-1}_i}{\Delta t^2} =
    c^2\frac{u_{i+1}^{n} - 2u_i^n + u^{n}_{i-1}}{\Delta x^2},\]</div>
<p>or written more compactly using the operator notation:</p>
<div class="math" id="eq-wave-pde1-step3a">
\[\tag{171}
[D_tD_t u = c^2 D_xD_x]^{n}_i
    {\thinspace .}\]</div>
</div>
<div class="section" id="interpretation-of-the-equation-as-a-stencil">
<h4>Interpretation of the equation as a stencil<a class="headerlink" href="#interpretation-of-the-equation-as-a-stencil" title="Permalink to this headline">¶</a></h4>
<p>A characteristic feature of <a class="reference internal" href="#eq-wave-pde1-step3b"><span class="std std-ref">(170)</span></a> is that it
involves <span class="math">\(u\)</span> values from neighboring points only: <span class="math">\(u_i^{n+1}\)</span>,
<span class="math">\(u^n_{i\pm 1}\)</span>, <span class="math">\(u^n_i\)</span>, and <span class="math">\(u^{n-1}_i\)</span>.  The circles in Figure
<a class="reference internal" href="#wave-pde1-fig-mesh"><span class="std std-ref">Mesh in space and time. The circles show points connected in a finite difference equation</span></a> illustrate such neighboring mesh points that
contribute to an algebraic equation. In this particular case, we have
sampled the PDE at the point <span class="math">\((2,2)\)</span> and constructed
<a class="reference internal" href="#eq-wave-pde1-step3b"><span class="std std-ref">(170)</span></a>, which then involves a coupling of <span class="math">\(u_nm1^1\)</span>,
<span class="math">\(u_n^2\)</span>, <span class="math">\(u_nm1^2\)</span>, <span class="math">\(u_3^2\)</span>, and <span class="math">\(u_nm1^3\)</span>.  The term <em>stencil</em> is often
used about the algebraic equation at a mesh point, and the geometry of
a typical stencil is illustrated in Figure
<a class="reference internal" href="#wave-pde1-fig-mesh"><span class="std std-ref">Mesh in space and time. The circles show points connected in a finite difference equation</span></a>. One also often refers to the algebraic
equations as <em>discrete equations</em>, <em>(finite) difference equations</em> or
a <em>finite difference scheme</em>.</p>
<div class="figure" id="id3">
<span id="wave-pde1-fig-mesh"></span><a class="reference internal image-reference" href="_images/stencil_n_interior.png"><img alt="_images/stencil_n_interior.png" src="_images/stencil_n_interior.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text"><em>Mesh in space and time. The circles show points connected in a finite difference equation</em></span></p>
</div>
</div>
<div class="section" id="algebraic-version-of-the-initial-conditions">
<h4>Algebraic version of the initial conditions<a class="headerlink" href="#algebraic-version-of-the-initial-conditions" title="Permalink to this headline">¶</a></h4>
<p>We also need to replace the derivative in the initial condition
<a class="reference internal" href="#eq-wave-pde1-ic-ut"><span class="std std-ref">(162)</span></a> by a finite difference approximation.
A centered difference of the type</p>
<div class="math">
\[\frac{\partial}{\partial t} u(x_i,t_0)\approx
\frac{u^1_i - u^{-1}_i}{2\Delta t} = [D_{2t} u]^0_i,\]</div>
<p>seems appropriate. Writing out this equation and ordering the terms give</p>
<div class="math" id="eq-wave-pde1-step3c">
\[\tag{172}
u^{-1}_i=u^{1}_i,\quad i=0,\ldots,N_x{\thinspace .}\]</div>
<p>The other initial condition can be computed by</p>
<div class="math">
\[u_i^0 = I(x_i),\quad i=0,\ldots,N_x{\thinspace .}\]</div>
</div>
</div>
<div class="section" id="formulating-a-recursive-algorithm">
<span id="wave-string-alg"></span><h3>Formulating a recursive algorithm<a class="headerlink" href="#formulating-a-recursive-algorithm" title="Permalink to this headline">¶</a></h3>
<p>We assume that <span class="math">\(u^n_i\)</span> and <span class="math">\(u^{n-1}_i\)</span> are available for
<span class="math">\(i=0,\ldots,N_x\)</span>.  The only unknown quantity in
<a class="reference internal" href="#eq-wave-pde1-step3b"><span class="std std-ref">(170)</span></a> is therefore <span class="math">\(u^{n+1}_i\)</span>, which we now can
solve for:</p>
<div class="math" id="eq-wave-pde1-step4">
\[\tag{173}
u^{n+1}_i = -u^{n-1}_i + 2u^n_i + C^2
    \left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right){\thinspace .}\]</div>
<p>We have here introduced the parameter</p>
<div class="math" id="eq-auto63">
\[\tag{174}
C = c\frac{\Delta t}{\Delta x},\]</div>
<p>known as the <em>Courant number</em>.</p>
<div class="admonition-math-c-is-the-key-parameter-in-the-discrete-wave-equation admonition">
<p class="first admonition-title"><span class="math">\(C\)</span> is the key parameter in the discrete wave equation</p>
<p class="last">We see that the discrete version of the PDE features only one
parameter, <span class="math">\(C\)</span>, which is therefore the key parameter, together with
<span class="math">\(N_x\)</span>, that governs the quality of the numerical solution (see the section <a class="reference internal" href="._book007.html#wave-pde1-analysis"><span class="std std-ref">Analysis of the difference equations</span></a> for details). Both the primary physical
parameter <span class="math">\(c\)</span> and the numerical parameters <span class="math">\(\Delta x\)</span> and <span class="math">\(\Delta t\)</span>
are lumped together in <span class="math">\(C\)</span>. Note that <span class="math">\(C\)</span> is a dimensionless
parameter.</p>
</div>
<p>Given that <span class="math">\(u^{n-1}_i\)</span> and <span class="math">\(u^n_i\)</span> are known for <span class="math">\(i=0,\ldots,N_x\)</span>,
we find new values at the next time level by applying the formula
<a class="reference internal" href="#eq-wave-pde1-step4"><span class="std std-ref">(173)</span></a> for <span class="math">\(i=1,\ldots,N_x-1\)</span>. Figure
<a class="reference internal" href="#wave-pde1-fig-mesh"><span class="std std-ref">Mesh in space and time. The circles show points connected in a finite difference equation</span></a> illustrates the points that are used to
compute <span class="math">\(u^3_2\)</span>. For the boundary points, <span class="math">\(i=0\)</span> and <span class="math">\(i=N_x\)</span>, we apply
the boundary conditions <span class="math">\(u_i^{n+1}=0\)</span>.</p>
<p>Even though sound reasoning leads up to
<a class="reference internal" href="#eq-wave-pde1-step4"><span class="std std-ref">(173)</span></a>, there is still a minor challenge with it that needs
to be resolved. Think of the very first computational step to be made.
The scheme <a class="reference internal" href="#eq-wave-pde1-step4"><span class="std std-ref">(173)</span></a> is supposed to start at <span class="math">\(n=1\)</span>, which means
that we compute <span class="math">\(u^2\)</span> from <span class="math">\(u^1\)</span> and <span class="math">\(u^0\)</span>. Unfortunately, we do not know the
value of <span class="math">\(u^1\)</span>, so how to proceed? A standard procedure in such cases is to
apply <a class="reference internal" href="#eq-wave-pde1-step4"><span class="std std-ref">(173)</span></a> also for <span class="math">\(n=0\)</span>. This immediately seems strange,
since it involves <span class="math">\(u^{-1}_i\)</span>, which is an undefined
quantity outside the time mesh (and the time domain). However, we can
use the initial condition <a class="reference internal" href="#eq-wave-pde1-step3c"><span class="std std-ref">(172)</span></a> in combination with
<a class="reference internal" href="#eq-wave-pde1-step4"><span class="std std-ref">(173)</span></a> when <span class="math">\(n=0\)</span> to eliminate <span class="math">\(u^{-1}_i\)</span> and
arrive at a special formula for <span class="math">\(u_i^1\)</span>:</p>
<div class="math" id="eq-wave-pde1-step4-1">
\[\tag{175}
u_i^1 = u^0_i - \frac{1}{2}
    C^2\left(u^{0}_{i+1}-2u^{0}_{i} + u^{0}_{i-1}\right)
    {\thinspace .}\]</div>
<p>Figure <a class="reference internal" href="#wave-pde1-fig-stencil-u1"><span class="std std-ref">Modified stencil for the first time step</span></a> illustrates how <a class="reference internal" href="#eq-wave-pde1-step4-1"><span class="std std-ref">(175)</span></a>
connects four instead of five points: <span class="math">\(u^1_2\)</span>, <span class="math">\(u_n^0\)</span>, <span class="math">\(u_nm1^0\)</span>, and <span class="math">\(u_3^0\)</span>.</p>
<div class="figure" id="id4">
<span id="wave-pde1-fig-stencil-u1"></span><a class="reference internal image-reference" href="_images/stencil_n0_interior.png"><img alt="_images/stencil_n0_interior.png" src="_images/stencil_n0_interior.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text"><em>Modified stencil for the first time step</em></span></p>
</div>
<p>We can now summarize the computational algorithm:</p>
<ol class="arabic simple">
<li>Compute <span class="math">\(u^0_i=I(x_i)\)</span> for <span class="math">\(i=0,\ldots,N_x\)</span></li>
<li>Compute <span class="math">\(u^1_i\)</span> by <a class="reference internal" href="#eq-wave-pde1-step4-1"><span class="std std-ref">(175)</span></a> and set <span class="math">\(u_i^1=0\)</span>
for the boundary points <span class="math">\(i=0\)</span> and <span class="math">\(i=N_x\)</span>, for <span class="math">\(n=1,2,\ldots,N-1\)</span>,</li>
<li>For each time level <span class="math">\(n=1,2,\ldots,N_t-1\)</span></li>
</ol>
<blockquote>
<div><ol class="loweralpha simple">
<li>apply <a class="reference internal" href="#eq-wave-pde1-step4"><span class="std std-ref">(173)</span></a> to find <span class="math">\(u^{n+1}_i\)</span> for <span class="math">\(i=1,\ldots,N_x-1\)</span></li>
<li>set <span class="math">\(u^{n+1}_i=0\)</span> for the boundary points <span class="math">\(i=0\)</span>, <span class="math">\(i=N_x\)</span>.</li>
</ol>
</div></blockquote>
<p>The algorithm essentially consists of moving a finite difference
stencil through all the mesh points, which can be seen as an animation
in a <a class="reference external" href="http://tinyurl.com/pu5uyfn/pub/pub/wave/html/mov-wave/D_stencil_gpl/index.html">web page</a>
or a <a class="reference external" href="http://tinyurl.com/pu5uyfn/pub/pub/wave/html/mov-wave/D_stencil_gpl/movie.ogg">movie file</a>.</p>
</div>
<div class="section" id="sketch-of-an-implementation">
<span id="wave-string-impl"></span><h3>Sketch of an implementation<a class="headerlink" href="#sketch-of-an-implementation" title="Permalink to this headline">¶</a></h3>
<p>The algorithm only involves the three most recent time levels, so we
need only three arrays for <span class="math">\(u_i^{n+1}\)</span>, <span class="math">\(u_i^n\)</span>, and <span class="math">\(u_i^{n-1}\)</span>,
<span class="math">\(i=0,\ldots,N_x\)</span>.  Storing all the solutions in a two-dimensional
array of size <span class="math">\((N_x+1)\times (N_t+1)\)</span> would be possible in this simple
one-dimensional PDE problem, but is normally out of the question in
three-dimensional (3D) and large two-dimensional (2D) problems. We
shall therefore, in all our PDE solving programs, have the unknown in
memory at as few time levels as possible.</p>
<p>In a Python implementation of this algorithm, we use the array
elements <code class="docutils literal"><span class="pre">u[i]</span></code> to store <span class="math">\(u^{n+1}_i\)</span>, <code class="docutils literal"><span class="pre">u_n[i]</span></code> to store <span class="math">\(u^n_i\)</span>, and
<code class="docutils literal"><span class="pre">u_nm1[i]</span></code> to store <span class="math">\(u^{n-1}_i\)</span>.
Our naming convention is to use <code class="docutils literal"><span class="pre">u</span></code> for the
unknown new spatial field to be computed and have all previous time
levels in a list <code class="docutils literal"><span class="pre">u_n</span></code> that we index as <code class="docutils literal"><span class="pre">u_n</span></code>, <code class="docutils literal"><span class="pre">u_nm1</span></code>, <code class="docutils literal"><span class="pre">u_n[-2]</span></code>
and so on. For the wave equation, <code class="docutils literal"><span class="pre">u_n</span></code> has just length 2.</p>
<p>The following Python snippet realizes the steps in the computational
algorithm.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Given mesh points as arrays x and t (x[i], t[n])</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">dx</span>            <span class="c1"># Courant number</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
<span class="n">C2</span> <span class="o">=</span> <span class="n">C</span><span class="o">**</span><span class="mi">2</span>              <span class="c1"># Help variable in the scheme</span>

<span class="c1"># Set initial condition u(x,0) = I(x)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="c1"># Apply special formula for first step, incorporating du/dt=0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> \
           <span class="mf">0.5</span><span class="o">*</span><span class="n">C</span><span class="o">**</span><span class="mi">2</span><span class="p">(</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c1"># Enforce boundary conditions</span>

<span class="c1"># Switch variables before next step</span>
<span class="n">u_nm1</span><span class="p">[:],</span> <span class="n">u_n</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u_n</span><span class="p">,</span> <span class="n">u</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
    <span class="c1"># Update all inner mesh points at time t[n+1]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_nm1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> \
               <span class="n">C</span><span class="o">**</span><span class="mi">2</span><span class="p">(</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Insert boundary conditions</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Switch variables before next step</span>
    <span class="n">u_nm1</span><span class="p">[:],</span> <span class="n">u_n</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u_n</span><span class="p">,</span> <span class="n">u</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="verification-4">
<h2>Verification<a class="headerlink" href="#verification-4" title="Permalink to this headline">¶</a></h2>
<p>Before implementing the algorithm, it is convenient to add a source
term to the PDE <a class="reference internal" href="#eq-wave-pde1"><span class="std std-ref">(160)</span></a>, since that gives us more freedom in
finding test problems for verification. Physically, a source term acts
as a generator for waves in the interior of the domain.</p>
<div class="section" id="a-slightly-generalized-model-problem">
<span id="wave-pde2-fd"></span><h3>A slightly generalized model problem<a class="headerlink" href="#a-slightly-generalized-model-problem" title="Permalink to this headline">¶</a></h3>
<p>We now address the following extended initial-boundary value problem
for one-dimensional wave phenomena:</p>
<div class="math" id="eq-wave-pde2">
\[\tag{176}
u_{tt} = c^2 u_{xx} + f(x,t), \quad x\in (0,L),\ t\in (0,T]\]</div>
<div class="math" id="eq-wave-pde2-ic-u">
\[\tag{177}
u(x,0) = I(x), \quad x\in [0,L]\]</div>
<div class="math" id="eq-wave-pde2-ic-ut">
\[\tag{178}
u_t(x,0) = V(x), \quad x\in [0,L]\]</div>
<div class="math" id="eq-wave-pde2-bc-0">
\[\tag{179}
u(0,t)  = 0, \quad  t&gt;0\]</div>
<div class="math" id="eq-wave-pde2-bc-l">
\[\tag{180}
u(L,t)  = 0, \quad  t&gt;0\]</div>
<p>Sampling the PDE at <span class="math">\((x_i,t_n)\)</span> and using the same finite difference
approximations as above, yields</p>
<div class="math" id="eq-wave-pde2-fdop">
\[\tag{181}
[D_tD_t u = c^2 D_xD_x u + f]^{n}_i
    {\thinspace .}\]</div>
<p>Writing this out and solving for the unknown <span class="math">\(u^{n+1}_i\)</span> results in</p>
<div class="math" id="eq-wave-pde2-step3b">
\[ \begin{align}\begin{aligned}\tag{182}
u^{n+1}_i = -u^{n-1}_i + 2u^n_i + C^2
    (u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}) + \Delta t^2 f^n_i\\    {\thinspace .}\end{aligned}\end{align} \]</div>
<p>The equation for the first time step must be rederived. The discretization
of the initial condition <span class="math">\(u_t = V(x)\)</span> at <span class="math">\(t=0\)</span>
becomes</p>
<div class="math">
\[[D_{2t}u = V]^0_i\quad\Rightarrow\quad u^{-1}_i = u^{1}_i - 2\Delta t V_i,\]</div>
<p>which, when inserted in <a class="reference internal" href="#eq-wave-pde2-step3b"><span class="std std-ref">(182)</span></a> for <span class="math">\(n=0\)</span>, gives
the special formula</p>
<div class="math" id="eq-wave-pde2-step3c">
\[ \begin{align}\begin{aligned}\tag{183}
u^{1}_i = u^0_i - \Delta t V_i + {\frac{1}{2}}
    C^2
    \left(u^{0}_{i+1}-2u^{0}_{i} + u^{0}_{i-1}\right) + \frac{1}{2}\Delta t^2 f^0_i\\    {\thinspace .}\end{aligned}\end{align} \]</div>
</div>
<div class="section" id="using-an-analytical-solution-of-physical-significance">
<span id="wave-pde2-fd-standing-waves"></span><h3>Using an analytical solution of physical significance<a class="headerlink" href="#using-an-analytical-solution-of-physical-significance" title="Permalink to this headline">¶</a></h3>
<p>Many wave problems feature sinusoidal oscillations in time
and space. For example, the original PDE problem
<a class="reference internal" href="#eq-wave-pde1"><span class="std std-ref">(160)</span></a>-<a class="reference internal" href="#eq-wave-pde1-bc-l"><span class="std std-ref">(164)</span></a> allows an exact solution</p>
<div class="math" id="eq-wave-pde2-test-ue">
\[\tag{184}
{u_{\small\mbox{e}}}(x,t) = A\sin\left(\frac{\pi}{L}x\right)
    \cos\left(\frac{\pi}{L}ct\right){\thinspace .}\]</div>
<p>This <span class="math">\({u_{\small\mbox{e}}}\)</span> fulfills the PDE with <span class="math">\(f=0\)</span>, boundary conditions
<span class="math">\({u_{\small\mbox{e}}}(0,t)={u_{\small\mbox{e}}}(L,0)=0\)</span>, as well as initial
conditions <span class="math">\(I(x)=A\sin\left(\frac{\pi}{L}x\right)\)</span> and <span class="math">\(V=0\)</span>.</p>
<div class="admonition-how-to-use-exact-solutions-for-verification admonition">
<p class="first admonition-title">How to use exact solutions for verification</p>
<p>It is common to use such exact solutions of physical interest
to verify implementations. However, the numerical
solution <span class="math">\(u^n_i\)</span> will only be an approximation to <span class="math">\({u_{\small\mbox{e}}}(x_i,t_n)\)</span>.
We have no knowledge of the precise size of the error in
this approximation, and therefore we can never know if discrepancies
between <span class="math">\(u^n_i\)</span> and <span class="math">\({u_{\small\mbox{e}}}(x_i,t_n)\)</span> are caused
by mathematical approximations or programming errors.
In particular, if plots of the computed solution <span class="math">\(u^n_i\)</span> and
the exact one <a class="reference internal" href="#eq-wave-pde2-test-ue"><span class="std std-ref">(184)</span></a> look similar, many
are tempted to claim that the implementation works. However,
even if color plots look nice and the accuracy is &#8220;deemed good&#8221;,
there can still be serious programming errors present!</p>
<p class="last">The only way to use exact physical solutions like
<a class="reference internal" href="#eq-wave-pde2-test-ue"><span class="std std-ref">(184)</span></a> for serious and thorough verification is to
run a series of simulations on finer and finer meshes, measure the
integrated error in each mesh, and from this information estimate the
empirical convergence rate of the method.</p>
</div>
<p>An introduction to the computing of convergence rates is given in
the section
on <a class="reference external" href="http://hplgit.github.io/decay-book/doc/pub/book/sphinx/._book007.html#computing-convergence-rates">convergence rates</a> in <a class="reference internal" href="._book027.html#ref02" id="id1">[Ref02]</a>.
There is also a detailed example on computing convergence rates in
the section <a class="reference internal" href="._book002.html#vib-ode1-verify"><span class="std std-ref">Verification</span></a>.</p>
<p>In the present problem, one expects the method to have a convergence rate
of 2 (see the section <a class="reference internal" href="._book007.html#wave-pde1-analysis"><span class="std std-ref">Analysis of the difference equations</span></a>), so if the computed rates
are close to 2 on a sufficiently fine mesh, we have good evidence that
the implementation is free of programming mistakes.</p>
</div>
<div class="section" id="manufactured-solution-and-estimation-of-convergence-rates">
<span id="wave-pde2-fd-mms"></span><h3>Manufactured solution and estimation of convergence rates<a class="headerlink" href="#manufactured-solution-and-estimation-of-convergence-rates" title="Permalink to this headline">¶</a></h3>
<div class="section" id="specifying-the-solution-and-computing-corresponding-data">
<h4>Specifying the solution and computing corresponding data<a class="headerlink" href="#specifying-the-solution-and-computing-corresponding-data" title="Permalink to this headline">¶</a></h4>
<p>One problem with the exact solution <a class="reference internal" href="#eq-wave-pde2-test-ue"><span class="std std-ref">(184)</span></a> is
that it requires a simplification (<span class="math">\(V=0, f=0\)</span>) of the implemented problem
<a class="reference internal" href="#eq-wave-pde2"><span class="std std-ref">(176)</span></a>-<a class="reference internal" href="#eq-wave-pde2-bc-l"><span class="std std-ref">(180)</span></a>. An advantage of using
a <em>manufactured solution</em> is that we can test all terms in the
PDE problem. The idea of this approach is to set up some chosen
solution and fit the source term, boundary conditions, and initial
conditions to be compatible with the chosen solution.
Given that our boundary conditions in the implementation are
<span class="math">\(u(0,t)=u(L,t)=0\)</span>, we must choose a solution that fulfills these
conditions. One example is</p>
<div class="math">
\[{u_{\small\mbox{e}}}(x,t) = x(L-x)\sin t{\thinspace .}\]</div>
<p>Inserted in the PDE <span class="math">\(u_{tt}=c^2u_{xx}+f\)</span> we get</p>
<div class="math">
\[-x(L-x)\sin t = -c^2 2\sin t + f\quad\Rightarrow f = (2c^2 - x(L-x))\sin t{\thinspace .}\]</div>
<p>The initial conditions become</p>
<div class="math">
\[\begin{split}\begin{align*}
u(x,0) =&amp; I(x) = 0,\\
u_t(x,0) &amp;= V(x) = x(L-x){\thinspace .}
\end{align*}\end{split}\]</div>
</div>
<div class="section" id="defining-a-single-discretization-parameter">
<h4>Defining a single discretization parameter<a class="headerlink" href="#defining-a-single-discretization-parameter" title="Permalink to this headline">¶</a></h4>
<p>To verify the code, we compute the convergence rates in a series of
simulations, letting each simulation use a finer mesh than the
previous one. Such empirical estimation of convergence rates relies on
an assumption that some measure <span class="math">\(E\)</span> of the numerical error is related
to the discretization parameters through</p>
<div class="math">
\[E = C_t\Delta t^r + C_x\Delta x^p,\]</div>
<p>where <span class="math">\(C_t\)</span>, <span class="math">\(C_x\)</span>, <span class="math">\(r\)</span>, and <span class="math">\(p\)</span> are constants. The constants <span class="math">\(r\)</span> and
<span class="math">\(p\)</span> are known as the <em>convergence rates</em> in time and space,
respectively.  From the accuracy in the finite difference
approximations, we expect <span class="math">\(r=p=2\)</span>, since the error terms are of order
<span class="math">\(\Delta t^2\)</span> and <span class="math">\(\Delta x^2\)</span>.  This is confirmed by truncation error
analysis and other types of analysis.</p>
<p>By using an exact solution of the PDE problem, we will next compute
the error measure <span class="math">\(E\)</span> on a sequence of refined meshes and see if
the rates <span class="math">\(r=p=2\)</span> are obtained. We will not be concerned with estimating
the constants <span class="math">\(C_t\)</span> and <span class="math">\(C_x\)</span>, simply because we are not interested in
their values.</p>
<p>It is advantageous to introduce a single discretization parameter
<span class="math">\(h=\Delta t=\hat c \Delta x\)</span> for some constant <span class="math">\(\hat c\)</span>.  Since
<span class="math">\(\Delta t\)</span> and <span class="math">\(\Delta x\)</span> are related through the Courant number,
<span class="math">\(\Delta t = C\Delta x/c\)</span>, we set <span class="math">\(h=\Delta t\)</span>, and then <span class="math">\(\Delta x =
hc/C\)</span>.  Now the expression for the error measure is greatly
simplified:</p>
<div class="math">
\[E = C_t\Delta t^r + C_x\Delta x^r =
C_t h^r + C_x\left(\frac{c}{C}\right)^r h^r
= Dh^r,\quad D = C_t+C_x\left(\frac{c}{C}\right)^r {\thinspace .}\]</div>
</div>
<div class="section" id="computing-errors">
<h4>Computing errors<a class="headerlink" href="#computing-errors" title="Permalink to this headline">¶</a></h4>
<p>We choose an initial discretization parameter <span class="math">\(h_0\)</span> and run
experiments with decreasing <span class="math">\(h\)</span>: <span class="math">\(h_i=2^{-i}h_0\)</span>, <span class="math">\(i=1,2,\ldots,m\)</span>.
Halving <span class="math">\(h\)</span> in each experiment is not necessary, but it is a common
choice.  For each experiment we must record <span class="math">\(E\)</span> and <span class="math">\(h\)</span>.  A standard
choice of error measure is the <span class="math">\(\ell^2\)</span> or <span class="math">\(\ell^\infty\)</span> norm of the
error mesh function <span class="math">\(e^n_i\)</span>:</p>
<div class="math" id="eq-wave-pde2-fd-mms-e-l2">
\[\tag{185}
E = ||e^n_i||_{\ell^2} = \left( \Delta t\Delta x
    \sum_{n=0}^{N_t}\sum_{i=0}^{N_x}
    (e^n_i)^2\right)^{\frac{1}{2}},\quad e^n_i = {u_{\small\mbox{e}}}(x_i,t_n)-u^n_i,\]</div>
<div class="math" id="eq-wave-pde2-fd-mms-e-linf">
\[\tag{186}
E = ||e^n_i||_{\ell^\infty} = \max_{i,n} |e^i_n|{\thinspace .}\]</div>
<p>In Python, one can compute <span class="math">\(\sum_{i}(e^{n}_i)^2\)</span> at each time step
and accumulate the value in some sum variable, say <code class="docutils literal"><span class="pre">e2_sum</span></code>.  At the
final time step one can do <code class="docutils literal"><span class="pre">sqrt(dt*dx*e2_sum)</span></code>.  For the
<span class="math">\(\ell^\infty\)</span> norm one must compare the maximum error at a time level
(<code class="docutils literal"><span class="pre">e.max()</span></code>) with the global maximum over the time domain: <code class="docutils literal"><span class="pre">e_max</span> <span class="pre">=</span>
<span class="pre">max(e_max,</span> <span class="pre">e.max())</span></code>.</p>
<p>An alternative error measure is to use a spatial norm at one time step
only, e.g., the end time <span class="math">\(T\)</span> (<span class="math">\(n=N_t\)</span>):</p>
<div class="math" id="eq-auto64">
\[\tag{187}
E = ||e^n_i||_{\ell^2} = \left( \Delta x\sum_{i=0}^{N_x}
    (e^n_i)^2\right)^{\frac{1}{2}},\quad e^n_i = {u_{\small\mbox{e}}}(x_i,t_n)-u^n_i,\]</div>
<div class="math" id="eq-auto65">
\[\tag{188}
E = ||e^n_i||_{\ell^\infty} = \max_{0\leq i\leq N_x} |e^{n}_i|{\thinspace .}\]</div>
<p>The important issue is that our error measure <span class="math">\(E\)</span> must be one number
that represents the error in the simulation.</p>
</div>
<div class="section" id="computing-rates">
<h4>Computing rates<a class="headerlink" href="#computing-rates" title="Permalink to this headline">¶</a></h4>
<p>Let <span class="math">\(E_i\)</span> be the error measure in experiment (mesh) number <span class="math">\(i\)</span> and
let <span class="math">\(h_i\)</span> be the corresponding discretization parameter (<span class="math">\(h\)</span>).
With the error model <span class="math">\(E_i = Dh_i^r\)</span>, we can
estimate <span class="math">\(r\)</span> by comparing two consecutive
experiments:</p>
<div class="math">
\[\begin{split}\begin{align*}
E_{i+1}&amp; =D h_{i+1}^{r},\\
E_{i}&amp; =D h_{i}^{r}{\thinspace .}
\end{align*}\end{split}\]</div>
<p>Dividing the two equations eliminates the (uninteresting) constant <span class="math">\(D\)</span>.
Thereafter, solving for <span class="math">\(r\)</span> yields</p>
<div class="math">
\[r = \frac{\ln E_{i+1}/E_{i}}{\ln h_{i+1}/h_{i}}{\thinspace .}\]</div>
<p>Since <span class="math">\(r\)</span> depends on <span class="math">\(i\)</span>, i.e., which simulations we compare,
we add an index to <span class="math">\(r\)</span>: <span class="math">\(r_i\)</span>, where <span class="math">\(i=0,\ldots,m-2\)</span>, if we
have <span class="math">\(m\)</span> experiments: <span class="math">\((h_0,E_0),\ldots,(h_{m-1}, E_{m-1})\)</span>.</p>
<p>In our present discretization of the wave equation we expect <span class="math">\(r=2\)</span>, and
hence the <span class="math">\(r_i\)</span> values should converge to 2 as <span class="math">\(i\)</span> increases.</p>
</div>
</div>
<div class="section" id="constructing-an-exact-solution-of-the-discrete-equations">
<span id="wave-pde2-fd-verify-quadratic"></span><h3>Constructing an exact solution of the discrete equations<a class="headerlink" href="#constructing-an-exact-solution-of-the-discrete-equations" title="Permalink to this headline">¶</a></h3>
<p>With a manufactured or known analytical solution, as outlined above,
we can estimate convergence rates and see if they have the correct
asymptotic behavior. Experience shows that this is a quite good
verification technique in that many common bugs will destroy the
convergence rates. A significantly better test though,
would be to check that the
numerical solution is exactly what it should be. This will in general
require exact knowledge of the numerical error, which we do not normally have
(although we in the section <a class="reference internal" href="._book007.html#wave-pde1-analysis"><span class="std std-ref">Analysis of the difference equations</span></a> establish such knowledge
in simple cases).
However, it is possible to look for solutions where we can show that
the numerical error vanishes, i.e., the solution of the original continuous
PDE problem is
also a solution of the discrete equations. This property often arises
if the exact solution of the PDE
is a lower-order polynomial. (Truncation error
analysis leads to error measures that involve derivatives of the
exact solution. In the present problem, the truncation error involves
4th-order derivatives of <span class="math">\(u\)</span> in space and time. Choosing <span class="math">\(u\)</span>
as a polynomial of degree three or less
will therefore lead to vanishing error.)</p>
<p>We shall now illustrate the construction of an exact solution to both the
PDE itself and the discrete equations.
Our chosen manufactured solution is quadratic in space
and linear in time. More specifically, we set</p>
<div class="math" id="eq-wave-pde2-fd-verify-quadratic-uex">
\[\tag{189}
{u_{\small\mbox{e}}} (x,t) = x(L-x)(1+{\frac{1}{2}}t),\]</div>
<p>which by insertion in the PDE leads to <span class="math">\(f(x,t)=2(1+t)c^2\)</span>. This <span class="math">\({u_{\small\mbox{e}}}\)</span>
fulfills the boundary conditions <span class="math">\(u=0\)</span> and demands <span class="math">\(I(x)=x(L-x)\)</span>
and <span class="math">\(V(x)={\frac{1}{2}}x(L-x)\)</span>.</p>
<p>To realize that the chosen <span class="math">\({u_{\small\mbox{e}}}\)</span> is also an exact
solution of the discrete equations,
we first remind ourselves that <span class="math">\(t_n=n\Delta t\)</span> before we
establish that</p>
<div class="math" id="eq-auto66">
\[\tag{190}
\lbrack D_tD_t t^2\rbrack^n = \frac{t_{n+1}^2 - 2t_n^2 + t_{n-1}^2}{\Delta t^2}
    = (n+1)^2 -2n^2 + (n-1)^2 = 2,\]</div>
<div class="math" id="eq-auto67">
\[\tag{191}
\lbrack D_tD_t t\rbrack^n = \frac{t_{n+1} - 2t_n + t_{n-1}}{\Delta t^2}
    = \frac{((n+1) -2n + (n-1))\Delta t}{\Delta t^2} = 0
    {\thinspace .}\]</div>
<p>Hence,</p>
<div class="math">
\[[D_tD_t {u_{\small\mbox{e}}}]^n_i = x_i(L-x_i)[D_tD_t (1+{\frac{1}{2}}t)]^n =
x_i(L-x_i){\frac{1}{2}}[D_tD_t t]^n = 0{\thinspace .}\]</div>
<p>Similarly, we get that</p>
<div class="math">
\[\begin{split}\begin{align*}
\lbrack D_xD_x {u_{\small\mbox{e}}}\rbrack^n_i &amp;=
(1+{\frac{1}{2}}t_n)\lbrack D_xD_x (xL-x^2)\rbrack_i\\
&amp; =
(1+{\frac{1}{2}}t_n)\lbrack LD_xD_x x - D_xD_x x^2\rbrack_i \\
&amp;= -2(1+{\frac{1}{2}}t_n)
{\thinspace .}
\end{align*}\end{split}\]</div>
<p>Now, <span class="math">\(f^n_i = 2(1+{\frac{1}{2}}t_n)c^2\)</span>, which results in</p>
<div class="math">
\[[D_tD_t {u_{\small\mbox{e}}} - c^2D_xD_x{u_{\small\mbox{e}}} - f]^n_i = 0 +
c^2 2(1 + {\frac{1}{2}}t_{n}) +
2(1+{\frac{1}{2}}t_n)c^2 = 0{\thinspace .}\]</div>
<p>Moreover, <span class="math">\({u_{\small\mbox{e}}}(x_i,0)=I(x_i)\)</span>,
<span class="math">\(\partial {u_{\small\mbox{e}}}/\partial t = V(x_i)\)</span> at <span class="math">\(t=0\)</span>, and
<span class="math">\({u_{\small\mbox{e}}}(x_0,t)={u_{\small\mbox{e}}}(x_{N_x},0)=0\)</span>. Also the modified scheme for the
first time step is fulfilled by <span class="math">\({u_{\small\mbox{e}}}(x_i,t_n)\)</span>.</p>
<p>Therefore, the exact solution <span class="math">\({u_{\small\mbox{e}}}(x,t)=x(L-x)(1+t/2)\)</span> of the PDE
problem is also an exact solution of the discrete problem.  This means
that we know beforehand what numbers the numerical algorithm should
produce.  We can use this fact to check that the computed <span class="math">\(u^n_i\)</span>
values from an implementation equals <span class="math">\({u_{\small\mbox{e}}}(x_i,t_n)\)</span>, within machine
precision.  This result is valid <em>regardless of the mesh spacings</em>
<span class="math">\(\Delta x\)</span> and <span class="math">\(\Delta t\)</span>!  Nevertheless, there might be stability
restrictions on <span class="math">\(\Delta x\)</span> and <span class="math">\(\Delta t\)</span>, so the test can only be run
for a mesh that is compatible with the stability criterion (which in
the present case is <span class="math">\(C\leq 1\)</span>, to be derived later).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>A product of quadratic or linear expressions in the various
independent variables, as shown above, will often fulfill both the
PDE problem and the discrete equations, and can therefore be very useful
solutions for verifying implementations.</p>
<p class="last">However, for 1D wave
equations of the type <span class="math">\(u_{tt}=c^2u_{xx}\)</span> we shall see that there is always
another much more powerful way of generating exact
solutions (which consists in just setting <span class="math">\(C=1\)</span> (!), as shown in
the section <a class="reference internal" href="._book007.html#wave-pde1-analysis"><span class="std std-ref">Analysis of the difference equations</span></a>).</p>
</div>
</div>
</div>
<div class="section" id="implementation-4">
<span id="wave-pde1-impl"></span><h2>Implementation<a class="headerlink" href="#implementation-4" title="Permalink to this headline">¶</a></h2>
<p id="index-6">This section presents the complete computational algorithm, its
implementation in Python code, animation of the solution, and
verification of the implementation.</p>
<p>A real implementation of the basic computational algorithm from
the sections <a class="reference internal" href="#wave-string-alg"><span class="std std-ref">Formulating a recursive algorithm</span></a> and <a class="reference internal" href="#wave-string-impl"><span class="std std-ref">Sketch of an implementation</span></a> can be
encapsulated in a function, taking all the input data for the problem
as arguments.  The physical input data consists of <span class="math">\(c\)</span>, <span class="math">\(I(x)\)</span>,
<span class="math">\(V(x)\)</span>, <span class="math">\(f(x,t)\)</span>, <span class="math">\(L\)</span>, and <span class="math">\(T\)</span>.  The numerical input is the mesh
parameters <span class="math">\(\Delta t\)</span> and <span class="math">\(\Delta x\)</span>.</p>
<p>Instead of specifying <span class="math">\(\Delta t\)</span> <em>and</em> <span class="math">\(\Delta x\)</span>, we can specify one
of them and the Courant number <span class="math">\(C\)</span> instead, since having explicit
control of the Courant number is convenient when investigating the
numerical method. Many find it natural to prescribe the resolution of
the spatial grid and set <span class="math">\(N_x\)</span>. The solver function can then compute
<span class="math">\(\Delta t = CL/(cN_x)\)</span>. However, for comparing <span class="math">\(u(x,t)\)</span> curves (as
functions of <span class="math">\(x\)</span>) for various Courant numbers
it is more convenient to keep <span class="math">\(\Delta t\)</span> fixed for
all <span class="math">\(C\)</span> and let <span class="math">\(\Delta x\)</span> vary according to <span class="math">\(\Delta x = c\Delta t/C\)</span>.
With <span class="math">\(\Delta t\)</span> fixed, all frames correspond to the same time <span class="math">\(t\)</span>,
and this simplifies animations that compare simulations with different
mesh resolutions. Plotting functions of <span class="math">\(x\)</span>
with different spatial resolution is trivial,
so it is easier to let <span class="math">\(\Delta x\)</span> vary in the simulations than <span class="math">\(\Delta t\)</span>.</p>
<div class="section" id="callback-function-for-user-specific-actions">
<span id="wave-pde1-impl-useraction"></span><h3>Callback function for user-specific actions<a class="headerlink" href="#callback-function-for-user-specific-actions" title="Permalink to this headline">¶</a></h3>
<p id="index-7">The solution at all spatial points at a new time level is stored in an
array <code class="docutils literal"><span class="pre">u</span></code> of length <span class="math">\(N_x+1\)</span>. We need to decide what to do with
this solution, e.g., visualize the curve, analyze the values, or write
the array to file for later use. The decision about what to do is left to
the user in the form of a user-supplied function</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">user_action</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">u</span></code> is the solution at the spatial points <code class="docutils literal"><span class="pre">x</span></code> at time <code class="docutils literal"><span class="pre">t[n]</span></code>.
The <code class="docutils literal"><span class="pre">user_action</span></code> function is called from the solver at each time level <code class="docutils literal"><span class="pre">n</span></code>.</p>
<p>If the user wants to plot the solution or store the solution at a
time point, she needs to write such a function and take appropriate
actions inside it. We will show examples on many such <code class="docutils literal"><span class="pre">user_action</span></code>
functions.</p>
<p>Since the solver function makes calls back to the user&#8217;s code
via such a function, this type of function is called a <em>callback function</em>.
When writing general software, like our solver function, which also needs
to carry out special problem- or solution-dependent actions
(like visualization),
it is a common technique to leave those actions to user-supplied
callback functions.</p>
<p>The callback function can be used to terminate the solution process
if the user returns <code class="docutils literal"><span class="pre">True</span></code>. For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_user_action_function</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">10</span>
</pre></div>
</div>
<p>is a callback function that will terminate the solver function of the
amplitude of the waves exceed 10, which is here considered as a numerical
instability.</p>
</div>
<div class="section" id="the-solver-function">
<span id="wave-pde1-impl-solver"></span><h3>The solver function<a class="headerlink" href="#the-solver-function" title="Permalink to this headline">¶</a></h3>
<p>A first attempt at a solver function is listed below.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">user_action</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solve u_tt=c^2*u_xx + f on (0,L)x(0,T].&quot;&quot;&quot;</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Mesh points in time</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">c</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">L</span><span class="o">/</span><span class="n">dx</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>       <span class="c1"># Mesh points in space</span>
    <span class="n">C2</span> <span class="o">=</span> <span class="n">C</span><span class="o">**</span><span class="mi">2</span>                         <span class="c1"># Help variable in the scheme</span>
    <span class="c1"># Make sure dx and dt are compatible with x and t</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">f</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">V</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">V</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span>

    <span class="n">u</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Solution array at new time level</span>
    <span class="n">u_n</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Solution at 1 time level back</span>
    <span class="n">u_nm1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Solution at 2 time levels back</span>

    <span class="kn">import</span> <span class="nn">time</span><span class="p">;</span>  <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>  <span class="c1"># Measure CPU time</span>

    <span class="c1"># Load initial condition into u_n</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">user_action</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">user_action</span><span class="p">(</span><span class="n">u_n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Special formula for first time step</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> \
               <span class="mf">0.5</span><span class="o">*</span><span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
               <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">user_action</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">user_action</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Switch variables before next step</span>
    <span class="n">u_nm1</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u_n</span><span class="p">;</span>  <span class="n">u_n</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="c1"># Update all inner points at time t[n+1]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
            <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u_nm1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
                     <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
                     <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

        <span class="c1"># Insert boundary conditions</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">user_action</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">user_action</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">break</span>

        <span class="c1"># Switch variables before next step</span>
        <span class="n">u_nm1</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u_n</span><span class="p">;</span>  <span class="n">u_n</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u</span>

    <span class="n">cpu_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">cpu_time</span>
</pre></div>
</div>
<p>A couple of remarks about the above code is perhaps necessary:</p>
<blockquote>
<div><ul class="simple">
<li>Although we give <code class="docutils literal"><span class="pre">dt</span></code> and compute <code class="docutils literal"><span class="pre">dx</span></code> via <code class="docutils literal"><span class="pre">C</span></code> and <code class="docutils literal"><span class="pre">c</span></code>, the resulting
<code class="docutils literal"><span class="pre">t</span></code> and <code class="docutils literal"><span class="pre">x</span></code> meshes do not necessarily correspond exactly to these values
because of rounding errors. To explicitly ensure that <code class="docutils literal"><span class="pre">dx</span></code> and <code class="docutils literal"><span class="pre">dt</span></code>
correspond to the cell sizes in <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">t</span></code>, we recompute the values.</li>
<li>According to the convention described in the section <a class="reference internal" href="#wave-pde1-impl-useraction"><span class="std std-ref">Callback function for user-specific actions</span></a>, a true value returned from <code class="docutils literal"><span class="pre">user_action</span></code> should terminate the simulation, here implemented by a <code class="docutils literal"><span class="pre">break</span></code> statement inside the for loop in the solver.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="verification-exact-quadratic-solution">
<span id="wave-pde1-impl-verify-quadratic"></span><h3>Verification: exact quadratic solution<a class="headerlink" href="#verification-exact-quadratic-solution" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-8"></span><span class="target" id="index-9"></span><span class="target" id="index-10"></span><span class="target" id="index-11"></span><p id="index-12">We use the test problem derived in the section <a class="reference internal" href="#wave-pde2-fd"><span class="std std-ref">A slightly generalized model problem</span></a> for
verification. Below is a unit test based on this test problem
and realized as a proper <em>test function</em> compatible with the unit test
frameworks nose or pytest.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_quadratic</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check that u(x,t)=x(L-x)(1+t/2) is exactly reproduced.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">V</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">L</span> <span class="o">=</span> <span class="mf">2.5</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mf">1.5</span>
    <span class="n">C</span> <span class="o">=</span> <span class="mf">0.75</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="mi">6</span>  <span class="c1"># Very coarse mesh for this exact test</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">C</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">/</span><span class="n">Nx</span><span class="p">)</span><span class="o">/</span><span class="n">c</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">18</span>

    <span class="k">def</span> <span class="nf">assert_no_error</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-13</span>
        <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span>

    <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>
           <span class="n">user_action</span><span class="o">=</span><span class="n">assert_no_error</span><span class="p">)</span>
</pre></div>
</div>
<p>When this function resides in the file <code class="docutils literal"><span class="pre">wave1D_u0.py</span></code>, one can run
pytest to check that all test functions with names <code class="docutils literal"><span class="pre">test_*()</span></code>
in this file work:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Terminal&gt; py.test -s -v wave1D_u0.py
</pre></div>
</div>
</div>
<div class="section" id="verification-convergence-rates-1">
<span id="wave-pde1-impl-verify-rate"></span><h3>Verification: convergence rates<a class="headerlink" href="#verification-convergence-rates-1" title="Permalink to this headline">¶</a></h3>
<p>A more general method, but not so reliable as a verification method,
is to compute the convergence rates and see if they coincide with
theoretical estimates. Here we expect a rate of 2 according to
the various results in the section <a class="reference internal" href="._book007.html#wave-pde1-analysis"><span class="std std-ref">Analysis of the difference equations</span></a>.
A general function for computing convergence rates can be written like
this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">convergence_rates</span><span class="p">(</span>
    <span class="n">u_exact</span><span class="p">,</span>                 <span class="c1"># Python function for exact solution</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span>           <span class="c1"># physical parameters</span>
    <span class="n">dt0</span><span class="p">,</span> <span class="n">num_meshes</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>  <span class="c1"># numerical parameters</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Half the time step and estimate convergence rates for</span>
<span class="sd">    for num_meshes simulations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># First define an appropriate user action function</span>
    <span class="k">global</span> <span class="n">error</span>
    <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># error computed in the user action function</span>

    <span class="k">def</span> <span class="nf">compute_error</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">global</span> <span class="n">error</span>  <span class="c1"># must be global to be altered here</span>
        <span class="c1"># (otherwise error is a local variable, different</span>
        <span class="c1"># from error defined in the parent function)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

    <span class="c1"># Run finer and finer resolutions and compute true errors</span>
    <span class="n">E</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">h</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># dt, solver adjusts dx such that C=dt*c/dx</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">dt0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_meshes</span><span class="p">):</span>
        <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>
               <span class="n">user_action</span><span class="o">=</span><span class="n">compute_error</span><span class="p">)</span>
        <span class="c1"># error is computed in the final call to compute_error</span>
        <span class="n">E</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
        <span class="n">h</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">/=</span> <span class="mi">2</span>  <span class="c1"># halve the time step for next simulation</span>
    <span class="k">print</span> <span class="s1">&#39;E:&#39;</span><span class="p">,</span> <span class="n">E</span>
    <span class="k">print</span> <span class="s1">&#39;h:&#39;</span><span class="p">,</span> <span class="n">h</span>
    <span class="c1"># Convergence rates for two consecutive experiments</span>
    <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">num_meshes</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">r</span>
</pre></div>
</div>
<p>Using the analytical solution from the section <a class="reference internal" href="#wave-pde2-fd-standing-waves"><span class="std std-ref">Using an analytical solution of physical significance</span></a>, we can call <code class="docutils literal"><span class="pre">convergece_rates</span></code> to
see if we get a convergence rate that approaches 2 and use the final
estimate of the rate in an <code class="docutils literal"><span class="pre">assert</span></code> statement such that this function becomes
a proper test function:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_convrate_sincos</span><span class="p">():</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">L</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">u_exact</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">L</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">L</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span>
        <span class="n">u_exact</span><span class="o">=</span><span class="n">u_exact</span><span class="p">,</span>
        <span class="n">I</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">V</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">f</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span>
        <span class="n">dt0</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">num_meshes</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
        <span class="n">C</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
        <span class="n">T</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">print</span> <span class="s1">&#39;rates sin(x)*cos(t) solution:&#39;</span><span class="p">,</span> \
          <span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">r_</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">r_</span> <span class="ow">in</span> <span class="n">r</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.002</span>
</pre></div>
</div>
<p>Doing <code class="docutils literal"><span class="pre">py.test</span> <span class="pre">-s</span> <span class="pre">-v</span> <span class="pre">wave1D_u0.py</span></code> will run also this test function and
show the rates 2.05, 1.98, 2.0, 2.0, and 2.0 (to two decimals).</p>
</div>
<div class="section" id="visualization-animating-the-solution">
<span id="wave-pde1-impl-animate"></span><h3>Visualization: animating the solution<a class="headerlink" href="#visualization-animating-the-solution" title="Permalink to this headline">¶</a></h3>
<p>Now that we have verified the implementation it is time to do a
real computation where we also display evolution of the waves
on the screen. Since the <code class="docutils literal"><span class="pre">solver</span></code> function knows nothing about
what type of visualizations we may want, it calls the callback function
<code class="docutils literal"><span class="pre">user_action(u,</span> <span class="pre">x,</span> <span class="pre">t,</span> <span class="pre">n)</span></code>. We must therefore write this function and
find the proper statements for plotting the solution.</p>
<div class="section" id="function-for-administering-the-simulation">
<h4>Function for administering the simulation<a class="headerlink" href="#function-for-administering-the-simulation" title="Permalink to this headline">¶</a></h4>
<p>The following <code class="docutils literal"><span class="pre">viz</span></code> function</p>
<ol class="arabic simple">
<li>defines a <code class="docutils literal"><span class="pre">user_action</span></code> callback function
for plotting the solution at each time level,</li>
<li>calls the <code class="docutils literal"><span class="pre">solver</span></code> function, and</li>
<li>combines all the plots (in files) to video in different formats.</li>
</ol>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">viz</span><span class="p">(</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>  <span class="c1"># PDE parameters</span>
    <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">,</span>               <span class="c1"># Interval for u in plots</span>
    <span class="n">animate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>             <span class="c1"># Simulation with animation?</span>
    <span class="n">tool</span><span class="o">=</span><span class="s1">&#39;matplotlib&#39;</span><span class="p">,</span>        <span class="c1"># &#39;matplotlib&#39; or &#39;scitools&#39;</span>
    <span class="n">solver_function</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span>   <span class="c1"># Function with numerical algorithm</span>
    <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Run solver and visualize u at each time level.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">plot_u_st</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;user_action function for solver.&quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s1">&#39;r-&#39;</span><span class="p">,</span>
                 <span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">,</span>
                 <span class="n">axis</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">],</span>
                 <span class="n">title</span><span class="o">=</span><span class="s1">&#39;t=</span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">show</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="c1"># Let the initial condition stay on the screen for 2</span>
        <span class="c1"># seconds, else insert a pause of 0.2 s between each plot</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;frame_</span><span class="si">%04d</span><span class="s1">.png&#39;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>  <span class="c1"># for movie making</span>

    <span class="k">class</span> <span class="nc">PlotMatplotlib</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;user_action function for solver.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lines</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s1">&#39;r-&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">])</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;t=</span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]],</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower left&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;t=</span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]],</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower left&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;tmp_</span><span class="si">%04d</span><span class="s1">.png&#39;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>  <span class="c1"># for movie making</span>

    <span class="k">if</span> <span class="n">tool</span> <span class="o">==</span> <span class="s1">&#39;matplotlib&#39;</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
        <span class="n">plot_u</span> <span class="o">=</span> <span class="n">PlotMatplotlib</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">tool</span> <span class="o">==</span> <span class="s1">&#39;scitools&#39;</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">scitools.std</span> <span class="kn">as</span> <span class="nn">plt</span>  <span class="c1"># scitools.easyviz interface</span>
        <span class="n">plot_u</span> <span class="o">=</span> <span class="n">plot_u_st</span>
    <span class="kn">import</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">glob</span><span class="o">,</span> <span class="nn">os</span>

    <span class="c1"># Clean up old movie frames</span>
    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;tmp_*.png&#39;</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="c1"># Call solver and do the simulaton</span>
    <span class="n">user_action</span> <span class="o">=</span> <span class="n">plot_u</span> <span class="k">if</span> <span class="n">animate</span> <span class="k">else</span> <span class="bp">None</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">solver_function</span><span class="p">(</span>
        <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">user_action</span><span class="p">)</span>

    <span class="c1"># Make video files</span>
    <span class="n">fps</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c1"># frames per second</span>
    <span class="n">codec2ext</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">flv</span><span class="o">=</span><span class="s1">&#39;flv&#39;</span><span class="p">,</span> <span class="n">libx264</span><span class="o">=</span><span class="s1">&#39;mp4&#39;</span><span class="p">,</span> <span class="n">libvpx</span><span class="o">=</span><span class="s1">&#39;webm&#39;</span><span class="p">,</span>
                     <span class="n">libtheora</span><span class="o">=</span><span class="s1">&#39;ogg&#39;</span><span class="p">)</span>  <span class="c1"># video formats</span>
    <span class="n">filespec</span> <span class="o">=</span> <span class="s1">&#39;tmp_</span><span class="si">%04d</span><span class="s1">.png&#39;</span>
    <span class="n">movie_program</span> <span class="o">=</span> <span class="s1">&#39;ffmpeg&#39;</span>  <span class="c1"># or &#39;ffmpeg&#39;</span>
    <span class="k">for</span> <span class="n">codec</span> <span class="ow">in</span> <span class="n">codec2ext</span><span class="p">:</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">codec2ext</span><span class="p">[</span><span class="n">codec</span><span class="p">]</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%(movie_program)s</span><span class="s1"> -r </span><span class="si">%(fps)d</span><span class="s1"> -i </span><span class="si">%(filespec)s</span><span class="s1"> &#39;</span>\
              <span class="s1">&#39;-vcodec </span><span class="si">%(codec)s</span><span class="s1"> movie.</span><span class="si">%(ext)s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">()</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">tool</span> <span class="o">==</span> <span class="s1">&#39;scitools&#39;</span><span class="p">:</span>
        <span class="c1"># Make an HTML play for showing the animation in a browser</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">movie</span><span class="p">(</span><span class="s1">&#39;tmp_*.png&#39;</span><span class="p">,</span> <span class="n">encoder</span><span class="o">=</span><span class="s1">&#39;html&#39;</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="n">fps</span><span class="p">,</span>
                  <span class="n">output_file</span><span class="o">=</span><span class="s1">&#39;movie.html&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cpu</span>
</pre></div>
</div>
</div>
<div class="section" id="dissection-of-the-code">
<h4>Dissection of the code<a class="headerlink" href="#dissection-of-the-code" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">viz</span></code> function can either use SciTools or Matplotlib for
visualizing the solution. The <code class="docutils literal"><span class="pre">user_action</span></code> function based on SciTools
is called <code class="docutils literal"><span class="pre">plot_u_st</span></code>, while the <code class="docutils literal"><span class="pre">user_action</span></code> function based on
Matplotlib is a bit more complicated as it is realized as a class and
needs statements that differ from those for making static plots.
SciTools can utilize both Matplotlib and Gnuplot (and many other
plotting programs) for doing the graphics, but Gnuplot is a relevant
choice for large <span class="math">\(N_x\)</span> or in two-dimensional problems
as Gnuplot is significantly faster than
Matplotlib for screen animations.</p>
<p id="index-13">A function inside another function, like <code class="docutils literal"><span class="pre">plot_u_st</span></code> in the above code
segment, has access to <em>and remembers</em> all the local variables in the
surrounding code inside the <code class="docutils literal"><span class="pre">viz</span></code> function (!). This is known in
computer science as a <em>closure</em> and is very convenient to program
with. For example, the <code class="docutils literal"><span class="pre">plt</span></code> and <code class="docutils literal"><span class="pre">time</span></code> modules defined outside
<code class="docutils literal"><span class="pre">plot_u</span></code> are accessible for <code class="docutils literal"><span class="pre">plot_u_st</span></code> when the function is called
(as <code class="docutils literal"><span class="pre">user_action</span></code>) in the <code class="docutils literal"><span class="pre">solver</span></code> function.  Some may think, however,
that a class instead of a closure is a cleaner and
easier-to-understand implementation of the user action function, see
the section <a class="reference internal" href="._book006.html#wave-pde2-software"><span class="std std-ref">Building a general 1D wave equation solver</span></a>.</p>
<p>The <code class="docutils literal"><span class="pre">plot_u_st</span></code> function just makes a standard SciTools <code class="docutils literal"><span class="pre">plot</span></code> command
for plotting <code class="docutils literal"><span class="pre">u</span></code> as a function of <code class="docutils literal"><span class="pre">x</span></code> at time <code class="docutils literal"><span class="pre">t[n]</span></code>.  To achieve a
smooth animation, the <code class="docutils literal"><span class="pre">plot</span></code> command should take keyword arguments
instead of being broken into separate calls to <code class="docutils literal"><span class="pre">xlabel</span></code>, <code class="docutils literal"><span class="pre">ylabel</span></code>,
<code class="docutils literal"><span class="pre">axis</span></code>, <code class="docutils literal"><span class="pre">time</span></code>, and <code class="docutils literal"><span class="pre">show</span></code>.  Several <code class="docutils literal"><span class="pre">plot</span></code> calls will automatically
cause an animation on the screen. In addition, we want to save each
frame in the animation to file. We then need a filename where the
frame number is padded with zeros, here <code class="docutils literal"><span class="pre">tmp_0000.png</span></code>,
<code class="docutils literal"><span class="pre">tmp_0001.png</span></code>, and so on.  The proper printf construction is then
<code class="docutils literal"><span class="pre">tmp_%04d.png</span></code>.
The section <a class="reference internal" href="._book002.html#vib-ode1-anim"><span class="std std-ref">Making animations</span></a> contains more basic
information on making animations.</p>
<p>The solver is called with an argument <code class="docutils literal"><span class="pre">plot_u</span></code> as <code class="docutils literal"><span class="pre">user_function</span></code>.
If the user chooses to use SciTools, <code class="docutils literal"><span class="pre">plot_u</span></code> is the <code class="docutils literal"><span class="pre">plot_u_st</span></code>
callback function, but for Matplotlib it is an instance of the
class <code class="docutils literal"><span class="pre">PlotMatplotlib</span></code>. Also this class makes use of variables
defined in the <code class="docutils literal"><span class="pre">viz</span></code> function: <code class="docutils literal"><span class="pre">plt</span></code> and <code class="docutils literal"><span class="pre">time</span></code>.
With Matplotlib, one has to make the first plot the standard way, and
then update the <span class="math">\(y\)</span> data in the plot at every time level. The update
requires active use of the returned value from <code class="docutils literal"><span class="pre">plt.plot</span></code> in the first
plot.  This value would need to be stored in a local variable if we
were to use a closure for the <code class="docutils literal"><span class="pre">user_action</span></code> function when doing the
animation with Matplotlib. It is much easier to store the
variable as a class attribute <code class="docutils literal"><span class="pre">self.lines</span></code>. Since the class is essentially a
function, we implement the function as the special method <code class="docutils literal"><span class="pre">__call__</span></code>
such that the instance <code class="docutils literal"><span class="pre">plot_u(u,</span> <span class="pre">x,</span> <span class="pre">t,</span> <span class="pre">n)</span></code> can be called as a standard
callback function from <code class="docutils literal"><span class="pre">solver</span></code>.</p>
</div>
<div class="section" id="making-movie-files">
<h4>Making movie files<a class="headerlink" href="#making-movie-files" title="Permalink to this headline">¶</a></h4>
<p>From the
<code class="docutils literal"><span class="pre">frame_*.png</span></code> files containing the frames in the animation we can
make video files.
The section <a class="reference internal" href="._book002.html#vib-ode1-anim"><span class="std std-ref">Making animations</span></a> presents basic information on how to
use the <code class="docutils literal"><span class="pre">ffmpeg</span></code> (or <code class="docutils literal"><span class="pre">ffmpeg</span></code>) program for producing video files
in different modern formats: Flash, MP4, Webm, and Ogg.</p>
<p>The <code class="docutils literal"><span class="pre">viz</span></code> function creates an <code class="docutils literal"><span class="pre">ffmpeg</span></code> or <code class="docutils literal"><span class="pre">ffmpeg</span></code> command
with the proper arguments for each of the formats Flash, MP4, WebM,
and Ogg. The task is greatly simplified by having a
<code class="docutils literal"><span class="pre">codec2ext</span></code> dictionary for mapping
video codec names to filename extensions.
As mentioned in the section <a class="reference internal" href="._book002.html#vib-ode1-anim"><span class="std std-ref">Making animations</span></a>, only
two formats are actually needed to ensure that all browsers can
successfully play the video: MP4 and WebM.</p>
<p>Some animations having a large number of plot files may not
be properly combined into a video using <code class="docutils literal"><span class="pre">ffmpeg</span></code> or <code class="docutils literal"><span class="pre">ffmpeg</span></code>.
A method that always works is to play the PNG files as an animation
in a browser using JavaScript code in an HTML file.
The SciTools package has a function <code class="docutils literal"><span class="pre">movie</span></code> (or a stand-alone command
<code class="docutils literal"><span class="pre">scitools</span> <span class="pre">movie</span></code>) for creating such an HTML player. The <code class="docutils literal"><span class="pre">plt.movie</span></code>
call in the <code class="docutils literal"><span class="pre">viz</span></code> function shows how the function is used.
The file <code class="docutils literal"><span class="pre">movie.html</span></code> can be loaded into a browser and features
a user interface where the speed of the animation can be controlled.
Note that the movie in this case consists of the <code class="docutils literal"><span class="pre">movie.html</span></code> file
and all the frame files <code class="docutils literal"><span class="pre">tmp_*.png</span></code>.</p>
</div>
<div class="section" id="skipping-frames-for-animation-speed">
<h4>Skipping frames for animation speed<a class="headerlink" href="#skipping-frames-for-animation-speed" title="Permalink to this headline">¶</a></h4>
<p>Sometimes the time step is small and <span class="math">\(T\)</span> is large, leading to an
inconveniently large number of plot files and a slow animation on the
screen. The solution to such a problem is to decide on a total number
of frames in the animation, <code class="docutils literal"><span class="pre">num_frames</span></code>, and plot the solution only for
every <code class="docutils literal"><span class="pre">skip_frame</span></code> frames. For example, setting <code class="docutils literal"><span class="pre">skip_frame=5</span></code> leads
to plots of every 5 frames. The default value <code class="docutils literal"><span class="pre">skip_frame=1</span></code> plots
every frame.
The total number of time levels (i.e., maximum
possible number of frames) is the length of <code class="docutils literal"><span class="pre">t</span></code>, <code class="docutils literal"><span class="pre">t.size</span></code> (or <code class="docutils literal"><span class="pre">len(t)</span></code>),
so if we want <code class="docutils literal"><span class="pre">num_frames</span></code> frames in the animation,
we need to plot every <code class="docutils literal"><span class="pre">t.size/num_frames</span></code> frames:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">skip_frame</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">num_frames</span><span class="p">))</span>
<span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">skip_frame</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
    <span class="n">st</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s1">&#39;r-&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>The initial condition (<code class="docutils literal"><span class="pre">n=0</span></code>) is included by <code class="docutils literal"><span class="pre">n</span> <span class="pre">%</span> <span class="pre">skip_frame</span> <span class="pre">==</span> <span class="pre">0</span></code>,
as well as every <code class="docutils literal"><span class="pre">skip_frame</span></code>-th frame.
As <code class="docutils literal"><span class="pre">n</span> <span class="pre">%</span> <span class="pre">skip_frame</span> <span class="pre">==</span> <span class="pre">0</span></code> will very seldom be true for the
very final frame, we must also check if <code class="docutils literal"><span class="pre">n</span> <span class="pre">==</span> <span class="pre">t.size-1</span></code> to
get the final frame included.</p>
<p>A simple choice of numbers may illustrate the formulas: say we have
801 frames in total (<code class="docutils literal"><span class="pre">t.size</span></code>) and we allow only 60 frames to be
plotted. As <code class="docutils literal"><span class="pre">n</span></code> then runs from 801 to 0, we need to plot every 801/60
frame, which with integer division yields 13 as <code class="docutils literal"><span class="pre">skip_frame</span></code>. Using
the mod function, <code class="docutils literal"><span class="pre">n</span> <span class="pre">%</span> <span class="pre">skip_frame</span></code>, this operation is zero every time
<code class="docutils literal"><span class="pre">n</span></code> can be divided by 13 without a remainder. That is, the <code class="docutils literal"><span class="pre">if</span></code> test
is true when <code class="docutils literal"><span class="pre">n</span></code> equals <span class="math">\(0, 13, 26, 39, ..., 780, 801\)</span>. The associated
code is included in the <code class="docutils literal"><span class="pre">plot_u</span></code> function, inside the <code class="docutils literal"><span class="pre">viz</span></code> function,
in the file <a class="reference external" href="http://tinyurl.com/nu656p2/wave/wave1D/wave1D_u0.py">wave1D_u0.py</a>.</p>
</div>
</div>
<div class="section" id="running-a-case">
<span id="wave-pde1-guitar-data"></span><h3>Running a case<a class="headerlink" href="#running-a-case" title="Permalink to this headline">¶</a></h3>
<p>The first demo of our 1D wave equation solver concerns vibrations of a
string that is initially deformed to a triangular shape, like when picking
a guitar string:</p>
<div class="math" id="eq-wave-pde1-guitar-i">
\[\begin{split}\tag{192}
I(x) = \left\lbrace
    \begin{array}{ll}
    ax/x_0, &amp; x &lt; x_0,\\
    a(L-x)/(L-x_0), &amp; \hbox{otherwise}
    \end{array}\right.\end{split}\]</div>
<p>We choose <span class="math">\(L=75\)</span> cm, <span class="math">\(x_0=0.8L\)</span>, <span class="math">\(a=5\)</span> mm, and a time frequency
<span class="math">\(\nu = 440\)</span> Hz. The relation between the wave speed <span class="math">\(c\)</span> and <span class="math">\(\nu\)</span> is
<span class="math">\(c=\nu\lambda\)</span>, where <span class="math">\(\lambda\)</span> is the wavelength, taken as <span class="math">\(2L\)</span> because
the longest wave on the string forms half a wavelength. There is no
external force, so <span class="math">\(f=0\)</span> (meaning we can neglect gravity),
and the string is at rest initially, implying <span class="math">\(V=0\)</span>.</p>
<p>Regarding numerical parameters, we need to specify a <span class="math">\(\Delta t\)</span>.
Sometimes it is more natural to think of a spatial resolution instead
of a time step. A natural semi-coarse spatial resolution in the present
problem is <span class="math">\(N_x=50\)</span>. We can then choose the associated <span class="math">\(\Delta t\)</span> (as required
by the <code class="docutils literal"><span class="pre">viz</span></code> and <code class="docutils literal"><span class="pre">solver</span></code> functions) as the stability limit:
<span class="math">\(\Delta t = L/(N_xc)\)</span>. This is the <span class="math">\(\Delta t\)</span> to be specified,
but notice that if <span class="math">\(C&lt;1\)</span>, the actual <span class="math">\(\Delta x\)</span> computed in <code class="docutils literal"><span class="pre">solver</span></code> gets
larger than <span class="math">\(L/N_x\)</span>: <span class="math">\(\Delta x = c\Delta t/C = L/(N_xC)\)</span>. (The reason
is that we fix <span class="math">\(\Delta t\)</span> and adjust <span class="math">\(\Delta x\)</span>, so if <span class="math">\(C\)</span> gets
smaller, the code implements this effect in terms of a larger <span class="math">\(\Delta x\)</span>.)</p>
<p>A function for setting the physical and numerical parameters and
calling <code class="docutils literal"><span class="pre">viz</span></code> in this application goes as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">guitar</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Triangular wave (pulled guitar string).&quot;&quot;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="mf">0.75</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="mf">0.8</span><span class="o">*</span><span class="n">L</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">0.005</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="mi">440</span>
    <span class="n">wavelength</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">L</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">freq</span><span class="o">*</span><span class="n">wavelength</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">freq</span>
    <span class="n">num_periods</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">omega</span><span class="o">*</span><span class="n">num_periods</span>
    <span class="c1"># Choose dt the same as the stability limit for Nx=50</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">L</span><span class="o">/</span><span class="mf">50.</span><span class="o">/</span><span class="n">c</span>

    <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="n">x0</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">x0</span> <span class="k">else</span> <span class="n">a</span><span class="o">/</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">x</span><span class="p">)</span>

    <span class="n">umin</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.2</span><span class="o">*</span><span class="n">a</span><span class="p">;</span>  <span class="n">umax</span> <span class="o">=</span> <span class="o">-</span><span class="n">umin</span>
    <span class="n">cpu</span> <span class="o">=</span> <span class="n">viz</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">,</span>
              <span class="n">animate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">tool</span><span class="o">=</span><span class="s1">&#39;scitools&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The associated program has the name <a class="reference external" href="http://tinyurl.com/nu656p2/wave/wave1D/wave1D_u0.py">wave1D_u0.py</a>. Run
the program and watch the <a class="reference external" href="http://tinyurl.com/pu5uyfn/pub/pub/wave/html/mov-wave/guitar_C0.8/movie.html">movie of the vibrating string</a>.
The string should ideally consist of straight segments, but these are
somewhat wavy due to numerical approximation. Run the case with the
<code class="docutils literal"><span class="pre">wave1D_u0.py</span></code> code and <span class="math">\(C=1\)</span> to see the exact solution.</p>
</div>
<div class="section" id="working-with-a-scaled-pde-model">
<h3>Working with a scaled PDE model<a class="headerlink" href="#working-with-a-scaled-pde-model" title="Permalink to this headline">¶</a></h3>
<p>Depending on the model, it may be a substantial job to establish
consistent and relevant physical parameter values for a case.  The
guitar string example illustrates the point.  However, by <em>scaling</em>
the mathematical problem we can often reduce the need to estimate
physical parameters dramatically. The scaling technique consists of
introducing new independent and dependent variables, with the aim that
the absolute values of these lie in <span class="math">\([0,1]\)</span>. We introduce the
dimensionless variables (details are found in the section
<a class="reference external" href="http://hplgit.github.io/scaling-book/doc/pub/book/html/._scaling-book007.html#sec:scale:wave:bc_u0">Homogeneous Dirichlet conditions in 1D</a>
in the book <a class="reference external" href="http://tinyurl.com/qfjgxmf/web">Scaling of differential equations</a> <a class="reference internal" href="._book027.html#ref03" id="id2">[Ref03]</a></p>
<div class="math">
\[\bar x = \frac{x}{L},\quad \bar t = \frac{c}{L}t,\quad
\bar u = \frac{u}{a}
{\thinspace .}\]</div>
<p>Here, <span class="math">\(L\)</span> is a typical length scale, e.g., the length of the domain,
and <span class="math">\(a\)</span> is a typical size of <span class="math">\(u\)</span>, e.g., determined from the
initial condition: <span class="math">\(a=\max_x|I(x)|\)</span>.</p>
<p>We get by the chain rule that</p>
<div class="math">
\[\frac{\partial u}{\partial t} =
\frac{\partial}{\partial\bar t}\left(a\bar u\right)
\frac{d\bar t}{dt} =
\frac{ac}{L}\frac{\partial\bar u}{\partial\bar t}{\thinspace .}\]</div>
<p>Similarly,</p>
<div class="math">
\[\frac{\partial u}{\partial x}
= \frac{a}{L}\frac{\partial\bar u}{\partial\bar x}{\thinspace .}\]</div>
<p>Inserting the dimensionless variables in the PDE gives, in case <span class="math">\(f=0\)</span>,</p>
<div class="math">
\[\frac{a^2c^2}{L^2}\frac{\partial^2\bar u}{\partial\bar t^2}
= \frac{a^2c^2}{L^2}\frac{\partial^2\bar u}{\partial\bar x^2}{\thinspace .}\]</div>
<p>Dropping the bars, we arrive at the scaled PDE</p>
<div class="math" id="eq-auto68">
\[\tag{193}
\frac{\partial^2 u}{\partial t^2} = \frac{\partial^2 u}{\partial x^2},
    \quad x\in (0,1),\ t\in (0,cT/L),\]</div>
<p>which has no parameter <span class="math">\(c^2\)</span> anymore. The initial conditions are scaled
as</p>
<div class="math">
\[a\bar u(\bar x, 0) = I(L\bar x)\]</div>
<p>and</p>
<div class="math">
\[\frac{a}{L/c}\frac{\partial\bar u}{\partial\bar t}(\bar x,0) = V(L\bar x),\]</div>
<p>resulting in</p>
<div class="math">
\[\bar u(\bar x, 0) = \frac{I(L\bar x)}{\max_x |I(x)|},\quad
\frac{\partial\bar u}{\partial\bar t}(\bar x,0) = \frac{L}{ac}V(L\bar x){\thinspace .}\]</div>
<p>In the common case <span class="math">\(V=0\)</span> we see that there are no physical parameters to be
estimated in the PDE model!</p>
<p>If we have a program implemented for the physical wave equation with
dimensions, we can obtain the dimensionless, scaled version by
setting <span class="math">\(c=1\)</span>. The initial condition of a guitar string,
given in <a class="reference internal" href="#eq-wave-pde1-guitar-i"><span class="std std-ref">(192)</span></a>, gets its scaled form by choosing
<span class="math">\(a=1\)</span>, <span class="math">\(L=1\)</span>, and <span class="math">\(x_0\in [0,1]\)</span>. This means that we only need to
decide on the <span class="math">\(x_0\)</span> value as a fraction of unity, because
the scaled problem corresponds to setting all
other parameters to unity. In the code we can just set
<code class="docutils literal"><span class="pre">a=c=L=1</span></code>, <code class="docutils literal"><span class="pre">x0=0.8</span></code>, and there is no need to calculate with
wavelengths and frequencies to estimate <span class="math">\(c\)</span>!</p>
<p>The only non-trivial parameter to estimate in the scaled problem
is the final end time of the simulation, or more precisely, how it relates
to periods in periodic solutions in time, since we often want to
express the end time as a certain number of periods.
The period in the dimensionless problem is 2, so the end time can be
set to the desired number of periods times 2.</p>
<p>Why the dimensionless period is 2 can be explained by the following
reasoning.
Suppose that <span class="math">\(u\)</span> behaves as <span class="math">\(\cos (\omega t)\)</span> in time in the original
problem with dimensions. The corresponding period is then <span class="math">\(P=2\pi/\omega\)</span>, but
we need to estimate <span class="math">\(\omega\)</span>. A typical solution of the wave
equation is <span class="math">\(u(x,t)=A\cos(kx)\cos(\omega t)\)</span>, where <span class="math">\(A\)</span> is an amplitude
and <span class="math">\(k\)</span> is related to the wave length <span class="math">\(\lambda\)</span> in space: <span class="math">\(\lambda = 2\pi/k\)</span>.
Both <span class="math">\(\lambda\)</span> and <span class="math">\(A\)</span> will be given by the initial condition <span class="math">\(I(x)\)</span>.
Inserting this <span class="math">\(u(x,t)\)</span> in the PDE yields <span class="math">\(-\omega^2 = -c^2k^2\)</span>, i.e.,
<span class="math">\(\omega = kc\)</span>. The period is therefore <span class="math">\(P=2\pi/(kc)\)</span>.
If the boundary conditions are <span class="math">\(u(0,t)=u(L,t)\)</span>, we need to have
<span class="math">\(kL = n\pi\)</span> for integer <span class="math">\(n\)</span>. The period becomes <span class="math">\(P=2L/nc\)</span>. The longest
period is <span class="math">\(P=2L/c\)</span>. The dimensionless period <span class="math">\(\tilde P\)</span> is obtained
by dividing <span class="math">\(P\)</span> by the time scale <span class="math">\(L/c\)</span>, which results in <span class="math">\(\tilde P=2\)</span>.
Shorter waves in the initial condition will have a dimensionless
shorter period <span class="math">\(\tilde P=2/n\)</span> (<span class="math">\(n&gt;1\)</span>).</p>
</div>
</div>
<div class="section" id="vectorization">
<span id="wave-pde1-impl-vec"></span><h2>Vectorization<a class="headerlink" href="#vectorization" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-14"></span><p id="index-15">The computational algorithm for solving the wave equation visits one
mesh point at a time and evaluates a formula for the new value
<span class="math">\(u_i^{n+1}\)</span> at that point. Technically, this is implemented by a loop
over array elements in a program. Such loops may run slowly in Python
(and similar interpreted languages such as R and MATLAB).  One
technique for speeding up loops is to perform operations on entire
arrays instead of working with one element at a time. This is referred
to as <em>vectorization</em>, <em>vector computing</em>, or <em>array computing</em>.
Operations on whole arrays are possible if the computations involving
each element is independent of each other and therefore can, at least
in principle, be performed simultaneously.  That is, vectorization not
only speeds up the code on serial computers, but also makes it easy to
exploit parallel computing. Actually, there are Python tools like
<a class="reference external" href="http://numba.pydata.org">Numba</a> that can automatically turn
vectorized code into parallel code.</p>
<div class="section" id="operations-on-slices-of-arrays">
<span id="wave-pde1-impl-vec-slices-basics"></span><h3>Operations on slices of arrays<a class="headerlink" href="#operations-on-slices-of-arrays" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-16"></span><span class="target" id="index-17"></span><span class="target" id="index-18"></span><span class="target" id="index-19"></span><p id="index-20">Efficient computing with <code class="docutils literal"><span class="pre">numpy</span></code> arrays demands that we avoid loops
and compute with entire arrays at once (or at least large portions of them).
Consider this calculation of differences <span class="math">\(d_i = u_{i+1}-u_i\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">size</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>All the differences here are independent of each other.
The computation of <code class="docutils literal"><span class="pre">d</span></code> can therefore alternatively be done by
subtracting the array <span class="math">\((u_0,u_n,\ldots,u_{n-1})\)</span> from
the array where the elements are shifted one index upwards:
<span class="math">\((u_n,u_nm1,\ldots,u_n)\)</span>, see Figure <a class="reference internal" href="#wave-pde1-vec-fig1"><span class="std std-ref">Illustration of subtracting two slices of two arrays</span></a>.
The former subset of the array can be
expressed by <code class="docutils literal"><span class="pre">u[0:n-1]</span></code>,
<code class="docutils literal"><span class="pre">u[0:-1]</span></code>, or just
<code class="docutils literal"><span class="pre">u[:-1]</span></code>, meaning from index 0 up to,
but not including, the last element (<code class="docutils literal"><span class="pre">-1</span></code>). The latter subset
is obtained by <code class="docutils literal"><span class="pre">u[1:n]</span></code> or <code class="docutils literal"><span class="pre">u[1:]</span></code>,
meaning from index 1 and the rest of the array.
The computation of <code class="docutils literal"><span class="pre">d</span></code> can now be done without an explicit Python loop:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>or with explicit limits if desired:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Indices with a colon, going from an index to (but not including) another
index are called <em>slices</em>. With <code class="docutils literal"><span class="pre">numpy</span></code> arrays, the computations
are still done by loops, but in efficient, compiled, highly optimized
C or Fortran code. Such loops are sometimes referred to as <em>vectorized
loops</em>. Such loops can also easily be distributed
among many processors on parallel computers. We say that the <em>scalar code</em>
above, working on an element (a scalar) at a time, has been replaced by
an equivalent <em>vectorized code</em>. The process of vectorizing code is called
<em>vectorization</em>.</p>
<div class="figure" id="id5">
<span id="wave-pde1-vec-fig1"></span><a class="reference internal image-reference" href="_images/vectorized_diff.png"><img alt="_images/vectorized_diff.png" src="_images/vectorized_diff.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>Illustration of subtracting two slices of two arrays</em></span></p>
</div>
<div class="admonition-test-your-understanding admonition">
<p class="first admonition-title">Test your understanding</p>
<p class="last">Newcomers to vectorization are encouraged to choose
a small array <code class="docutils literal"><span class="pre">u</span></code>, say with five elements,
and simulate with pen and paper
both the loop version and the vectorized version above.</p>
</div>
<p>Finite difference schemes basically contain differences between array
elements with shifted indices. As an example,
consider the updating formula</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>The vectorization consists of replacing the loop by arithmetics on
slices of arrays of length <code class="docutils literal"><span class="pre">n-2</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u2</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
<span class="n">u2</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>   <span class="c1"># alternative</span>
</pre></div>
</div>
<p>Note that the length of <code class="docutils literal"><span class="pre">u2</span></code> becomes <code class="docutils literal"><span class="pre">n-2</span></code>. If <code class="docutils literal"><span class="pre">u2</span></code> is already an array of
length <code class="docutils literal"><span class="pre">n</span></code> and we want to use the formula to update all the &#8220;inner&#8221;
elements of <code class="docutils literal"><span class="pre">u2</span></code>, as we will when solving a 1D wave equation, we can write</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="o">=</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
<span class="n">u2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>   <span class="c1"># alternative</span>
</pre></div>
</div>
<p>The first expression&#8217;s right-hand side is realized by the
following steps, involving temporary arrays with intermediate results,
since each array operation can only involve one or two arrays.
The <code class="docutils literal"><span class="pre">numpy</span></code> package performs (behind the scenes) the first line above in
four steps:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>temp1 = 2*u[1:-1]
temp2 = u[:-2] - temp1
temp3 = temp2 + u[2:]
u2[1:-1] = temp3
</pre></div>
</div>
<p>We need three temporary arrays, but a user does not need to worry about
such temporary arrays.</p>
<div class="admonition-common-mistakes-with-array-slices admonition">
<p class="first admonition-title">Common mistakes with array slices</p>
<p>Array expressions with slices demand that the slices have the same
shape. It easy to make a mistake in, e.g.,</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<p>and write</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<p>Now <code class="docutils literal"><span class="pre">u[1:n]</span></code> has wrong length (<code class="docutils literal"><span class="pre">n-1</span></code>) compared to the other array
slices, causing a <code class="docutils literal"><span class="pre">ValueError</span></code> and the message
<code class="docutils literal"><span class="pre">could</span> <span class="pre">not</span> <span class="pre">broadcast</span> <span class="pre">input</span> <span class="pre">array</span> <span class="pre">from</span> <span class="pre">shape</span> <span class="pre">103</span> <span class="pre">into</span> <span class="pre">shape</span> <span class="pre">104</span></code>
(if <code class="docutils literal"><span class="pre">n</span></code> is 105). When such errors occur one must closely examine
all the slices. Usually, it is easier to get upper limits of slices
right when they use <code class="docutils literal"><span class="pre">-1</span></code> or <code class="docutils literal"><span class="pre">-2</span></code> or empty limit rather than
expressions involving the length.</p>
<p>Another common mistake is to forget the slice in the array on the
left-hand side,</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u2</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<p class="last">This is really crucial: now <code class="docutils literal"><span class="pre">u2</span></code> becomes a <em>new</em> array of length
<code class="docutils literal"><span class="pre">n-2</span></code>, which is the wrong length as we have no entries for the boundary
values. We meant to insert the right-hand side array <em>into</em> the
original <code class="docutils literal"><span class="pre">u2</span></code> array for the entries that correspond to the
internal points in the mesh (<code class="docutils literal"><span class="pre">1:n-1</span></code> or <code class="docutils literal"><span class="pre">1:-1</span></code>).</p>
</div>
<p>Vectorization may also work nicely with functions. To illustrate, we may
extend the previous example as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>Assuming <code class="docutils literal"><span class="pre">u2</span></code>, <code class="docutils literal"><span class="pre">u</span></code>, and <code class="docutils literal"><span class="pre">x</span></code> all have length <code class="docutils literal"><span class="pre">n</span></code>, the vectorized
version becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>Obviously, <code class="docutils literal"><span class="pre">f</span></code> must be able to take an array as argument for <code class="docutils literal"><span class="pre">f(x[1:-1])</span></code>
to make sense.</p>
</div>
<div class="section" id="finite-difference-schemes-expressed-as-slices">
<span id="wave-pde1-impl-vec-slices-fdm"></span><h3>Finite difference schemes expressed as slices<a class="headerlink" href="#finite-difference-schemes-expressed-as-slices" title="Permalink to this headline">¶</a></h3>
<p>We now have the necessary tools to vectorize the wave equation
algorithm as described mathematically in the section <a class="reference internal" href="#wave-string-alg"><span class="std std-ref">Formulating a recursive algorithm</span></a>
and through code in the section <a class="reference internal" href="#wave-pde1-impl-solver"><span class="std std-ref">The solver function</span></a>.  There are
three loops: one for the initial condition, one for the first time
step, and finally the loop that is repeated for all subsequent time
levels. Since only the latter is repeated a potentially large number
of times, we limit our vectorization efforts to this loop:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_nm1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
           <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The vectorized version becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u_nm1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_n</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
          <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_n</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_n</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_n</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_n</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Nx</span><span class="p">]</span><span class="o">-</span> <span class="n">u_nm1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Nx</span><span class="p">]</span> <span class="o">+</span> \
          <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_n</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Nx</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_n</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The program
<a class="reference external" href="http://tinyurl.com/nu656p2/wave/wave1D/wave1D_u0v.py">wave1D_u0v.py</a>
contains a new version of the function <code class="docutils literal"><span class="pre">solver</span></code> where both the scalar
and the vectorized loops are included (the argument <code class="docutils literal"><span class="pre">version</span></code> is
set to <code class="docutils literal"><span class="pre">scalar</span></code> or <code class="docutils literal"><span class="pre">vectorized</span></code>, respectively).</p>
</div>
<div class="section" id="verification-5">
<span id="wave-pde1-impl-vec-verify-quadratic"></span><h3>Verification<a class="headerlink" href="#verification-5" title="Permalink to this headline">¶</a></h3>
<p id="index-21">We may reuse the quadratic solution <span class="math">\({u_{\small\mbox{e}}}(x,t)=x(L-x)(1+{\frac{1}{2}}t)\)</span> for
verifying also the vectorized code. A test function can now verify
both the scalar and the vectorized version. Moreover, we may
use a <code class="docutils literal"><span class="pre">user_action</span></code> function that compares the computed and exact
solution at each time level and performs a test:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_quadratic</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check the scalar and vectorized versions for</span>
<span class="sd">    a quadratic u(x,t)=x(L-x)(1+t/2) that is exactly reproduced.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The following function must work for x as array or scalar</span>
    <span class="n">u_exact</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">L</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># f is a scalar (zeros_like(x) works for scalar x too)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

    <span class="n">L</span> <span class="o">=</span> <span class="mf">2.5</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mf">1.5</span>
    <span class="n">C</span> <span class="o">=</span> <span class="mf">0.75</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># Very coarse mesh for this exact test</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">C</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">/</span><span class="n">Nx</span><span class="p">)</span><span class="o">/</span><span class="n">c</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">18</span>

    <span class="k">def</span> <span class="nf">assert_no_error</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-13</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span>

    <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>
           <span class="n">user_action</span><span class="o">=</span><span class="n">assert_no_error</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s1">&#39;scalar&#39;</span><span class="p">)</span>
    <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>
           <span class="n">user_action</span><span class="o">=</span><span class="n">assert_no_error</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s1">&#39;vectorized&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-lambda-functions admonition">
<p class="first admonition-title">Lambda functions</p>
<p>The code segment above demonstrates how to achieve very
compact code, without degraded readability,
by use of lambda functions for the various
input parameters that require a Python function. In essence,</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">L</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<p>is equivalent to</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">L</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<p>Note that lambda functions can just contain a single expression and no
statements.</p>
<p>One advantage with lambda functions is that they can be used directly
in calls:</p>
<div class="last highlight-python"><div class="highlight"><pre><span></span><span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="n">L</span><span class="p">),</span> <span class="n">V</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="efficiency-measurements">
<h3>Efficiency measurements<a class="headerlink" href="#efficiency-measurements" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">wave1D_u0v.py</span></code> contains our new <code class="docutils literal"><span class="pre">solver</span></code> function with both
scalar and vectorized code. For comparing the efficiency
of scalar versus vectorized code, we need a <code class="docutils literal"><span class="pre">viz</span></code> function
as discussed in the section <a class="reference internal" href="#wave-pde1-impl-animate"><span class="std std-ref">Visualization: animating the solution</span></a>.
All of this <code class="docutils literal"><span class="pre">viz</span></code> function can be reused, except the call
to <code class="docutils literal"><span class="pre">solver_function</span></code>. This call lacks the parameter
<code class="docutils literal"><span class="pre">version</span></code>, which we want to set to <code class="docutils literal"><span class="pre">vectorized</span></code> and <code class="docutils literal"><span class="pre">scalar</span></code>
for our efficiency measurements.</p>
<p>One solution is to copy the <code class="docutils literal"><span class="pre">viz</span></code> code from <code class="docutils literal"><span class="pre">wave1D_u0</span></code> into
<code class="docutils literal"><span class="pre">wave1D_u0v.py</span></code> and add a <code class="docutils literal"><span class="pre">version</span></code> argument to the <code class="docutils literal"><span class="pre">solver_function</span></code> call.
Taking into account how much animation code we
then duplicate, this is not a good idea.
Alternatively,
introducing the <code class="docutils literal"><span class="pre">version</span></code> argument in <code class="docutils literal"><span class="pre">wave1D_u0.viz</span></code>, so that this function
can be imported into <code class="docutils literal"><span class="pre">wave1D_u0v.py</span></code>, is not
a good solution either, since <code class="docutils literal"><span class="pre">version</span></code> has no meaning in that file.
We need better ideas!</p>
<div class="section" id="solution-1">
<h4>Solution 1<a class="headerlink" href="#solution-1" title="Permalink to this headline">¶</a></h4>
<p>Calling <code class="docutils literal"><span class="pre">viz</span></code> in <code class="docutils literal"><span class="pre">wave1D_u0</span></code> with <code class="docutils literal"><span class="pre">solver_function</span></code> as our new
solver in <code class="docutils literal"><span class="pre">wave1D_u0v</span></code> works fine, since this solver has
<code class="docutils literal"><span class="pre">version='vectorized'</span></code> as default value. The problem arises when we
want to test <code class="docutils literal"><span class="pre">version='scalar'</span></code>. The simplest solution is then
to use <code class="docutils literal"><span class="pre">wave1D_u0.solver</span></code> instead. We make a new <code class="docutils literal"><span class="pre">viz</span></code> function
in <code class="docutils literal"><span class="pre">wave1D_u0v.py</span></code> that has a <code class="docutils literal"><span class="pre">version</span></code> argument and that just
calls <code class="docutils literal"><span class="pre">wave1D_u0.viz</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">viz</span><span class="p">(</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>  <span class="c1"># PDE parameters</span>
    <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">,</span>               <span class="c1"># Interval for u in plots</span>
    <span class="n">animate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>             <span class="c1"># Simulation with animation?</span>
    <span class="n">tool</span><span class="o">=</span><span class="s1">&#39;matplotlib&#39;</span><span class="p">,</span>        <span class="c1"># &#39;matplotlib&#39; or &#39;scitools&#39;</span>
    <span class="n">solver_function</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span>   <span class="c1"># Function with numerical algorithm</span>
    <span class="n">version</span><span class="o">=</span><span class="s1">&#39;vectorized&#39;</span><span class="p">,</span>     <span class="c1"># &#39;scalar&#39; or &#39;vectorized&#39;</span>
    <span class="p">):</span>
    <span class="kn">import</span> <span class="nn">wave1D_u0</span>
    <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="s1">&#39;vectorized&#39;</span><span class="p">:</span>
        <span class="c1"># Reuse viz from wave1D_u0, but with the present</span>
        <span class="c1"># modules&#39; new vectorized solver (which has</span>
        <span class="c1"># version=&#39;vectorized&#39; as default argument;</span>
        <span class="c1"># wave1D_u0.viz does not feature this argument)</span>
        <span class="n">cpu</span> <span class="o">=</span> <span class="n">wave1D_u0</span><span class="o">.</span><span class="n">viz</span><span class="p">(</span>
            <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">,</span>
            <span class="n">animate</span><span class="p">,</span> <span class="n">tool</span><span class="p">,</span> <span class="n">solver_function</span><span class="o">=</span><span class="n">solver</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">version</span> <span class="o">==</span> <span class="s1">&#39;scalar&#39;</span><span class="p">:</span>
        <span class="c1"># Call wave1D_u0.viz with a solver with</span>
        <span class="c1"># scalar code and use wave1D_u0.solver.</span>
        <span class="n">cpu</span> <span class="o">=</span> <span class="n">wave1D_u0</span><span class="o">.</span><span class="n">viz</span><span class="p">(</span>
            <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">,</span>
            <span class="n">animate</span><span class="p">,</span> <span class="n">tool</span><span class="p">,</span>
            <span class="n">solver_function</span><span class="o">=</span><span class="n">wave1D_u0</span><span class="o">.</span><span class="n">solver</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="solution-2">
<h4>Solution 2<a class="headerlink" href="#solution-2" title="Permalink to this headline">¶</a></h4>
<p>There is a more advanced and fancier solution featuring a very useful trick:
we can make a new function that will always call <code class="docutils literal"><span class="pre">wave1D_u0v.solver</span></code>
with <code class="docutils literal"><span class="pre">version='scalar'</span></code>. The <code class="docutils literal"><span class="pre">functools.partial</span></code> function from
standard Python takes a function <code class="docutils literal"><span class="pre">func</span></code> as argument and
a series of positional and keyword arguments and returns a
new function that will call <code class="docutils literal"><span class="pre">func</span></code> with the supplied arguments,
while the user can control all the other arguments in <code class="docutils literal"><span class="pre">func</span></code>.
Consider a trivial example,</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
</pre></div>
</div>
<p>We want to ensure that <code class="docutils literal"><span class="pre">f</span></code> is always called with <code class="docutils literal"><span class="pre">c=3</span></code>, i.e., <code class="docutils literal"><span class="pre">f</span></code>
has only two &#8220;free&#8221; arguments <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code>.
This functionality is obtained by</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">functools</span>
<span class="n">f2</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="k">print</span> <span class="n">f2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># results in 1+2+3=6</span>
</pre></div>
</div>
<p>Now <code class="docutils literal"><span class="pre">f2</span></code> calls <code class="docutils literal"><span class="pre">f</span></code> with whatever the user supplies as <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code>,
but <code class="docutils literal"><span class="pre">c</span></code> is always <code class="docutils literal"><span class="pre">3</span></code>.</p>
<p>Back to our <code class="docutils literal"><span class="pre">viz</span></code> code, we can do</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">functools</span>
<span class="c1"># Call wave1D_u0.solver with version fixed to scalar</span>
<span class="n">scalar_solver</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">wave1D_u0</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s1">&#39;scalar&#39;</span><span class="p">)</span>
<span class="n">cpu</span> <span class="o">=</span> <span class="n">wave1D_u0</span><span class="o">.</span><span class="n">viz</span><span class="p">(</span>
        <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">,</span>
        <span class="n">animate</span><span class="p">,</span> <span class="n">tool</span><span class="p">,</span> <span class="n">solver_function</span><span class="o">=</span><span class="n">scalar_solver</span><span class="p">)</span>
</pre></div>
</div>
<p>The new <code class="docutils literal"><span class="pre">scalar_solver</span></code> takes the same arguments as
<code class="docutils literal"><span class="pre">wave1D_u0.scalar</span></code> and calls <code class="docutils literal"><span class="pre">wave1D_u0v.scalar</span></code>,
but always supplies the extra argument
<code class="docutils literal"><span class="pre">version='scalar'</span></code>. When sending this <code class="docutils literal"><span class="pre">solver_function</span></code>
to <code class="docutils literal"><span class="pre">wave1D_u0.viz</span></code>, the latter will call <code class="docutils literal"><span class="pre">wave1D_u0v.solver</span></code>
with all the <code class="docutils literal"><span class="pre">I</span></code>, <code class="docutils literal"><span class="pre">V</span></code>, <code class="docutils literal"><span class="pre">f</span></code>, etc., arguments we supply, plus
<code class="docutils literal"><span class="pre">version='scalar'</span></code>.</p>
</div>
<div class="section" id="efficiency-experiments">
<h4>Efficiency experiments<a class="headerlink" href="#efficiency-experiments" title="Permalink to this headline">¶</a></h4>
<p>We now have a <code class="docutils literal"><span class="pre">viz</span></code> function that can call our solver function both in
scalar and vectorized mode. The function <code class="docutils literal"><span class="pre">run_efficiency_experiments</span></code>
in <code class="docutils literal"><span class="pre">wave1D_u0v.py</span></code> performs a set of experiments and reports the
CPU time spent in the scalar and vectorized solver for
the previous string vibration example with spatial mesh resolutions
<span class="math">\(N_x=50,100,200,400,800\)</span>. Running this function reveals
that the vectorized
code runs substantially faster: the vectorized code runs approximately
<span class="math">\(N_x/10\)</span> times as fast as the scalar code!</p>
</div>
</div>
<div class="section" id="remark-on-the-updating-of-arrays">
<span id="wave-pde1-impl-ref-switch"></span><h3>Remark on the updating of arrays<a class="headerlink" href="#remark-on-the-updating-of-arrays" title="Permalink to this headline">¶</a></h3>
<p>At the end of each time step we need to update the <code class="docutils literal"><span class="pre">u_nm1</span></code> and <code class="docutils literal"><span class="pre">u_n</span></code>
arrays such that they have the right content for the next time step:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u_nm1</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u_n</span>
<span class="n">u_n</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u</span>
</pre></div>
</div>
<p>The order here is important: updating <code class="docutils literal"><span class="pre">u_n</span></code> first, makes <code class="docutils literal"><span class="pre">u_nm1</span></code> equal
to <code class="docutils literal"><span class="pre">u</span></code>, which is wrong!</p>
<p>The assignment <code class="docutils literal"><span class="pre">u_n[:]</span> <span class="pre">=</span> <span class="pre">u</span></code> copies the content of the <code class="docutils literal"><span class="pre">u</span></code> array into
the elements of the <code class="docutils literal"><span class="pre">u_n</span></code> array. Such copying takes time, but
that time is negligible compared to the time needed for
computing <code class="docutils literal"><span class="pre">u</span></code> from the finite difference formula,
even when the formula has a vectorized implementation.
However, efficiency of program code is a key topic when solving
PDEs numerically (particularly when there are two or three
space dimensions), so it must be mentioned that there exists a
much more efficient way of making the arrays <code class="docutils literal"><span class="pre">u_nm1</span></code> and <code class="docutils literal"><span class="pre">u_n</span></code>
ready for the next time step. The idea is based on <em>switching
references</em> and explained as follows.</p>
<p>A Python variable is actually a reference to some object (C programmers
may think of pointers). Instead of copying data, we can let <code class="docutils literal"><span class="pre">u_nm1</span></code>
refer to the <code class="docutils literal"><span class="pre">u_n</span></code> object and <code class="docutils literal"><span class="pre">u_n</span></code> refer to the <code class="docutils literal"><span class="pre">u</span></code> object.
This is a very efficient operation (like switching pointers in C).
A naive implementation like</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u_nm1</span> <span class="o">=</span> <span class="n">u_n</span>
<span class="n">u_n</span> <span class="o">=</span> <span class="n">u</span>
</pre></div>
</div>
<p>will fail, however, because now <code class="docutils literal"><span class="pre">u_nm1</span></code> refers to the <code class="docutils literal"><span class="pre">u_n</span></code> object,
but then the name <code class="docutils literal"><span class="pre">u_n</span></code> refers to <code class="docutils literal"><span class="pre">u</span></code>, so that this <code class="docutils literal"><span class="pre">u</span></code> object
has two references, <code class="docutils literal"><span class="pre">u_n</span></code> and <code class="docutils literal"><span class="pre">u</span></code>, while our third array, originally
referred to by <code class="docutils literal"><span class="pre">u_nm1</span></code>, has no more references and is lost.
This means that the variables <code class="docutils literal"><span class="pre">u</span></code>, <code class="docutils literal"><span class="pre">u_n</span></code>, and <code class="docutils literal"><span class="pre">u_nm1</span></code> refer to two
arrays and not three. Consequently, the computations at the next
time level will be messed up since updating the elements in
<code class="docutils literal"><span class="pre">u</span></code> will imply updating the elements in <code class="docutils literal"><span class="pre">u_n</span></code> too so the solution
at the previous time step, which is crucial in our formulas, is
destroyed.</p>
<p>While <code class="docutils literal"><span class="pre">u_nm1</span> <span class="pre">=</span> <span class="pre">u_n</span></code> is fine, <code class="docutils literal"><span class="pre">u_n</span> <span class="pre">=</span> <span class="pre">u</span></code> is problematic, so
the solution to this problem is to ensure that <code class="docutils literal"><span class="pre">u</span></code>
points to the <code class="docutils literal"><span class="pre">u_nm1</span></code> array. This is mathematically wrong, but
new correct values will be filled into <code class="docutils literal"><span class="pre">u</span></code> at the next time step
and make it right.</p>
<p>The correct switch of references is</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">tmp</span> <span class="o">=</span> <span class="n">u_nm1</span>
<span class="n">u_nm1</span> <span class="o">=</span> <span class="n">u_n</span>
<span class="n">u_n</span> <span class="o">=</span> <span class="n">u</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">tmp</span>
</pre></div>
</div>
<p>We can get rid of the temporary reference <code class="docutils literal"><span class="pre">tmp</span></code> by writing</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u_nm1</span><span class="p">,</span> <span class="n">u_n</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">u_n</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_nm1</span>
</pre></div>
</div>
<p>This switching of references for updating our arrays
will be used in later implementations.</p>
<div class="admonition-caution admonition">
<p class="first admonition-title">Caution</p>
<p class="last">The update <code class="docutils literal"><span class="pre">u_nm1,</span> <span class="pre">u_n,</span> <span class="pre">u</span> <span class="pre">=</span> <span class="pre">u_n,</span> <span class="pre">u,</span> <span class="pre">u_nm1</span></code> leaves wrong content in <code class="docutils literal"><span class="pre">u</span></code>
at the final time step. This means that if we return <code class="docutils literal"><span class="pre">u</span></code>, as we
do in the example codes here, we actually return <code class="docutils literal"><span class="pre">u_nm1</span></code>, which is
obviously wrong. It is therefore important to adjust the content
of <code class="docutils literal"><span class="pre">u</span></code> to <code class="docutils literal"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">u_n</span></code> before returning <code class="docutils literal"><span class="pre">u</span></code>. (Note that
the <code class="docutils literal"><span class="pre">user_action</span></code> function
reduces the need to return the solution from the solver.)</p>
</div>
</div>
</div>
<div class="section" id="exercises-2">
<h2>Exercises<a class="headerlink" href="#exercises-2" title="Permalink to this headline">¶</a></h2>
<div class="section" id="exercise-2-1-simulate-a-standing-wave">
<span id="wave-exer-standingwave"></span><h3>Exercise 2.1: Simulate a standing wave<a class="headerlink" href="#exercise-2-1-simulate-a-standing-wave" title="Permalink to this headline">¶</a></h3>
<p>The purpose of this exercise is to simulate standing waves on <span class="math">\([0,L]\)</span>
and illustrate the error in the simulation.
Standing waves arise from an initial condition</p>
<div class="math">
\[u(x,0)= A \sin\left(\frac{\pi}{L}mx\right),\]</div>
<p>where <span class="math">\(m\)</span> is an integer and <span class="math">\(A\)</span> is a freely chosen amplitude.
The corresponding exact solution can be computed and reads</p>
<div class="math">
\[{u_{\small\mbox{e}}}(x,t) =  A\sin\left(\frac{\pi}{L}mx\right)
\cos\left(\frac{\pi}{L}mct\right){\thinspace .}\]</div>
<p><strong>a)</strong>
Explain that for a function <span class="math">\(\sin kx\cos \omega t\)</span> the wave length
in space is <span class="math">\(\lambda = 2\pi /k\)</span> and the period in time is <span class="math">\(P=2\pi/\omega\)</span>.
Use these expressions to find the wave length in space and period in
time of <span class="math">\({u_{\small\mbox{e}}}\)</span> above.</p>
<p><strong>b)</strong>
Import the <code class="docutils literal"><span class="pre">solver</span></code> function from <code class="docutils literal"><span class="pre">wave1D_u0.py</span></code> into a new file
where the <code class="docutils literal"><span class="pre">viz</span></code> function is reimplemented such that it
plots either the numerical <em>and</em> the exact solution, <em>or</em> the error.</p>
<p><strong>c)</strong>
Make animations where you illustrate how the error
<span class="math">\(e^n_i ={u_{\small\mbox{e}}}(x_i, t_n)- u^n_i\)</span>
develops and increases in time. Also make animations of
<span class="math">\(u\)</span> and <span class="math">\({u_{\small\mbox{e}}}\)</span> simultaneously.</p>
<p><strong>Hint 1.</strong>
Quite long time simulations are needed in order to display significant
discrepancies between the numerical and exact solution.</p>
<p><strong>Hint 2.</strong>
A possible set of parameters is <span class="math">\(L=12\)</span>, <span class="math">\(m=9\)</span>, <span class="math">\(c=2\)</span>, <span class="math">\(A=1\)</span>, <span class="math">\(N_x=80\)</span>,
<span class="math">\(C=0.8\)</span>. The error mesh function <span class="math">\(e^n\)</span> can be simulated for 10 periods,
while 20-30 periods are needed to show significant differences between
the curves for the numerical and exact solution.</p>
<p>Filename: <code class="docutils literal"><span class="pre">wave_standing</span></code>.</p>
<div class="section" id="remarks-3">
<h4>Remarks<a class="headerlink" href="#remarks-3" title="Permalink to this headline">¶</a></h4>
<p>The important
parameters for numerical quality are <span class="math">\(C\)</span> and <span class="math">\(k\Delta x\)</span>, where
<span class="math">\(C=c\Delta t/\Delta x\)</span> is the Courant number and <span class="math">\(k\)</span> is defined above
(<span class="math">\(k\Delta x\)</span> is proportional to how many mesh points we have per wave length
in space, see the section <a class="reference internal" href="._book007.html#wave-pde1-num-dispersion"><span class="std std-ref">Numerical dispersion relation</span></a> for explanation).</p>
</div>
</div>
<div class="section" id="exercise-2-2-add-storage-of-solution-in-a-user-action-function">
<span id="wave-exer-store-list"></span><h3>Exercise 2.2: Add storage of solution in a user action function<a class="headerlink" href="#exercise-2-2-add-storage-of-solution-in-a-user-action-function" title="Permalink to this headline">¶</a></h3>
<p>Extend the <code class="docutils literal"><span class="pre">plot_u</span></code> function in the file <code class="docutils literal"><span class="pre">wave1D_u0.py</span></code> to also store
the solutions <code class="docutils literal"><span class="pre">u</span></code> in a list.
To this end, declare <code class="docutils literal"><span class="pre">all_u</span></code> as
an empty list in the <code class="docutils literal"><span class="pre">viz</span></code> function, outside <code class="docutils literal"><span class="pre">plot_u</span></code>, and perform
an append operation inside the <code class="docutils literal"><span class="pre">plot_u</span></code> function. Note that a
function, like <code class="docutils literal"><span class="pre">plot_u</span></code>, inside another function, like <code class="docutils literal"><span class="pre">viz</span></code>,
remembers all local variables in <code class="docutils literal"><span class="pre">viz</span></code> function, including <code class="docutils literal"><span class="pre">all_u</span></code>,
even when <code class="docutils literal"><span class="pre">plot_u</span></code> is called (as <code class="docutils literal"><span class="pre">user_action</span></code>) in the <code class="docutils literal"><span class="pre">solver</span></code> function.
Test both <code class="docutils literal"><span class="pre">all_u.append(u)</span></code> and <code class="docutils literal"><span class="pre">all_u.append(u.copy())</span></code>.
Why does one of these constructions fail to store the solution correctly?
Let the <code class="docutils literal"><span class="pre">viz</span></code> function return the <code class="docutils literal"><span class="pre">all_u</span></code> list
converted to a two-dimensional <code class="docutils literal"><span class="pre">numpy</span></code> array.</p>
<p>Filename: <code class="docutils literal"><span class="pre">wave1D_u0_s_store</span></code>.</p>
</div>
<div class="section" id="exercise-2-3-use-a-class-for-the-user-action-function">
<span id="wave-exer-store-list-class"></span><h3>Exercise 2.3: Use a class for the user action function<a class="headerlink" href="#exercise-2-3-use-a-class-for-the-user-action-function" title="Permalink to this headline">¶</a></h3>
<p>Redo <a class="reference internal" href="#wave-exer-store-list"><span class="std std-ref">Exercise 2.2: Add storage of solution in a user action function</span></a> using a class for the user
action function. Let the <code class="docutils literal"><span class="pre">all_u</span></code> list be an attribute in this class
and implement the user action function as a method (the special method
<code class="docutils literal"><span class="pre">__call__</span></code> is a natural choice). The class versions avoid that the
user action function depends on parameters defined outside the
function (such as <code class="docutils literal"><span class="pre">all_u</span></code> in <a class="reference internal" href="#wave-exer-store-list"><span class="std std-ref">Exercise 2.2: Add storage of solution in a user action function</span></a>).</p>
<p>Filename: <code class="docutils literal"><span class="pre">wave1D_u0_s2c</span></code>.</p>
</div>
<div class="section" id="exercise-2-4-compare-several-courant-numbers-in-one-movie">
<span id="wave-exer-multiple-c"></span><h3>Exercise 2.4: Compare several Courant numbers in one movie<a class="headerlink" href="#exercise-2-4-compare-several-courant-numbers-in-one-movie" title="Permalink to this headline">¶</a></h3>
<p>The goal of this exercise is to make movies where several curves,
corresponding to different Courant numbers, are visualized. Write a
program that resembles <code class="docutils literal"><span class="pre">wave1D_u0_s2c.py</span></code> in <a class="reference internal" href="#wave-exer-store-list-class"><span class="std std-ref">Exercise 2.3: Use a class for the user action function</span></a>, but with a <code class="docutils literal"><span class="pre">viz</span></code> function that
can take a list of <code class="docutils literal"><span class="pre">C</span></code> values as argument and create a movie with
solutions corresponding to the given <code class="docutils literal"><span class="pre">C</span></code> values. The <code class="docutils literal"><span class="pre">plot_u</span></code> function
must be changed to store the solution in an array (see <a class="reference internal" href="#wave-exer-store-list"><span class="std std-ref">Exercise 2.2: Add storage of solution in a user action function</span></a> or <a class="reference internal" href="#wave-exer-store-list-class"><span class="std std-ref">Exercise 2.3: Use a class for the user action function</span></a> for
details), <code class="docutils literal"><span class="pre">solver</span></code> must be computed for each value of the Courant
number, and finally one must run through each time step and plot all
the spatial solution curves in one figure and store it in a file.</p>
<p>The challenge in such a visualization is to ensure that the curves in
one plot correspond to the same time point. The easiest remedy is to
keep the time resolution constant and change the space resolution
to change the Courant number. Note that each spatial grid is needed for
the final plotting, so it is an option to store those grids too.</p>
<p>Filename: <code class="docutils literal"><span class="pre">wave_numerics_comparison</span></code>.</p>
</div>
<div class="section" id="exercise-2-5-implementing-the-solver-function-as-a-generator">
<span id="wave-exer-useraction-generator"></span><h3>Exercise 2.5: Implementing the solver function as a generator<a class="headerlink" href="#exercise-2-5-implementing-the-solver-function-as-a-generator" title="Permalink to this headline">¶</a></h3>
<p>The callback function <code class="docutils literal"><span class="pre">user_action(u,</span> <span class="pre">x,</span> <span class="pre">t,</span> <span class="pre">n)</span></code> is called from the
<code class="docutils literal"><span class="pre">solver</span></code> function (in, e.g., <code class="docutils literal"><span class="pre">wave1D_u0.py</span></code>) at every time level and lets
the user work perform desired actions with the solution, like plotting it
on the screen. We have implemented the callback function in the typical
way it would have been done in C and Fortran. Specifically, the code looks
like</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">user_action</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">user_action</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">break</span>
</pre></div>
</div>
<p>Many Python programmers, however, may claim that <code class="docutils literal"><span class="pre">solver</span></code> is an iterative
process, and that iterative processes with callbacks to the user code is
more elegantly implemented as <em>generators</em>. The rest of the text has little
meaning unless you are familiar with Python generators and the <code class="docutils literal"><span class="pre">yield</span></code>
statement.</p>
<p>Instead of calling <code class="docutils literal"><span class="pre">user_action</span></code>, the <code class="docutils literal"><span class="pre">solver</span></code> function
issues a <code class="docutils literal"><span class="pre">yield</span></code> statement, which is a kind of <code class="docutils literal"><span class="pre">return</span></code> statement:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">yield</span> <span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span>
</pre></div>
</div>
<p>The program control is directed back to the calling code:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">solver</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="c1"># Do something with u at t[n]</span>
</pre></div>
</div>
<p>When the block is done, <code class="docutils literal"><span class="pre">solver</span></code> continues with the statement after <code class="docutils literal"><span class="pre">yield</span></code>.
Note that the functionality of terminating the solution process if
<code class="docutils literal"><span class="pre">user_action</span></code> returns a <code class="docutils literal"><span class="pre">True</span></code> value is not possible to implement in the
generator case.</p>
<p>Implement the <code class="docutils literal"><span class="pre">solver</span></code> function as a generator, and plot the solution
at each time step.
Filename: <code class="docutils literal"><span class="pre">wave1D_u0_generator</span></code>.</p>
</div>
<div class="section" id="project-2-6-calculus-with-1d-mesh-functions">
<span id="wave-exer-mesh1d-calculus"></span><h3>Project 2.6: Calculus with 1D mesh functions<a class="headerlink" href="#project-2-6-calculus-with-1d-mesh-functions" title="Permalink to this headline">¶</a></h3>
<p>This project explores integration and differentiation of
mesh functions, both with scalar and vectorized implementations.
We are given a mesh function <span class="math">\(f_i\)</span> on a spatial one-dimensional
mesh <span class="math">\(x_i=i\Delta x\)</span>, <span class="math">\(i=0,\ldots,N_x\)</span>, over the interval <span class="math">\([a,b]\)</span>.</p>
<p><strong>a)</strong>
Define the discrete derivative of <span class="math">\(f_i\)</span> by using centered
differences at internal mesh points and one-sided differences
at the end points. Implement a scalar version of
the computation in a Python function and write an associated unit test
for the linear case <span class="math">\(f(x)=4x-2.5\)</span> where the discrete derivative should
be exact.</p>
<p><strong>b)</strong>
Vectorize the implementation of the discrete derivative.
Extend the unit test to check the validity of the implementation.</p>
<p><strong>c)</strong>
To compute the discrete integral <span class="math">\(F_i\)</span> of <span class="math">\(f_i\)</span>, we assume that
the mesh function <span class="math">\(f_i\)</span> varies linearly between the mesh points.
Let <span class="math">\(f(x)\)</span> be such a linear interpolant of <span class="math">\(f_i\)</span>. We then
have</p>
<div class="math">
\[F_i = \int_{x_0}^{x_i} f(x) dx{\thinspace .}\]</div>
<p>The exact integral of a piecewise linear function <span class="math">\(f(x)\)</span> is
given by the Trapezoidal rule. Show
that if <span class="math">\(F_{i}\)</span> is already computed, we can find <span class="math">\(F_{i+1}\)</span>
from</p>
<div class="math">
\[F_{i+1} = F_i + \frac{1}{2}(f_i + f_{i+1})\Delta x{\thinspace .}\]</div>
<p>Make a function for the scalar implementation of the discrete integral
as a mesh function. That is, the function should return
<span class="math">\(F_i\)</span> for <span class="math">\(i=0,\ldots,N_x\)</span>.
For a unit test one can use the fact that the above defined
discrete integral of a linear
function (say <span class="math">\(f(x)=4x-2.5\)</span>) is exact.</p>
<p><strong>d)</strong>
Vectorize the implementation of the discrete integral.
Extend the unit test to check the validity of the implementation.</p>
<p><strong>Hint.</strong>
Interpret the recursive formula for <span class="math">\(F_{i+1}\)</span> as a sum.
Make an array with each element of the sum and use the &#8220;cumsum&#8221;
(<code class="docutils literal"><span class="pre">numpy.cumsum</span></code>) operation to compute the accumulative sum:
<code class="docutils literal"><span class="pre">numpy.cumsum([1,3,5])</span></code> is <code class="docutils literal"><span class="pre">[1,4,9]</span></code>.</p>
<p><strong>e)</strong>
Create a class <code class="docutils literal"><span class="pre">MeshCalculus</span></code> that can integrate and differentiate
mesh functions. The class can just define some methods that call
the previously implemented Python functions. Here is an example
on the usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="n">calc</span> <span class="o">=</span> <span class="n">MeshCalculus</span><span class="p">(</span><span class="n">vectorized</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>        <span class="c1"># mesh</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>                    <span class="c1"># mesh function</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">calc</span><span class="o">.</span><span class="n">differentiate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>    <span class="c1"># discrete derivative</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">calc</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>         <span class="c1"># discrete anti-derivative</span>
</pre></div>
</div>
<p><strong>Solution.</strong>
The final version of the code reads</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Calculus with a 1D mesh function.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">class</span> <span class="nc">MeshCalculus</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vectorized</span> <span class="o">=</span> <span class="n">vectorized</span>

    <span class="k">def</span> <span class="nf">differentiate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Computes the derivative of f by centered differences, but</span>
<span class="sd">        forw and back difference at the start and end, respectively.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>     <span class="c1"># number of spatial steps</span>
        <span class="n">num_dfdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Compute approximate derivatives at end-points first</span>
        <span class="n">num_dfdx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">/</span><span class="n">dx</span>          <span class="c1"># FD approx.</span>
        <span class="n">num_dfdx</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">Nx</span><span class="p">])</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="o">/</span><span class="n">dx</span>     <span class="c1"># BD approx.</span>
        <span class="c1"># proceed with approximate derivatives for inner mesh points</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vectorized</span><span class="p">:</span>
            <span class="n">num_dfdx</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>   <span class="c1"># scalar version</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
                <span class="n">num_dfdx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">num_dfdx</span>

    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Computes the integral of f(x) over the interval</span>
<span class="sd">        covered by x.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>    <span class="c1"># starting value for iterative scheme</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vectorized</span><span class="p">:</span>
            <span class="n">all_trapezoids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">all_trapezoids</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span><span class="o">*</span><span class="n">dx</span>
            <span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">all_trapezoids</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>   <span class="c1"># scalar version</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span><span class="o">*</span><span class="n">dx</span>
        <span class="k">return</span> <span class="n">F</span>

<span class="k">def</span> <span class="nf">test_differentiate</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mf">2.5</span>
    <span class="k">def</span> <span class="nf">dfdx</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">derivatives</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">derivatives</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="k">return</span> <span class="n">derivatives</span>

    <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">Nx</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">exact_dfdx</span> <span class="o">=</span> <span class="n">dfdx</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>        <span class="c1"># compute exact derivatives</span>
    <span class="c1"># test vectorized version</span>
    <span class="n">calc_v</span> <span class="o">=</span> <span class="n">MeshCalculus</span><span class="p">(</span><span class="n">vectorized</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">num_dfdx</span>  <span class="o">=</span> <span class="n">calc_v</span><span class="o">.</span><span class="n">differentiate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">num_dfdx</span> <span class="o">-</span> <span class="n">exact_dfdx</span><span class="p">)</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">num_dfdx</span> <span class="o">-</span> <span class="n">exact_dfdx</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span>
    <span class="c1"># test scalar version</span>
    <span class="n">calc</span> <span class="o">=</span> <span class="n">MeshCalculus</span><span class="p">(</span><span class="n">vectorized</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">num_dfdx</span>  <span class="o">=</span> <span class="n">calc</span><span class="o">.</span><span class="n">differentiate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">num_dfdx</span> <span class="o">-</span> <span class="n">exact_dfdx</span><span class="p">)</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">num_dfdx</span> <span class="o">-</span> <span class="n">exact_dfdx</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="k">def</span> <span class="nf">test_integrate</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mf">2.5</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">Nx</span> <span class="o">=</span> <span class="mi">10</span>
<span class="c1">#    a = 2.5/4; b = 10; Nx = 2</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># The exact integral amounts to the total area of two triangles</span>
    <span class="n">I_exact</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="mf">2.5</span><span class="o">/</span><span class="mi">4</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="mf">2.5</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="c1"># test vectorized version</span>
    <span class="n">calc_v</span> <span class="o">=</span> <span class="n">MeshCalculus</span><span class="p">(</span><span class="n">vectorized</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">calc_v</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">F</span><span class="p">,</span> <span class="n">I_exact</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">I_exact</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">diff</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span>
    <span class="c1"># test scalar version</span>
    <span class="n">calc</span> <span class="o">=</span> <span class="n">MeshCalculus</span><span class="p">(</span><span class="n">vectorized</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">calc</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">F</span><span class="p">,</span> <span class="n">I_exact</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">I_exact</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">diff</span>
    <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">test_differentiate</span><span class="p">()</span>
    <span class="n">test_integrate</span><span class="p">()</span>
</pre></div>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">mesh_calculus_1D</span></code>.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Wave equations</a><ul>
<li><a class="reference internal" href="#simulation-of-waves-on-a-string">Simulation of waves on a string</a><ul>
<li><a class="reference internal" href="#discretizing-the-domain">Discretizing the domain</a><ul>
<li><a class="reference internal" href="#uniform-meshes">Uniform meshes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-discrete-solution">The discrete solution</a></li>
<li><a class="reference internal" href="#fulfilling-the-equation-at-the-mesh-points">Fulfilling the equation at the mesh points</a></li>
<li><a class="reference internal" href="#replacing-derivatives-by-finite-differences">Replacing derivatives by finite differences</a><ul>
<li><a class="reference internal" href="#algebraic-version-of-the-pde">Algebraic version of the PDE</a></li>
<li><a class="reference internal" href="#interpretation-of-the-equation-as-a-stencil">Interpretation of the equation as a stencil</a></li>
<li><a class="reference internal" href="#algebraic-version-of-the-initial-conditions">Algebraic version of the initial conditions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#formulating-a-recursive-algorithm">Formulating a recursive algorithm</a></li>
<li><a class="reference internal" href="#sketch-of-an-implementation">Sketch of an implementation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#verification-4">Verification</a><ul>
<li><a class="reference internal" href="#a-slightly-generalized-model-problem">A slightly generalized model problem</a></li>
<li><a class="reference internal" href="#using-an-analytical-solution-of-physical-significance">Using an analytical solution of physical significance</a></li>
<li><a class="reference internal" href="#manufactured-solution-and-estimation-of-convergence-rates">Manufactured solution and estimation of convergence rates</a><ul>
<li><a class="reference internal" href="#specifying-the-solution-and-computing-corresponding-data">Specifying the solution and computing corresponding data</a></li>
<li><a class="reference internal" href="#defining-a-single-discretization-parameter">Defining a single discretization parameter</a></li>
<li><a class="reference internal" href="#computing-errors">Computing errors</a></li>
<li><a class="reference internal" href="#computing-rates">Computing rates</a></li>
</ul>
</li>
<li><a class="reference internal" href="#constructing-an-exact-solution-of-the-discrete-equations">Constructing an exact solution of the discrete equations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-4">Implementation</a><ul>
<li><a class="reference internal" href="#callback-function-for-user-specific-actions">Callback function for user-specific actions</a></li>
<li><a class="reference internal" href="#the-solver-function">The solver function</a></li>
<li><a class="reference internal" href="#verification-exact-quadratic-solution">Verification: exact quadratic solution</a></li>
<li><a class="reference internal" href="#verification-convergence-rates-1">Verification: convergence rates</a></li>
<li><a class="reference internal" href="#visualization-animating-the-solution">Visualization: animating the solution</a><ul>
<li><a class="reference internal" href="#function-for-administering-the-simulation">Function for administering the simulation</a></li>
<li><a class="reference internal" href="#dissection-of-the-code">Dissection of the code</a></li>
<li><a class="reference internal" href="#making-movie-files">Making movie files</a></li>
<li><a class="reference internal" href="#skipping-frames-for-animation-speed">Skipping frames for animation speed</a></li>
</ul>
</li>
<li><a class="reference internal" href="#running-a-case">Running a case</a></li>
<li><a class="reference internal" href="#working-with-a-scaled-pde-model">Working with a scaled PDE model</a></li>
</ul>
</li>
<li><a class="reference internal" href="#vectorization">Vectorization</a><ul>
<li><a class="reference internal" href="#operations-on-slices-of-arrays">Operations on slices of arrays</a></li>
<li><a class="reference internal" href="#finite-difference-schemes-expressed-as-slices">Finite difference schemes expressed as slices</a></li>
<li><a class="reference internal" href="#verification-5">Verification</a></li>
<li><a class="reference internal" href="#efficiency-measurements">Efficiency measurements</a><ul>
<li><a class="reference internal" href="#solution-1">Solution 1</a></li>
<li><a class="reference internal" href="#solution-2">Solution 2</a></li>
<li><a class="reference internal" href="#efficiency-experiments">Efficiency experiments</a></li>
</ul>
</li>
<li><a class="reference internal" href="#remark-on-the-updating-of-arrays">Remark on the updating of arrays</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises-2">Exercises</a><ul>
<li><a class="reference internal" href="#exercise-2-1-simulate-a-standing-wave">Exercise 2.1: Simulate a standing wave</a><ul>
<li><a class="reference internal" href="#remarks-3">Remarks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercise-2-2-add-storage-of-solution-in-a-user-action-function">Exercise 2.2: Add storage of solution in a user action function</a></li>
<li><a class="reference internal" href="#exercise-2-3-use-a-class-for-the-user-action-function">Exercise 2.3: Use a class for the user action function</a></li>
<li><a class="reference internal" href="#exercise-2-4-compare-several-courant-numbers-in-one-movie">Exercise 2.4: Compare several Courant numbers in one movie</a></li>
<li><a class="reference internal" href="#exercise-2-5-implementing-the-solver-function-as-a-generator">Exercise 2.5: Implementing the solver function as a generator</a></li>
<li><a class="reference internal" href="#project-2-6-calculus-with-1d-mesh-functions">Project 2.6: Calculus with 1D mesh functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._book004.html"
                        title="previous chapter">Applications of vibration models</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._book006.html"
                        title="next chapter">Generalization: reflecting boundaries</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._book005.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._book006.html" title="Generalization: reflecting boundaries"
             >next</a> |</li>
        <li class="right" >
          <a href="._book004.html" title="Applications of vibration models"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with PDEs</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2016, Hans Petter Langtangen, Svein Linge. Released under CC Attribution 4.0 license.
  </div>
</div>

  </body>
</html>