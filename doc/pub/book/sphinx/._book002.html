
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Vibration ODEs</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Finite Difference Computing with PDEs" href="index.html" />
    <link rel="next" title="Generalization: damping, nonlinearities, and excitation" href="._book003.html" />
    <link rel="prev" title="Preface" href="._book001.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._book003.html" title="Generalization: damping, nonlinearities, and excitation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._book001.html" title="Preface"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with PDEs</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="vibration-odes-1">
<span id="ch-vib"></span><h1>Vibration ODEs<a class="headerlink" href="#vibration-odes-1" title="Permalink to this headline">¶</a></h1>
<p>Vibration problems lead to differential equations with solutions that
oscillate in time, typically in a damped or undamped sinusoidal
fashion.  Such solutions put certain demands on the numerical methods
compared to other phenomena whose solutions are monotone or very smooth.
Both the frequency and amplitude of the oscillations need to be
accurately handled by the numerical schemes. The forthcoming text
presents a range of different methods, from classical ones
(Runge-Kutta and midpoint/Crank-Nicolson methods), to more
modern and popular symplectic (geometric) integration schemes (Leapfrog,
Euler-Cromer, and
Stoermer-Verlet
methods), but with a clear emphasis on the latter. Vibration problems
occur throughout mechanics and physics, but the methods discussed
in this text are also fundamental for constructing successful algorithms
for partial differential equations
of wave nature in multiple spatial dimensions.</p>
<div class="section" id="finite-difference-discretization-1">
<span id="vib-model1"></span><h2>Finite difference discretization<a class="headerlink" href="#finite-difference-discretization-1" title="Permalink to this headline">¶</a></h2>
<p>Many of the numerical challenges faced when computing oscillatory
solutions to ODEs and PDEs can be captured by the very simple ODE
<span class="math">\(u^{\prime\prime} + u =0\)</span>. This ODE is thus chosen as our starting
point for method development, implementation, and analysis.</p>
<div class="section" id="a-basic-model-for-vibrations">
<h3>A basic model for vibrations<a class="headerlink" href="#a-basic-model-for-vibrations" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-0"></span><span class="target" id="index-1"></span><p id="index-2">The simplest model of a vibrating mechanical system has the following form:</p>
<div class="math" id="eq-vib-ode1">
\[\tag{1}
u^{\prime\prime} + \omega^2u = 0,\quad u(0)=I,\ u^{\prime}(0)=0,\ t\in (0,T]
    {\thinspace .}\]</div>
<p>Here, <span class="math">\(\omega\)</span> and <span class="math">\(I\)</span> are given constants.
The section <a class="reference internal" href="._book004.html#vib-app-mass-spring"><span class="std std-ref">Oscillating mass attached to a spring</span></a> derives <a class="reference internal" href="#eq-vib-ode1"><span class="std std-ref">(1)</span></a> from physical
principles and explains what the constants mean.</p>
<span class="target" id="index-3"></span><span class="target" id="index-4"></span><p id="index-5">The exact solution of <a class="reference internal" href="#eq-vib-ode1"><span class="std std-ref">(1)</span></a> is</p>
<div class="math" id="eq-vib-ode1-uex">
\[\tag{2}
u(t) = I\cos (\omega t)
    {\thinspace .}\]</div>
<p>That is, <span class="math">\(u\)</span> oscillates with constant amplitude <span class="math">\(I\)</span> and
angular frequency <span class="math">\(\omega\)</span>.
The corresponding period of oscillations (i.e., the time between two
neighboring peaks in the cosine function) is <span class="math">\(P=2\pi/\omega\)</span>.
The number of periods per second
is <span class="math">\(f=\omega/(2\pi)\)</span> and measured in the unit Hz.
Both <span class="math">\(f\)</span> and <span class="math">\(\omega\)</span> are referred to as frequency, but <span class="math">\(\omega\)</span>
is more precisely named <em>angular frequency</em>, measured in rad/s.</p>
<p>In vibrating mechanical systems modeled by <a class="reference internal" href="#eq-vib-ode1"><span class="std std-ref">(1)</span></a>, <span class="math">\(u(t)\)</span>
very often represents a position or a displacement of a particular
point in the system. The derivative <span class="math">\(u^{\prime}(t)\)</span> then has the
interpretation of velocity, and <span class="math">\(u^{\prime\prime}(t)\)</span> is the associated
acceleration.  The model <a class="reference internal" href="#eq-vib-ode1"><span class="std std-ref">(1)</span></a> is not only
applicable to vibrating mechanical systems, but also to oscillations
in electrical circuits.</p>
</div>
<div class="section" id="a-centered-finite-difference-scheme-1">
<span id="vib-ode1-fdm"></span><h3>A centered finite difference scheme<a class="headerlink" href="#a-centered-finite-difference-scheme-1" title="Permalink to this headline">¶</a></h3>
<p>To formulate a finite difference method for the model
problem  <a class="reference internal" href="#eq-vib-ode1"><span class="std std-ref">(1)</span></a> we follow the <a class="reference external" href="http://tinyurl.com/pu5uyfn/pub/sphinx-decay/main_decay.html#the-forward-euler-scheme">four steps</a> explained in <a class="reference internal" href="._book027.html#ref02" id="id1">[Ref02]</a>.</p>
<span class="target" id="index-6"></span><div class="section" id="step-1-discretizing-the-domain">
<span id="index-7"></span><h4>Step 1: Discretizing the domain<a class="headerlink" href="#step-1-discretizing-the-domain" title="Permalink to this headline">¶</a></h4>
<p>The domain is discretized by
introducing a uniformly partitioned time mesh.
The points in the mesh are <span class="math">\(t_n=n\Delta t\)</span>, <span class="math">\(n=0,1,\ldots,N_t\)</span>,
where <span class="math">\(\Delta t = T/N_t\)</span> is the constant length of the time steps.
We introduce a mesh function <span class="math">\(u^n\)</span> for <span class="math">\(n=0,1,\ldots,N_t\)</span>, which
approximates the exact solution at the mesh points. (Note that
<span class="math">\(n=0\)</span> is the known initial condition, so <span class="math">\(u^n\)</span> is identical to the mathematical
<span class="math">\(u\)</span> at this point.) The mesh
function <span class="math">\(u^n\)</span> will be computed from algebraic equations derived from
the differential equation problem.</p>
</div>
<div class="section" id="step-2-fulfilling-the-equation-at-discrete-time-points">
<h4>Step 2: Fulfilling the equation at discrete time points<a class="headerlink" href="#step-2-fulfilling-the-equation-at-discrete-time-points" title="Permalink to this headline">¶</a></h4>
<p>The ODE is to be satisfied at each mesh point where the solution
must be found:</p>
<div class="math" id="eq-vib-ode1-step2">
\[\tag{3}
u^{\prime\prime}(t_n) + \omega^2u(t_n) = 0,\quad n=1,\ldots,N_t
    {\thinspace .}\]</div>
<span class="target" id="index-8"></span></div>
<div class="section" id="step-3-replacing-derivatives-by-finite-differences">
<span id="index-9"></span><h4>Step 3: Replacing derivatives by finite differences<a class="headerlink" href="#step-3-replacing-derivatives-by-finite-differences" title="Permalink to this headline">¶</a></h4>
<p>The derivative <span class="math">\(u^{\prime\prime}(t_n)\)</span> is to be replaced by a finite
difference approximation. A common second-order accurate approximation
to the second-order derivative is</p>
<div class="math" id="eq-vib-ode1-step3">
\[\tag{4}
u^{\prime\prime}(t_n) \approx \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
    {\thinspace .}\]</div>
<p>Inserting <a class="reference internal" href="#eq-vib-ode1-step3"><span class="std std-ref">(4)</span></a> in <a class="reference internal" href="#eq-vib-ode1-step2"><span class="std std-ref">(3)</span></a>
yields</p>
<div class="math" id="eq-vib-ode1-step3b">
\[\tag{5}
\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2} = -\omega^2 u^n
    {\thinspace .}\]</div>
<p>We also need to replace the derivative in the initial condition by
a finite difference. Here we choose a centered difference, whose
accuracy is similar to the centered difference we used for <span class="math">\(u^{\prime\prime}\)</span>:</p>
<div class="math" id="eq-vib-ode1-step3c">
\[ \begin{align}\begin{aligned}\tag{6}
\frac{u^1-u^{-1}}{2\Delta t} = 0\\    {\thinspace .}\end{aligned}\end{align} \]</div>
</div>
<div class="section" id="step-4-formulating-a-recursive-algorithm">
<h4>Step 4: Formulating a recursive algorithm<a class="headerlink" href="#step-4-formulating-a-recursive-algorithm" title="Permalink to this headline">¶</a></h4>
<p>To formulate the computational algorithm, we assume that we
have already computed <span class="math">\(u^{n-1}\)</span> and <span class="math">\(u^n\)</span>, such that <span class="math">\(u^{n+1}\)</span> is the
unknown value to be solved for:</p>
<div class="math" id="eq-vib-ode1-step4">
\[\tag{7}
u^{n+1} = 2u^n - u^{n-1} - \Delta t^2\omega^2 u^n
    {\thinspace .}\]</div>
<p>The computational algorithm is simply to apply <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a>
successively for <span class="math">\(n=1,2,\ldots,N_t-1\)</span>. This numerical scheme sometimes
goes under the name
Stoermer&#8217;s
method, <a class="reference external" href="http://en.wikipedia.org/wiki/Verlet_integration">Verlet integration</a>, or the Leapfrog method
(one should note
that Leapfrog is used for many quite different methods for quite
different differential equations!).</p>
</div>
<div class="section" id="computing-the-first-step">
<h4>Computing the first step<a class="headerlink" href="#computing-the-first-step" title="Permalink to this headline">¶</a></h4>
<p>We observe that <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a> cannot be used for <span class="math">\(n=0\)</span> since
the computation of <span class="math">\(u^1\)</span> then involves the undefined value <span class="math">\(u^{-1}\)</span>
at <span class="math">\(t=-\Delta t\)</span>. The discretization of the initial condition
then comes to our rescue: <a class="reference internal" href="#eq-vib-ode1-step3c"><span class="std std-ref">(6)</span></a> implies <span class="math">\(u^{-1} = u^1\)</span>
and this relation can be combined with <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a>
for <span class="math">\(n=0\)</span> to yield a value for <span class="math">\(u^1\)</span>:</p>
<div class="math">
\[u^1 = 2u^0 - u^{1} - \Delta t^2 \omega^2 u^0,\]</div>
<p>which reduces to</p>
<div class="math" id="eq-vib-ode1-step4b">
\[\tag{8}
u^1 = u^0 - \frac{1}{2} \Delta t^2 \omega^2 u^0
    {\thinspace .}\]</div>
<p><a class="reference internal" href="#vib-exer-step4b-alt"><span class="std std-ref">Exercise 1.5: Use a Taylor polynomial to compute </span></a> asks you to perform an alternative derivation
and also to generalize the initial condition to <span class="math">\(u^{\prime}(0)=V\neq 0\)</span>.</p>
</div>
<div class="section" id="the-computational-algorithm">
<h4>The computational algorithm<a class="headerlink" href="#the-computational-algorithm" title="Permalink to this headline">¶</a></h4>
<p>The steps for solving <a class="reference internal" href="#eq-vib-ode1"><span class="std std-ref">(1)</span></a> become</p>
<blockquote>
<div><ol class="arabic simple">
<li><span class="math">\(u^0=I\)</span></li>
<li>compute <span class="math">\(u^1\)</span> from <a class="reference internal" href="#eq-vib-ode1-step4b"><span class="std std-ref">(8)</span></a></li>
<li>for <span class="math">\(n=1,2,\ldots,N_t-1\)</span>: compute <span class="math">\(u^{n+1}\)</span> from <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a></li>
</ol>
</div></blockquote>
<p>The algorithm is more precisely expressed directly in Python:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># mesh points in time</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>          <span class="c1"># constant time step</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>           <span class="c1"># solution</span>

<span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
<span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
    <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition-remark-on-using-w-for-math-omega-in-computer-code admonition">
<p class="first admonition-title">Remark on using <code class="docutils literal"><span class="pre">w</span></code> for <span class="math">\(\omega\)</span> in computer code</p>
<p class="last">In the code, we use <code class="docutils literal"><span class="pre">w</span></code> as the symbol for <span class="math">\(\omega\)</span>.
The reason is that the authors prefer <code class="docutils literal"><span class="pre">w</span></code> for readability
and comparison with the mathematical <span class="math">\(\omega\)</span> instead of
the full word <code class="docutils literal"><span class="pre">omega</span></code> as variable name.</p>
</div>
</div>
<div class="section" id="operator-notation">
<h4>Operator notation<a class="headerlink" href="#operator-notation" title="Permalink to this headline">¶</a></h4>
<p>We may write the scheme using a compact difference notation
listed in  <a class="reference internal" href="._book020.html#sec-form-fdop"><span class="std std-ref">Finite difference operator notation</span></a>
(see also
<a class="reference external" href="http://tinyurl.com/pu5uyfn/pub/sphinx-decay/main_decay.html#compact-operator-notation-for-finite-differences">examples</a> in <a class="reference internal" href="._book027.html#ref02" id="id2">[Ref02]</a>).
The difference <a class="reference internal" href="#eq-vib-ode1-step3"><span class="std std-ref">(4)</span></a> has the operator
notation <span class="math">\([D_tD_t u]^n\)</span> such that we can write:</p>
<div class="math" id="eq-vib-ode1-step4-op">
\[\tag{9}
[D_tD_t u  + \omega^2 u = 0]^n
    {\thinspace .}\]</div>
<p>Note that <span class="math">\([D_tD_t u]^n\)</span> means applying a central difference with step <span class="math">\(\Delta t/2\)</span> twice:</p>
<div class="math">
\[[D_t(D_t u)]^n = \frac{[D_t u]^{n+\frac{1}{2}} - [D_t u]^{n-\frac{1}{2}}}{\Delta t}\]</div>
<p>which is written out as</p>
<div class="math">
\[\frac{1}{\Delta t}\left(\frac{u^{n+1}-u^n}{\Delta t} - \frac{u^{n}-u^{n-1}}{\Delta t}\right) = \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
{\thinspace .}\]</div>
<p>The discretization of initial conditions can in the operator notation
be expressed as</p>
<div class="math" id="eq-auto1">
\[\tag{10}
[u = I]^0,\quad [D_{2t} u = 0]^0,\]</div>
<p>where the operator <span class="math">\([D_{2t} u]^n\)</span> is defined as</p>
<div class="math" id="eq-auto2">
\[\tag{11}
[D_{2t} u]^n = \frac{u^{n+1} - u^{n-1}}{2\Delta t}
    {\thinspace .}\]</div>
</div>
</div>
</div>
<div class="section" id="implementation-1">
<span id="vib-impl1"></span><h2>Implementation<a class="headerlink" href="#implementation-1" title="Permalink to this headline">¶</a></h2>
<div class="section" id="making-a-solver-function">
<span id="vib-impl1-solver"></span><h3>Making a solver function<a class="headerlink" href="#making-a-solver-function" title="Permalink to this headline">¶</a></h3>
<p>The algorithm from the previous section is readily translated to
a complete Python function for computing and returning
<span class="math">\(u^0,u^1,\ldots,u^{N_t}\)</span> and <span class="math">\(t_0,t_1,\ldots,t_{N_t}\)</span>, given the
input <span class="math">\(I\)</span>, <span class="math">\(\omega\)</span>, <span class="math">\(\Delta t\)</span>, and <span class="math">\(T\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;&#39; + w**2*u = 0 for t in (0,T], u(0)=I and u&#39;(0)=0,</span>
<span class="sd">    by a central finite difference method with time step dt.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>We have imported <code class="docutils literal"><span class="pre">numpy</span></code> and <code class="docutils literal"><span class="pre">matplotlib</span></code> under the names <code class="docutils literal"><span class="pre">np</span></code> and <code class="docutils literal"><span class="pre">plt</span></code>,
respectively, as this is very common in the Python scientific
computing community and a good programming habit (since we explicitly
see where the different functions come from).  An alternative is to do
<code class="docutils literal"><span class="pre">from</span> <span class="pre">numpy</span> <span class="pre">import</span> <span class="pre">*</span></code> and a similar &#8220;import all&#8221; for Matplotlib to
avoid the <code class="docutils literal"><span class="pre">np</span></code> and <code class="docutils literal"><span class="pre">plt</span></code> prefixes and make the code as close as
possible to MATLAB. (See the section
<a class="reference external" href="http://hplgit.github.io/decay-book/doc/pub/book/html/._decay-book009.html#softeng1:basic:modprefix">Prefixing imported functions by the module name</a> in the book
<a class="reference external" href="http://tinyurl.com/nclmcng/web">Finite Difference Computing with Exponential Decay Models</a> <a class="reference internal" href="._book027.html#ref02" id="id3">[Ref02]</a> for a discussion of the two
types of import in Python.)</p>
<p>A function for plotting the numerical and the exact solution is also
convenient to have:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">visualize</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s1">&#39;r--o&#39;</span><span class="p">)</span>
    <span class="n">t_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1001</span><span class="p">)</span>  <span class="c1"># very fine mesh for u_e</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s1">&#39;on&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;numerical&#39;</span><span class="p">,</span> <span class="s1">&#39;exact&#39;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;dt=</span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">umin</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">min</span><span class="p">();</span>  <span class="n">umax</span> <span class="o">=</span> <span class="o">-</span><span class="n">umin</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;tmp1.png&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;tmp1.pdf&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>A corresponding main program calling these functions to simulate
a given number of periods (<code class="docutils literal"><span class="pre">num_periods</span></code>) may take the form</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">I</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">w</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">num_periods</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>    <span class="c1">#  one period</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">num_periods</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
<span class="n">visualize</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
</pre></div>
</div>
<p>Adjusting some of the input parameters via the command line can be
handy. Here is a code segment using the <code class="docutils literal"><span class="pre">ArgumentParser</span></code> tool in
the <code class="docutils literal"><span class="pre">argparse</span></code> module to define option value (<code class="docutils literal"><span class="pre">--option</span> <span class="pre">value</span></code>)
pairs on the command line:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">argparse</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--I&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--w&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--dt&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--num_periods&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
<span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">num_periods</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">num_periods</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Such parsing of the command line is explained in more detail in</dt>
<dd>the</dd>
</dl>
<p>section <a class="reference external" href="http://hplgit.github.io/decay-book/doc/pub/book/html/._decay-book009.html#softeng1:basic:UI:options_cml">Option-value pairs on the command line</a> in <a class="reference external" href="http://tinyurl.com/nclmcng/web">Finite Difference Computing with Exponential Decay Models</a> <a class="reference internal" href="._book027.html#ref02" id="id4">[Ref02]</a>.</p>
<p>A typical execution goes like</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Terminal&gt; python vib_undamped.py --num_periods 20 --dt 0.1
</pre></div>
</div>
<div class="section" id="computing">
<span id="index-10"></span><h4>Computing <span class="math">\(u^{\prime}\)</span><a class="headerlink" href="#computing" title="Permalink to this headline">¶</a></h4>
<p>In mechanical vibration applications one is often interested in
computing the velocity <span class="math">\(v(t)=u^{\prime}(t)\)</span> after <span class="math">\(u(t)\)</span> has been
computed.  This can be done by a central difference,</p>
<div class="math" id="eq-auto3">
\[\tag{12}
v(t_n)=u^{\prime}(t_n) \approx v^n = \frac{u^{n+1}-u^{n-1}}{2\Delta t} = [D_{2t}u]^n
    {\thinspace .}\]</div>
<p>This formula applies for all inner mesh points, <span class="math">\(n=1,\ldots,N_t-1\)</span>.
For <span class="math">\(n=0\)</span>, <span class="math">\(v(0)\)</span> is given by the initial condition on <span class="math">\(u^{\prime}(0)\)</span>,
and for <span class="math">\(n=N_t\)</span> we can use a one-sided, backward difference:</p>
<div class="math">
\[v^n=[D_t^-u]^n = \frac{u^{n} - u^{n-1}}{\Delta t}{\thinspace .}\]</div>
<p>Typical (scalar) code is</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>  <span class="c1"># or v = np.zeros(len(u))</span>
<span class="c1"># Use central difference for internal points</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
<span class="c1"># Use initial condition for u&#39;(0) when i=0</span>
<span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1"># Use backward difference at the final mesh point</span>
<span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">dt</span>
</pre></div>
</div>
<p>Since the loop is slow for large <span class="math">\(N_t\)</span>, we can get rid of the loop by
vectorizing the central difference. The above code segment goes as
follows in its vectorized version (see the problem
<a class="reference external" href="http://hplgit.github.io/decay-book/doc/pub/book/html/._decay-book005.html#decay:exer:dudt">Differentiate a function</a> in <a class="reference external" href="http://tinyurl.com/nclmcng/web">Finite
Difference Computing with Exponential Decay Models</a> <a class="reference internal" href="._book027.html#ref02" id="id5">[Ref02]</a> for
explanation of details):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>  <span class="c1"># central difference</span>
<span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>                           <span class="c1"># boundary condition u&#39;(0)</span>
<span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">dt</span>         <span class="c1"># backward difference</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="verification-1">
<span id="vib-ode1-verify"></span><h3>Verification<a class="headerlink" href="#verification-1" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-11"></span><span class="target" id="index-12"></span><span class="target" id="index-13"></span><span class="target" id="index-14"></span><div class="section" id="manual-calculation">
<span id="index-15"></span><h4>Manual calculation<a class="headerlink" href="#manual-calculation" title="Permalink to this headline">¶</a></h4>
<p>The simplest type of verification, which is also instructive for understanding
the algorithm, is to compute <span class="math">\(u^1\)</span>, <span class="math">\(u^2\)</span>, and <span class="math">\(u^3\)</span>
with the aid of a calculator
and make a function for comparing these results with those from the <code class="docutils literal"><span class="pre">solver</span></code>
function. The <code class="docutils literal"><span class="pre">test_three_steps</span></code> function in
the file <a class="reference external" href="http://tinyurl.com/nu656p2/vib/vib_undamped.py">vib_undamped.py</a>
shows the details of how we use the hand calculations to test the code:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_three_steps</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
    <span class="n">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">;</span>  <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>  <span class="n">T</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">u_by_hand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.000000000000000</span><span class="p">,</span>
                          <span class="mf">0.802607911978213</span><span class="p">,</span>
                          <span class="mf">0.288358920740053</span><span class="p">])</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_by_hand</span> <span class="o">-</span> <span class="n">u</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
<p>This function is a proper <em>test function</em>,
compliant with the pytest and nose testing
framework for Python code, because</p>
<blockquote>
<div><ul class="simple">
<li>the function name begins with <code class="docutils literal"><span class="pre">test_</span></code></li>
<li>the function takes no arguments</li>
<li>the test is formulated as a boolean condition and executed by <code class="docutils literal"><span class="pre">assert</span></code></li>
</ul>
</div></blockquote>
<p>We shall in this book implement all software verification via such
proper test functions, also known as unit testing.
See the
section <a class="reference external" href="http://hplgit.github.io/decay-book/doc/pub/book/html/._decay-book009.html#softeng1:verify:pytest">Unit tests and test functions</a> in
<a class="reference external" href="http://tinyurl.com/nclmcng/web">Finite Difference Computing with Exponential Decay Models</a> <a class="reference internal" href="._book027.html#ref02" id="id6">[Ref02]</a>
for more details on how to construct test functions and utilize nose
or pytest for automatic execution of tests. Our recommendation is to
use pytest. With this choice, you can
run all test functions in <code class="docutils literal"><span class="pre">vib_undamped.py</span></code> by</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Terminal&gt; py.test -s -v vib_undamped.py
============================= test session starts ======...
platform linux2 -- Python 2.7.9 -- ...
collected 2 items

vib_undamped.py::test_three_steps PASSED
vib_undamped.py::test_convergence_rates PASSED

=========================== 2 passed in 0.19 seconds ===...
</pre></div>
</div>
</div>
<div class="section" id="testing-very-simple-polynomial-solutions">
<span id="index-16"></span><h4>Testing very simple polynomial solutions<a class="headerlink" href="#testing-very-simple-polynomial-solutions" title="Permalink to this headline">¶</a></h4>
<p>Constructing test problems where the exact solution is constant or
linear helps initial debugging and verification as one expects any
reasonable numerical method to reproduce such solutions to machine
precision.  Second-order accurate methods will often also reproduce a
quadratic solution.  Here <span class="math">\([D_tD_tt^2]^n=2\)</span>, which is the exact
result. A solution <span class="math">\(u=t^2\)</span> leads to <span class="math">\(u^{\prime\prime}+\omega^2 u=2 + (\omega
t)^2\neq 0\)</span>.  We must therefore add a source in the equation: <span class="math">\(u^{\prime\prime} +
\omega^2 u = f\)</span> to allow a solution <span class="math">\(u=t^2\)</span> for <span class="math">\(f=2 + (\omega t)^2\)</span>.  By
simple insertion we can show that the mesh function <span class="math">\(u^n = t_n^2\)</span> is
also a solution of the discrete equations.  <a class="reference internal" href="#vib-exer-undamped-verify-linquad"><span class="std std-ref">Problem 1.1: Use linear/quadratic functions for verification</span></a> asks you to carry out all
details to show that linear and quadratic solutions are solutions
of the discrete equations. Such results are very useful for debugging
and verification. You are strongly encouraged to do this problem now!</p>
</div>
<div class="section" id="checking-convergence-rates-1">
<span id="index-17"></span><h4>Checking convergence rates<a class="headerlink" href="#checking-convergence-rates-1" title="Permalink to this headline">¶</a></h4>
<p>Empirical computation of convergence rates yields a good method for
verification. The method and its computational details are explained
in detail for a simple ODE model in the section
<a class="reference external" href="http://hplgit.github.io/decay-book/doc/pub/book/html/._decay-book007.html#decay:convergence:rate">Computing convergence rates</a>
in <a class="reference external" href="http://tinyurl.com/nclmcng/web">Finite Difference Computing with Exponential Decay Models</a> <a class="reference internal" href="._book027.html#ref02" id="id7">[Ref02]</a>.  Readers not
familiar with the concept should look up this reference before
proceeding.</p>
<p>In the present problem, computing convergence rates means that we must</p>
<blockquote>
<div><ul class="simple">
<li>perform <span class="math">\(m\)</span> simulations, halving the time steps as: <span class="math">\(\Delta t_i=2^{-i}\Delta t_0\)</span>, <span class="math">\(i=1,\ldots,m-1\)</span>, and <span class="math">\(\Delta t_i\)</span> is the time step used in simulation <span class="math">\(i\)</span>;</li>
<li>compute the <span class="math">\(L^2\)</span> norm of the error,
<span class="math">\(E_i=\sqrt{\Delta t_i\sum_{n=0}^{N_t-1}(u^n-{u_{\small\mbox{e}}}(t_n))^2}\)</span> in each case;</li>
<li>estimate the convergence rates <span class="math">\(r_i\)</span> based on two consecutive
experiments <span class="math">\((\Delta t_{i-1}, E_{i-1})\)</span> and <span class="math">\((\Delta t_{i}, E_{i})\)</span>,
assuming <span class="math">\(E_i=C(\Delta t_i)^{r}\)</span> and <span class="math">\(E_{i-1}=C(\Delta t_{i-1})^{r}\)</span>.
From these equations it follows that
<span class="math">\(r = \ln (E_{i-1}/E_i)/\ln (\Delta t_{i-1}/\Delta t_i)\)</span>. Since this <span class="math">\(r\)</span>
will vary with <span class="math">\(i\)</span>, we equip it with an index and call it <span class="math">\(r_{i-1}\)</span>,
where <span class="math">\(i\)</span> runs from <span class="math">\(1\)</span> to <span class="math">\(m-1\)</span>.</li>
</ul>
</div></blockquote>
<p>The computed rates <span class="math">\(r_0,r_1,\ldots,r_{m-2}\)</span> hopefully converge to the
number 2 in the present
problem, because theory (from the section <a class="reference internal" href="#vib-ode1-analysis"><span class="std std-ref">Analysis of the numerical scheme</span></a>) shows
that the error of the numerical method we use behaves like <span class="math">\(\Delta t^2\)</span>.
The convergence of the sequence <span class="math">\(r_0,r_1,\ldots,r_{m-2}\)</span>
demands that the time steps
<span class="math">\(\Delta t_i\)</span> are sufficiently small for the error model <span class="math">\(E_i=C(\Delta t_i)^r\)</span>
to be valid.</p>
<p>All the implementational details of computing the sequence
<span class="math">\(r_0,r_1,\ldots,r_{m-2}\)</span> appear below.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">convergence_rates</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">solver_function</span><span class="p">,</span> <span class="n">num_periods</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return m-1 empirical estimates of the convergence rate</span>
<span class="sd">    based on m simulations, where the time step is halved</span>
<span class="sd">    for each simulation.</span>
<span class="sd">    solver_function(I, w, dt, T) solves each problem, where T</span>
<span class="sd">    is based on simulation for num_periods periods.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mf">0.35</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="mf">0.3</span>       <span class="c1"># just chosen values</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>              <span class="c1"># period</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">P</span><span class="o">/</span><span class="mi">30</span>               <span class="c1"># 30 time step per period 2*pi/w</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">num_periods</span>

    <span class="n">dt_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">E_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver_function</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
        <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">u_e</span><span class="o">-</span><span class="n">u</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">dt_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">E_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">/</span><span class="mi">2</span>

    <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">E_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">E_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span>
         <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">E_values</span><span class="p">,</span> <span class="n">dt_values</span>
</pre></div>
</div>
<p>The error analysis in the section <a class="reference internal" href="#vib-ode1-analysis"><span class="std std-ref">Analysis of the numerical scheme</span></a> is quite
detailed and suggests that <span class="math">\(r=2\)</span>.
It is also a intuitively reasonable result, since we used a
second-order accurate finite difference approximation <span class="math">\([D_tD_tu]^n\)</span> to
the ODE and a second-order accurate finite difference formula for the
initial condition for <span class="math">\(u^{\prime}\)</span>.</p>
<p>In the present problem, when <span class="math">\(\Delta t_0\)</span> corresponds to 30 time steps
per period, the returned <code class="docutils literal"><span class="pre">r</span></code> list has all its values equal to 2.00
(if rounded to two decimals). This amazingly accurate result means that all
<span class="math">\(\Delta t_i\)</span> values are well into the asymptotic regime where the
error model <span class="math">\(E_i = C(\Delta t_i)^r\)</span> is valid.</p>
<p>We can now construct a proper test function that computes convergence rates
and checks that the final (and usually the best) estimate is sufficiently
close to 2. Here, a rough tolerance of 0.1 is enough. This unit test
goes like</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_convergence_rates</span><span class="p">():</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span>
        <span class="n">m</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">solver_function</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span> <span class="n">num_periods</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="c1"># Accept rate to 1 decimal place</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>
    <span class="c1"># Test that adjusted w obtains 4th order convergence</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span>
        <span class="n">m</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">solver_function</span><span class="o">=</span><span class="n">solver_adjust_w</span><span class="p">,</span> <span class="n">num_periods</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="k">print</span> <span class="s1">&#39;adjust w rates:&#39;</span><span class="p">,</span> <span class="n">r</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">4.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
<p>The complete code appears in the file <code class="docutils literal"><span class="pre">vib_undamped.py</span></code>.</p>
<span class="target" id="index-18"></span></div>
<div class="section" id="visualizing-convergence-rates-with-slope-markers">
<span id="index-19"></span><h4>Visualizing convergence rates with slope markers<a class="headerlink" href="#visualizing-convergence-rates-with-slope-markers" title="Permalink to this headline">¶</a></h4>
<p>Tony S. Yu has written a script <a class="reference external" href="http://goo.gl/A4Utm7">plotslopes.py</a>
that is very useful to indicate the slope of a graph, especially
a graph like <span class="math">\(\ln E = r\ln \Delta t + \ln C\)</span> arising from the model
<span class="math">\(E=C\Delta t^r\)</span>. A copy of the script resides in the <a class="reference external" href="http://tinyurl.com/nu656p2/vib">src/vib</a>
directory. Let us use it to compare the original method for <span class="math">\(u'' + \omega^2u =0\)</span>
with the same method applied to the equation with a modified
<span class="math">\(\omega\)</span>. We make log-log plots of the error versus <span class="math">\(\Delta t\)</span>.
For each curve we attach a slope marker using the <code class="docutils literal"><span class="pre">slope_marker((x,y),</span> <span class="pre">r)</span></code>
function from <code class="docutils literal"><span class="pre">plotslopes.py</span></code>, where <code class="docutils literal"><span class="pre">(x,y)</span></code> is the position of the
marker and <code class="docutils literal"><span class="pre">r</span></code> and the slope (<span class="math">\((r,1)\)</span>), here (2,1) and (4,1).</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_convergence_rates</span><span class="p">():</span>
    <span class="n">r2</span><span class="p">,</span> <span class="n">E2</span><span class="p">,</span> <span class="n">dt2</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span>
        <span class="n">m</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">solver_function</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span> <span class="n">num_periods</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">dt2</span><span class="p">,</span> <span class="n">E2</span><span class="p">)</span>
    <span class="n">r4</span><span class="p">,</span> <span class="n">E4</span><span class="p">,</span> <span class="n">dt4</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span>
        <span class="n">m</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">solver_function</span><span class="o">=</span><span class="n">solver_adjust_w</span><span class="p">,</span> <span class="n">num_periods</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">dt4</span><span class="p">,</span> <span class="n">E4</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;original scheme&#39;</span><span class="p">,</span> <span class="s1">r&#39;adjusted $\omega$&#39;</span><span class="p">],</span>
               <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Convergence of finite difference methods&#39;</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">plotslopes</span> <span class="kn">import</span> <span class="n">slope_marker</span>
    <span class="n">slope_marker</span><span class="p">((</span><span class="n">dt2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">E2</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">slope_marker</span><span class="p">((</span><span class="n">dt4</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">E4</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>Figure <a class="reference internal" href="#vib-ode1-verify-fig-convrate-curve"><span class="std std-ref">Empirical convergence rate curves with special slope marker</span></a> displays the two curves
with the markers. The match of the curve slope and the marker slope is
excellent.</p>
<div class="figure" id="id11">
<span id="vib-ode1-verify-fig-convrate-curve"></span><a class="reference internal image-reference" href="_images/vib_adjusted_w_rate_curves.png"><img alt="_images/vib_adjusted_w_rate_curves.png" src="_images/vib_adjusted_w_rate_curves.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text"><em>Empirical convergence rate curves with special slope marker</em></span></p>
</div>
</div>
</div>
<div class="section" id="scaled-model">
<h3>Scaled model<a class="headerlink" href="#scaled-model" title="Permalink to this headline">¶</a></h3>
<p>It is advantageous to use dimensionless variables in simulations,
because fewer parameters need to be set. The present problem is made
dimensionless by introducing dimensionless variables <span class="math">\(\bar t = t/t_c\)</span>
and <span class="math">\(\bar u = u/u_c\)</span>, where <span class="math">\(t_c\)</span> and <span class="math">\(u_c\)</span> are characteristic scales
for <span class="math">\(t\)</span> and <span class="math">\(u\)</span>, respectively. We refer to the section
<a class="reference external" href="http://hplgit.github.io/scaling-book/doc/pub/book/html/._scaling-book006.html#sec:scale:vib:undamped">Undamped vibrations without forcing</a>
in the book <a class="reference external" href="http://tinyurl.com/qfjgxmf/web">Scaling of differential equations</a> <a class="reference internal" href="._book027.html#ref03" id="id8">[Ref03]</a> for all
details about this scaling.</p>
<p>The scaled ODE problem reads</p>
<div class="math">
\[\frac{u_c}{t_c^2}\frac{d^2\bar u}{d\bar t^2} + u_c\bar u = 0,\quad
u_c\bar u(0) = I,\ \frac{u_c}{t_c}\frac{d\bar u}{d\bar t}(0)=0{\thinspace .}\]</div>
<p>A common choice is to take <span class="math">\(t_c\)</span> as one period of
the oscillations, <span class="math">\(t_c = 2\pi/w\)</span>, and <span class="math">\(u_c=I\)</span>.
This gives the dimensionless model</p>
<div class="math" id="eq-vib-ode1-model-scaled">
\[\tag{13}
\frac{d^2\bar u}{d\bar t^2} + 4\pi^2 \bar u = 0,\quad \bar u(0)=1,\
    \bar u^{\prime}(0)=0{\thinspace .}\]</div>
<p>Observe that there are no physical parameters in <a class="reference internal" href="#eq-vib-ode1-model-scaled"><span class="std std-ref">(13)</span></a>!
We can therefore perform
a single numerical simulation <span class="math">\(\bar u(\bar t)\)</span> and afterwards
recover any <span class="math">\(u(t; \omega, I)\)</span> by</p>
<div class="math">
\[u(t;\omega, I) = u_c\bar u(t/t_c) = I\bar u(\omega t/(2\pi)){\thinspace .}\]</div>
<p>We can easily check this assertion: the solution of the scaled problem
is <span class="math">\(\bar u(\bar t) = \cos(2\pi\bar t)\)</span>. The formula for <span class="math">\(u\)</span> in terms
of <span class="math">\(\bar u\)</span> gives <span class="math">\(u = I\cos(\omega t)\)</span>, which is nothing but the solution
of the original problem with dimensions.</p>
<p>The scaled model can by run by calling <code class="docutils literal"><span class="pre">solver(I=1,</span> <span class="pre">w=2*pi,</span> <span class="pre">dt,</span> <span class="pre">T)</span></code>.
Each period is now 1 and <code class="docutils literal"><span class="pre">T</span></code> simply counts the number of periods.
Choosing <code class="docutils literal"><span class="pre">dt</span></code> as <code class="docutils literal"><span class="pre">1./M</span></code> gives <code class="docutils literal"><span class="pre">M</span></code> time steps per period.</p>
</div>
</div>
<div class="section" id="visualization-of-long-time-simulations">
<span id="vib-ode1-longseries"></span><h2>Visualization of long time simulations<a class="headerlink" href="#visualization-of-long-time-simulations" title="Permalink to this headline">¶</a></h2>
<p>Figure <a class="reference internal" href="#vib-ode1-2dt"><span class="std std-ref">Effect of halving the time step</span></a> shows a comparison of the exact and numerical
solution for the scaled model <a class="reference internal" href="#eq-vib-ode1-model-scaled"><span class="std std-ref">(13)</span></a> with
<span class="math">\(\Delta t=0.1, 0.05\)</span>.
From the plot we make the following observations:</p>
<blockquote>
<div><ul class="simple">
<li>The numerical solution seems to have correct amplitude.</li>
<li>There is an angular frequency error which is reduced by decreasing the time step.</li>
<li>The total angular frequency error grows with time.</li>
</ul>
</div></blockquote>
<p>By angular frequency error we mean that the numerical angular frequency differs
from the exact <span class="math">\(\omega\)</span>. This is evident by looking
at the peaks of the numerical solution: these have incorrect
positions compared with the peaks of the exact cosine solution. The
effect can be mathematically expressed by writing the numerical solution
as <span class="math">\(I\cos\tilde\omega t\)</span>, where <span class="math">\(\tilde\omega\)</span> is not exactly
equal to <span class="math">\(\omega\)</span>. Later, we shall mathematically
quantify this numerical angular frequency <span class="math">\(\tilde\omega\)</span>.</p>
<div class="figure" id="id12">
<span id="vib-ode1-2dt"></span><a class="reference internal image-reference" href="_images/vib_freq_err1.png"><img alt="_images/vib_freq_err1.png" src="_images/vib_freq_err1.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Effect of halving the time step</em></span></p>
</div>
<div class="section" id="using-a-moving-plot-window">
<h3>Using a moving plot window<a class="headerlink" href="#using-a-moving-plot-window" title="Permalink to this headline">¶</a></h3>
<p>In vibration problems it is often of interest to investigate the system&#8217;s
behavior over long time intervals. Errors in the angular frequency accumulate
and become more visible as time grows. We can investigate long
time series by introducing a moving plot window that can move along with
the <span class="math">\(p\)</span> most recently computed periods of the solution. The
<a class="reference external" href="https://github.com/hplgit/scitools">SciTools</a> package contains
a convenient tool for this: <code class="docutils literal"><span class="pre">MovingPlotWindow</span></code>. Typing
<code class="docutils literal"><span class="pre">pydoc</span> <span class="pre">scitools.MovingPlotWindow</span></code> shows a demo and a description of its use.
The function below utilizes the moving plot window and is in fact
called by the <code class="docutils literal"><span class="pre">main</span></code> function in the <code class="docutils literal"><span class="pre">vib_undamped</span></code> module
if the number of periods in the simulation exceeds 10.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">visualize_front</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">skip_frames</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Visualize u and the exact solution vs t, using a</span>
<span class="sd">    moving plot window and continuous drawing of the</span>
<span class="sd">    curves as they evolve in time.</span>
<span class="sd">    Makes it easy to plot very long time series.</span>
<span class="sd">    Plots are saved to files if savefig is True.</span>
<span class="sd">    Only each skip_frames-th plot is saved (e.g., if</span>
<span class="sd">    skip_frame=10, only each 10th plot is saved to file;</span>
<span class="sd">    this is convenient if plot files corresponding to</span>
<span class="sd">    different time steps are to be compared).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">scitools.std</span> <span class="kn">as</span> <span class="nn">st</span>
    <span class="kn">from</span> <span class="nn">scitools.MovingPlotWindow</span> <span class="kn">import</span> <span class="n">MovingPlotWindow</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>

    <span class="c1"># Remove all old plot files tmp_*.png</span>
    <span class="kn">import</span> <span class="nn">glob</span><span class="o">,</span> <span class="nn">os</span>
    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;tmp_*.png&#39;</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>  <span class="c1"># one period</span>
    <span class="n">umin</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">min</span><span class="p">();</span>  <span class="n">umax</span> <span class="o">=</span> <span class="o">-</span><span class="n">umin</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">plot_manager</span> <span class="o">=</span> <span class="n">MovingPlotWindow</span><span class="p">(</span>
        <span class="n">window_width</span><span class="o">=</span><span class="mi">8</span><span class="o">*</span><span class="n">P</span><span class="p">,</span>
        <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span>
        <span class="n">yaxis</span><span class="o">=</span><span class="p">[</span><span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">],</span>
        <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;continuous drawing&#39;</span><span class="p">)</span>
    <span class="n">frame_counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">plot_manager</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">plot_manager</span><span class="o">.</span><span class="n">first_index_in_plot</span>
            <span class="n">st</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;r-1&#39;</span><span class="p">,</span>
                    <span class="n">t</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">I</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)[</span><span class="n">s</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;b-1&#39;</span><span class="p">,</span>
                    <span class="n">title</span><span class="o">=</span><span class="s1">&#39;t=</span><span class="si">%6.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">plot_manager</span><span class="o">.</span><span class="n">axis</span><span class="p">(),</span>
                    <span class="n">show</span><span class="o">=</span><span class="ow">not</span> <span class="n">savefig</span><span class="p">)</span> <span class="c1"># drop window if savefig</span>
            <span class="k">if</span> <span class="n">savefig</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">%</span> <span class="n">skip_frames</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;tmp_</span><span class="si">%04d</span><span class="s1">.png&#39;</span> <span class="o">%</span> <span class="n">frame_counter</span>
                <span class="n">st</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                <span class="k">print</span> <span class="s1">&#39;making plot file&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;at t=</span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="n">frame_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">plot_manager</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>We run the scaled problem (the default values for the command-line arguments
<code class="docutils literal"><span class="pre">--I</span></code> and <code class="docutils literal"><span class="pre">--w</span></code> correspond to the scaled problem) for 40 periods with 20
time steps per period:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Terminal&gt; python vib_undamped.py --dt 0.05 --num_periods 40
</pre></div>
</div>
<p>The moving plot window is invoked, and we can follow the numerical and exact
solutions as time progresses. From this demo we see that
the angular frequency error is small in the beginning, and that it becomes more
prominent with time. A new run with <span class="math">\(\Delta t=0.1\)</span> (i.e., only 10 time steps per period)
clearly shows that the phase errors become significant even earlier
in the time series, deteriorating the solution further.</p>
</div>
<div class="section" id="making-animations">
<span id="vib-ode1-anim"></span><h3>Making animations<a class="headerlink" href="#making-animations" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-20"></span><span class="target" id="index-21"></span><span class="target" id="index-22"></span><span class="target" id="index-23"></span><span class="target" id="index-24"></span><span class="target" id="index-25"></span><div class="section" id="producing-standard-video-formats">
<span id="index-26"></span><h4>Producing standard video formats<a class="headerlink" href="#producing-standard-video-formats" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">visualize_front</span></code> function stores all the plots in
files whose names are numbered:
<code class="docutils literal"><span class="pre">tmp_0000.png</span></code>, <code class="docutils literal"><span class="pre">tmp_0001.png</span></code>, <code class="docutils literal"><span class="pre">tmp_0002.png</span></code>,
and so on. From these files we may make a movie. The Flash
format is popular,</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Terminal&gt; ffmpeg -r 25 -i tmp_%04d.png -c:v flv movie.flv
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">-r</span></code> option should come first and
describes the number of frames per second in the movie (even if we
would like to have slow movies, keep this number as large as 25,
otherwise files are skipped from the movie). The
<code class="docutils literal"><span class="pre">-i</span></code> option describes the name of the plot files.
Other formats can be generated by changing the video codec
and equipping the video file with the right extension:</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Codec and filename</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Flash</td>
<td><code class="docutils literal"><span class="pre">-c:v</span> <span class="pre">flv</span> <span class="pre">movie.flv</span></code></td>
</tr>
<tr class="row-odd"><td>MP4</td>
<td><code class="docutils literal"><span class="pre">-c:v</span> <span class="pre">libx264</span> <span class="pre">movie.mp4</span></code></td>
</tr>
<tr class="row-even"><td>WebM</td>
<td><code class="docutils literal"><span class="pre">-c:v</span> <span class="pre">libvpx</span> <span class="pre">movie.webm</span></code></td>
</tr>
<tr class="row-odd"><td>Ogg</td>
<td><code class="docutils literal"><span class="pre">-c:v</span> <span class="pre">libtheora</span> <span class="pre">movie.ogg</span></code></td>
</tr>
</tbody>
</table>
<p id="index-27">The video file can be played by some video player like <code class="docutils literal"><span class="pre">vlc</span></code>, <code class="docutils literal"><span class="pre">mplayer</span></code>,
<code class="docutils literal"><span class="pre">gxine</span></code>, or <code class="docutils literal"><span class="pre">totem</span></code>, e.g.,</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Terminal&gt; vlc movie.webm
</pre></div>
</div>
<p>A web page can also be used to play the movie. Today&#8217;s standard is
to use the HTML5 <code class="docutils literal"><span class="pre">video</span></code> tag:</p>
<div class="highlight-html"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">video</span> <span class="na">autoplay</span> <span class="na">loop</span> <span class="na">controls</span>
       <span class="na">width</span><span class="o">=</span><span class="s">&#39;640&#39;</span> <span class="na">height</span><span class="o">=</span><span class="s">&#39;365&#39;</span> <span class="na">preload</span><span class="o">=</span><span class="s">&#39;none&#39;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">source</span> <span class="na">src</span><span class="o">=</span><span class="s">&#39;movie.webm&#39;</span>  <span class="na">type</span><span class="o">=</span><span class="s">&#39;video/webm; codecs=&quot;vp8, vorbis&quot;&#39;</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">video</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Modern browsers do not support all of the video formats.
MP4 is needed to successfully play the videos on Apple devices
that use the Safari browser.
WebM is the preferred format for Chrome, Opera, Firefox, and Internet
Explorer v9+. Flash was a popular format, but older browsers that
required Flash can play MP4. All browsers that work with Ogg can also
work with WebM. This means that to have a video work in all browsers,
the video should be available in the MP4 and WebM formats.
The proper HTML code reads</p>
<div class="highlight-html"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">video</span> <span class="na">autoplay</span> <span class="na">loop</span> <span class="na">controls</span>
       <span class="na">width</span><span class="o">=</span><span class="s">&#39;640&#39;</span> <span class="na">height</span><span class="o">=</span><span class="s">&#39;365&#39;</span> <span class="na">preload</span><span class="o">=</span><span class="s">&#39;none&#39;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">source</span> <span class="na">src</span><span class="o">=</span><span class="s">&#39;movie.mp4&#39;</span>   <span class="na">type</span><span class="o">=</span><span class="s">&#39;video/mp4;</span>
<span class="s"> codecs=&quot;avc1.42E01E, mp4a.40.2&quot;&#39;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">source</span> <span class="na">src</span><span class="o">=</span><span class="s">&#39;movie.webm&#39;</span>  <span class="na">type</span><span class="o">=</span><span class="s">&#39;video/webm;</span>
<span class="s"> codecs=&quot;vp8, vorbis&quot;&#39;</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">video</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>The MP4 format should appear first to ensure that Apple devices will
load the video correctly.</p>
<div class="admonition-caution-number-the-plot-files-correctly admonition">
<p class="first admonition-title">Caution: number the plot files correctly</p>
<p class="last">To ensure that the individual plot frames are shown in correct order,
it is important to number the files with zero-padded numbers
(0000, 0001, 0002, etc.). The printf format <code class="docutils literal"><span class="pre">%04d</span></code> specifies an
integer in a field of width 4, padded with zeros from the left.
A simple Unix wildcard file specification like <code class="docutils literal"><span class="pre">tmp_*.png</span></code>
will then list the frames in the right order. If the numbers in the
filenames were not zero-padded, the frame <code class="docutils literal"><span class="pre">tmp_11.png</span></code> would appear
before <code class="docutils literal"><span class="pre">tmp_2.png</span></code> in the movie.</p>
</div>
</div>
<div class="section" id="playing-png-files-in-a-web-browser">
<h4>Playing PNG files in a web browser<a class="headerlink" href="#playing-png-files-in-a-web-browser" title="Permalink to this headline">¶</a></h4>
<p id="index-28">The <code class="docutils literal"><span class="pre">scitools</span> <span class="pre">movie</span></code> command can create a movie player for a set
of PNG files such that a web browser can be used to watch the movie.
This interface has the advantage that the speed of the movie can
easily be controlled, a feature that scientists often appreciate.
The command for creating an HTML with a player for a set of
PNG files <code class="docutils literal"><span class="pre">tmp_*.png</span></code> goes like</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Terminal&gt; scitools movie output_file=vib.html fps=4 tmp_*.png
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">fps</span></code> argument controls the speed of the movie (&#8220;frames per second&#8221;).</p>
<p>To watch the movie, load the video file <code class="docutils literal"><span class="pre">vib.html</span></code> into some browser, e.g.,</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Terminal&gt; google-chrome vib.html  # invoke web page
</pre></div>
</div>
<p>Clicking on <code class="docutils literal"><span class="pre">Start</span> <span class="pre">movie</span></code> to see the result. Moving this movie to
some other place requires moving <code class="docutils literal"><span class="pre">vib.html</span></code> <em>and all the PNG files</em>
<code class="docutils literal"><span class="pre">tmp_*.png</span></code>:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Terminal&gt; mkdir vib_dt0.1
Terminal&gt; mv tmp_*.png vib_dt0.1
Terminal&gt; mv vib.html vib_dt0.1/index.html
</pre></div>
</div>
</div>
<div class="section" id="making-animated-gif-files">
<h4>Making animated GIF files<a class="headerlink" href="#making-animated-gif-files" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">convert</span></code> program from the ImageMagick software suite can be
used to produce animated GIF files from a set of PNG files:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Terminal&gt; convert -delay 25 tmp_vib*.png tmp_vib.gif
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">-delay</span></code> option needs an argument of the delay between each frame,
measured in 1/100 s, so 4 frames/s here gives 25/100 s delay.
Note, however, that in this particular example
with <span class="math">\(\Delta t=0.05\)</span> and 40 periods,
making an animated GIF file out of
the large number of PNG files is a very heavy process and not
considered feasible. Animated GIFs are best suited for animations with
not so many frames and where you want to see each frame and play them
slowly.</p>
</div>
</div>
<div class="section" id="using-bokeh-to-compare-graphs">
<h3>Using Bokeh to compare graphs<a class="headerlink" href="#using-bokeh-to-compare-graphs" title="Permalink to this headline">¶</a></h3>
<p>Instead of a moving plot frame, one can use tools that allow panning
by the mouse. For example, we can show four periods of several signals in
several plots and then scroll with the mouse through the rest of the
simulation <em>simultaneously</em> in all the plot windows.
The <a class="reference external" href="http://bokeh.pydata.org/en/latest/docs/quickstart.html">Bokeh</a> plotting library offers such tools, but the plots must be displayed in
a web browser. The documentation of Bokeh is excellent, so here we just
show how the library can be used to compare a set of <span class="math">\(u\)</span> curves corresponding
to long time simulations. (By the way, the guidance to correct
pronunciation of Bokeh in
the <a class="reference external" href="http://bokeh.pydata.org/en/0.10.0/docs/faq.html#how-do-you-pronounce-bokeh">documentation</a> and on <a class="reference external" href="https://en.wikipedia.org/wiki/Bokeh">Wikipedia</a> is not directly compatible with a <a class="reference external" href="https://www.youtube.com/watch?v=OR8HSHevQTM">YouTube video</a>...).</p>
<p>Imagine we have performed experiments for a set of <span class="math">\(\Delta t\)</span> values.
We want each curve, together with the exact solution, to appear in
a plot, and then arrange all plots in a grid-like fashion:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/bokeh_gridplot1.png"><img alt="_images/bokeh_gridplot1.png" src="_images/bokeh_gridplot1.png" style="width: 800px;" /></a>
</div>
<p>Furthermore, we want the axes to couple such that if we move into
the future in one plot, all the other plots follows (note the
displaced <span class="math">\(t\)</span> axes!):</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/bokeh_gridplot2.png"><img alt="_images/bokeh_gridplot2.png" src="_images/bokeh_gridplot2.png" style="width: 800px;" /></a>
</div>
<p>A function for creating a Bokeh plot, given a list of <code class="docutils literal"><span class="pre">u</span></code> arrays
and corresponding <code class="docutils literal"><span class="pre">t</span></code> arrays, is implemented below.
The code combines data fro different simulations, described
compactly in a list of strings <code class="docutils literal"><span class="pre">legends</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bokeh_plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">legends</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">t_range</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make plots for u vs t using the Bokeh library.</span>
<span class="sd">    u and t are lists (several experiments can be compared).</span>
<span class="sd">    legens contain legend strings for the various u,t pairs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span><span class="p">]</span>  <span class="c1"># wrap in list</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span>  <span class="c1"># wrap in list</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">legends</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">legends</span> <span class="o">=</span> <span class="p">[</span><span class="n">legends</span><span class="p">]</span>  <span class="c1"># wrap in list</span>

    <span class="kn">import</span> <span class="nn">bokeh.plotting</span> <span class="kn">as</span> <span class="nn">plt</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">output_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;cdn&#39;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Comparison&#39;</span><span class="p">)</span>
    <span class="c1"># Assume that all t arrays have the same range</span>
    <span class="n">t_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1001</span><span class="p">)</span>  <span class="c1"># fine mesh for u_e</span>
    <span class="n">tools</span> <span class="o">=</span> <span class="s1">&#39;pan,wheel_zoom,box_zoom,reset,&#39;</span>\
            <span class="s1">&#39;save,box_select,lasso_select&#39;</span>
    <span class="n">u_range</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.2</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">I</span><span class="p">]</span>
    <span class="n">font_size</span> <span class="o">=</span> <span class="s1">&#39;8pt&#39;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of plot objects</span>
    <span class="c1"># Make the first figure</span>
    <span class="n">p_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span>
        <span class="n">width</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">plot_height</span><span class="o">=</span><span class="mi">250</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">legends</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">x_axis_label</span><span class="o">=</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="n">y_axis_label</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">,</span>
        <span class="n">x_range</span><span class="o">=</span><span class="n">t_range</span><span class="p">,</span> <span class="n">y_range</span><span class="o">=</span><span class="n">u_range</span><span class="p">,</span> <span class="n">tools</span><span class="o">=</span><span class="n">tools</span><span class="p">,</span>
        <span class="n">title_text_font_size</span><span class="o">=</span><span class="n">font_size</span><span class="p">)</span>
    <span class="n">p_</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">axis_label_text_font_size</span><span class="o">=</span><span class="n">font_size</span>
    <span class="n">p_</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">axis_label_text_font_size</span><span class="o">=</span><span class="n">font_size</span>
    <span class="n">p_</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">line_color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)</span>
    <span class="c1"># Add exact solution</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="n">p_</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="n">line_color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">line_dash</span><span class="o">=</span><span class="s1">&#39;4 4&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_</span><span class="p">)</span>
    <span class="c1"># Make the rest of the figures and attach their axes to</span>
    <span class="c1"># the first figure&#39;s axes</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
        <span class="n">p_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span>
            <span class="n">width</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">plot_height</span><span class="o">=</span><span class="mi">250</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">legends</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="n">x_axis_label</span><span class="o">=</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="n">y_axis_label</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">,</span>
            <span class="n">x_range</span><span class="o">=</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x_range</span><span class="p">,</span> <span class="n">y_range</span><span class="o">=</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y_range</span><span class="p">,</span> <span class="n">tools</span><span class="o">=</span><span class="n">tools</span><span class="p">,</span>
            <span class="n">title_text_font_size</span><span class="o">=</span><span class="n">font_size</span><span class="p">)</span>
        <span class="n">p_</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">axis_label_text_font_size</span> <span class="o">=</span> <span class="n">font_size</span>
        <span class="n">p_</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">axis_label_text_font_size</span> <span class="o">=</span> <span class="n">font_size</span>
        <span class="n">p_</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">line_color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)</span>
        <span class="n">p_</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="n">line_color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">line_dash</span><span class="o">=</span><span class="s1">&#39;4 4&#39;</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_</span><span class="p">)</span>

    <span class="c1"># Arrange all plots in a grid with 3 plots per row</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="p">[[]]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="n">grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># New row</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gridplot</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">toolbar_location</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">plot</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">plot</span><span class="p">)</span>
</pre></div>
</div>
<p>A particular example using the <code class="docutils literal"><span class="pre">bokeh_plot</span></code> function appears below.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">demo_bokeh</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Solve a scaled ODE u&#39;&#39; + u = 0.&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mf">1.0</span>        <span class="c1"># Scaled problem (frequency)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>  <span class="c1"># Period</span>
    <span class="n">num_steps_per_period</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">80</span><span class="p">]</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">40</span><span class="o">*</span><span class="n">P</span>       <span class="c1"># Simulation time: 40 periods</span>
    <span class="n">u</span> <span class="o">=</span> <span class="p">[]</span>         <span class="c1"># List of numerical solutions</span>
    <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>         <span class="c1"># List of corresponding meshes</span>
    <span class="n">legends</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">num_steps_per_period</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">P</span><span class="o">/</span><span class="n">n</span>
        <span class="n">u_</span><span class="p">,</span> <span class="n">t_</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">)</span>
        <span class="n">u</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t_</span><span class="p">)</span>
        <span class="n">legends</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;# time steps per period: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">bokeh_plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">legends</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">t_range</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">P</span><span class="p">],</span>
               <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;tmp.html&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="using-a-line-by-line-ascii-plotter">
<h3>Using a line-by-line ascii plotter<a class="headerlink" href="#using-a-line-by-line-ascii-plotter" title="Permalink to this headline">¶</a></h3>
<p>Plotting functions vertically, line by line, in the terminal window
using ascii characters only is a simple, fast, and convenient
visualization technique for long time series. Note that the time
axis then is positive downwards on the screen, so we can let the
solution be visualized &#8220;forever&#8221;.
The tool
<code class="docutils literal"><span class="pre">scitools.avplotter.Plotter</span></code> makes it easy to create such plots:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">visualize_front_ascii</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot u and the exact solution vs t line by line in a</span>
<span class="sd">    terminal window (only using ascii characters).</span>
<span class="sd">    Makes it easy to plot very long time series.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scitools.avplotter</span> <span class="kn">import</span> <span class="n">Plotter</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>
    <span class="n">umin</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">min</span><span class="p">();</span>  <span class="n">umax</span> <span class="o">=</span> <span class="o">-</span><span class="n">umin</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">Plotter</span><span class="p">(</span><span class="n">ymin</span><span class="o">=</span><span class="n">umin</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="n">umax</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="s1">&#39;+o&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)):</span>
        <span class="k">print</span> <span class="n">p</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">I</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])),</span> \
              <span class="s1">&#39;</span><span class="si">%.1f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">/</span><span class="n">P</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">fps</span><span class="p">))</span>
</pre></div>
</div>
<p>The call <code class="docutils literal"><span class="pre">p.plot</span></code> returns a line of text, with the <span class="math">\(t\)</span> axis marked and
a symbol <code class="docutils literal"><span class="pre">+</span></code> for the first function (<code class="docutils literal"><span class="pre">u</span></code>) and <code class="docutils literal"><span class="pre">o</span></code> for the second
function (the exact solution). Here we append to this text
a time counter reflecting how many periods the current time point
corresponds to. A typical output (<span class="math">\(\omega =2\pi\)</span>, <span class="math">\(\Delta t=0.05\)</span>)
looks like this:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>                         |                       o+      14.0
                         |                      + o      14.0
                         |                  +    o       14.1
                         |             +     o           14.1
                         |     +        o                14.2
                        +|       o                       14.2
                +        |                               14.2
         +       o       |                               14.3
    +     o              |                               14.4
 +   o                   |                               14.4
+o                       |                               14.5
o +                      |                               14.5
 o    +                  |                               14.6
     o      +            |                               14.6
          o        +     |                               14.7
                 o       | +                             14.7
                         |        +                      14.8
                         |       o       +               14.8
                         |              o     +          14.9
                         |                   o   +       14.9
                         |                       o+      15.0
</pre></div>
</div>
</div>
<div class="section" id="empirical-analysis-of-the-solution">
<span id="vib-ode1-empirical"></span><h3>Empirical analysis of the solution<a class="headerlink" href="#empirical-analysis-of-the-solution" title="Permalink to this headline">¶</a></h3>
<p>For oscillating functions like those in Figure <a class="reference internal" href="#vib-ode1-2dt"><span class="std std-ref">Effect of halving the time step</span></a> we may
compute the amplitude and frequency (or period) empirically.
That is, we run through the discrete solution points <span class="math">\((t_n, u_n)\)</span> and
find all maxima and minima points. The distance between two consecutive
maxima (or minima) points can be used as estimate of the local period,
while half the difference between the <span class="math">\(u\)</span> value at a maximum and a nearby
minimum gives an estimate of the local amplitude.</p>
<p>The local maxima are the points where</p>
<div class="math" id="eq-auto4">
\[\tag{14}
u^{n-1} &lt; u^n &gt; u^{n+1},\quad n=1,\ldots,N_t-1,\]</div>
<p>and the local minima are recognized by</p>
<div class="math" id="eq-auto5">
\[\tag{15}
u^{n-1} &gt; u^n &lt; u^{n+1},\quad n=1,\ldots,N_t-1
    {\thinspace .}\]</div>
<p>In computer code this becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">minmax</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
    <span class="n">minima</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">maxima</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">minima</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">maxima</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">minima</span><span class="p">,</span> <span class="n">maxima</span>
</pre></div>
</div>
<p>Note that the two returned objects are lists of tuples.</p>
<p>Let <span class="math">\((t_i, e_i)\)</span>, <span class="math">\(i=0,\ldots,M-1\)</span>, be the sequence of all
the <span class="math">\(M\)</span> maxima points, where <span class="math">\(t_i\)</span>
is the time value and <span class="math">\(e_i\)</span> the corresponding <span class="math">\(u\)</span> value.
The local period can be defined as <span class="math">\(p_i=t_{i+1}-t_i\)</span>.
With Python syntax this reads</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">periods</span><span class="p">(</span><span class="n">maxima</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">extrema</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">maxima</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
         <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">maxima</span><span class="p">))]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p>The list <code class="docutils literal"><span class="pre">p</span></code> created by a list comprehension is converted to an array
since we probably want to compute with it, e.g., find the corresponding
frequencies <code class="docutils literal"><span class="pre">2*pi/p</span></code>.</p>
<p>Having the minima and the maxima, the local amplitude can be
calculated as the difference between two neighboring minimum and
maximum points:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">amplitudes</span><span class="p">(</span><span class="n">minima</span><span class="p">,</span> <span class="n">maxima</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">abs</span><span class="p">(</span><span class="n">maxima</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">minima</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span><span class="o">/</span><span class="mf">2.0</span>
         <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">minima</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">maxima</span><span class="p">)))]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>The code segments are found in the file <a class="reference external" href="http://tinyurl.com/nu656p2/vib/vib_empirical_analysis.py">vib_empirical_analysis.py</a>.</p>
<p>Since <code class="docutils literal"><span class="pre">a[i]</span></code> and <code class="docutils literal"><span class="pre">p[i]</span></code> correspond to
the <span class="math">\(i\)</span>-th amplitude estimate and the <span class="math">\(i\)</span>-th period estimate, respectively,
it is most convenient to visualize the <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">p</span></code> values with the
index <code class="docutils literal"><span class="pre">i</span></code> on the horizontal axis.
(There is no unique time point associated with either of these estimate
since values at two different time points were used in the
computations.)</p>
<p>In the analysis of very long time series, it is advantageous to
compute and plot <code class="docutils literal"><span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">a</span></code> instead of <span class="math">\(u\)</span> to get an impression of
the development of the oscillations. Let us do this for the scaled
problem and <span class="math">\(\Delta t=0.1, 0.05, 0.01\)</span>.
A ready-made function</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">plot_empirical_freq_and_amplitude</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
<p>computes the empirical amplitudes and periods, and creates a plot
where the amplitudes and angular frequencies
are visualized together with the exact amplitude <code class="docutils literal"><span class="pre">I</span></code>
and the exact angular frequency <code class="docutils literal"><span class="pre">w</span></code>. We can make a little program
for creating the plot:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">vib_undamped</span> <span class="kn">import</span> <span class="n">solver</span><span class="p">,</span> <span class="n">plot_empirical_freq_and_amplitude</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
<span class="n">dt_values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">]</span>
<span class="n">u_cases</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">t_cases</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dt_values</span><span class="p">:</span>
    <span class="c1"># Simulate scaled problem for 40 periods</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
    <span class="n">u_cases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">t_cases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">plot_empirical_freq_and_amplitude</span><span class="p">(</span><span class="n">u_cases</span><span class="p">,</span> <span class="n">t_cases</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span>
</pre></div>
</div>
<p>Figure <a class="reference internal" href="#vib-ode1-fig-freq-ampl"><span class="std std-ref">Empirical angular frequency (left) and amplitude (right) for three different time steps</span></a> shows the result: we clearly see that
lowering <span class="math">\(\Delta t\)</span> improves the angular frequency significantly, while the
amplitude seems to be more accurate.
The lines with
<span class="math">\(\Delta t=0.01\)</span>, corresponding to 100 steps per period, can hardly be
distinguished from the exact values. The next section shows how we
can get mathematical insight into why amplitudes are good while frequencies
are more inaccurate.</p>
<div class="figure" id="id13">
<span id="vib-ode1-fig-freq-ampl"></span><a class="reference internal image-reference" href="_images/empirical_ampl_freq.png"><img alt="_images/empirical_ampl_freq.png" src="_images/empirical_ampl_freq.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Empirical angular frequency (left) and amplitude (right) for three different time steps</em></span></p>
</div>
</div>
</div>
<div class="section" id="analysis-of-the-numerical-scheme">
<span id="vib-ode1-analysis"></span><h2>Analysis of the numerical scheme<a class="headerlink" href="#analysis-of-the-numerical-scheme" title="Permalink to this headline">¶</a></h2>
<div class="section" id="deriving-a-solution-of-the-numerical-scheme">
<span id="vib-ode1-analysis-solderiv"></span><h3>Deriving a solution of the numerical scheme<a class="headerlink" href="#deriving-a-solution-of-the-numerical-scheme" title="Permalink to this headline">¶</a></h3>
<p>After having seen the phase error grow with time in the previous
section, we shall now quantify this error through mathematical
analysis.  The key tool in the analysis will be to establish an exact
solution of the discrete equations.  The difference equation
<a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a> has constant coefficients and is
homogeneous. Such equations are known to have solutions on the form
<span class="math">\(u^n=CA^n\)</span>, where <span class="math">\(A\)</span> is some number
to be determined from the difference equation and <span class="math">\(C\)</span> is found as the
initial condition (<span class="math">\(C=I\)</span>).  Recall that <span class="math">\(n\)</span> in <span class="math">\(u^n\)</span> is a
superscript labeling the time level, while <span class="math">\(n\)</span> in <span class="math">\(A^n\)</span> is an
exponent.</p>
<p>With oscillating functions as solutions, the algebra will
be considerably simplified if we seek an <span class="math">\(A\)</span> on the form</p>
<div class="math">
\[A=e^{i\tilde\omega \Delta t},\]</div>
<p>and solve for the numerical frequency <span class="math">\(\tilde\omega\)</span> rather than
<span class="math">\(A\)</span>. Note that <span class="math">\(i=\sqrt{-1}\)</span> is the imaginary unit. (Using a
complex exponential function gives simpler arithmetics than working
with a sine or cosine function.)
We have</p>
<div class="math">
\[A^n = e^{i\tilde\omega \Delta t\, n}=e^{i\tilde\omega t_n} =
\cos (\tilde\omega t_n) + i\sin(\tilde \omega t_n)
{\thinspace .}\]</div>
<p>The physically relevant numerical solution can
be taken as the real part of this complex expression.</p>
<p>The calculations go as</p>
<div class="math">
\[\begin{split}\begin{align*}
[D_tD_t u]^n &amp;= \frac{u^{n+1} - 2u^n + u^{n-1}}{\Delta t^2}\\
&amp;= I\frac{A^{n+1} - 2A^n + A^{n-1}}{\Delta t^2}\\
&amp;= \frac{I}{\Delta t^{2}}(e^{i\tilde\omega(t_n+\Delta t)} - 2e^{i\tilde\omega t_n} + e^{i\tilde\omega(t_n-\Delta t)})\\
&amp;= Ie^{i\tilde\omega t_n}\frac{1}{\Delta t^2}\left(e^{i\tilde\omega\Delta t} + e^{i\tilde\omega(-\Delta t)} - 2\right)\\
&amp;= Ie^{i\tilde\omega t_n}\frac{2}{\Delta t^2}\left(\cosh(i\tilde\omega\Delta t) -1 \right)\\
&amp;= Ie^{i\tilde\omega t_n}\frac{2}{\Delta t^2}\left(\cos(\tilde\omega\Delta t) -1 \right)\\
&amp;= -Ie^{i\tilde\omega t_n}\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2})
\end{align*}\end{split}\]</div>
<p>The last line follows from the relation
<span class="math">\(\cos x - 1 = -2\sin^2(x/2)\)</span> (try <code class="docutils literal"><span class="pre">cos(x)-1</span></code> in
<a class="reference external" href="http://www.wolframalpha.com">wolframalpha.com</a> to see the formula).</p>
<p>The scheme <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a>
with <span class="math">\(u^n=Ie^{i\tilde\omega\Delta t\, n}\)</span> inserted now gives</p>
<div class="math" id="eq-auto6">
\[\tag{16}
-Ie^{i\tilde\omega t_n}
    \frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2})
    + \omega^2 Ie^{i\tilde\omega t_n} = 0,\]</div>
<p>which after dividing by <span class="math">\(Ie^{i\tilde\omega t_n}\)</span> results in</p>
<div class="math" id="eq-auto7">
\[\tag{17}
\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2}) = \omega^2
    {\thinspace .}\]</div>
<p>The first step in solving for the unknown <span class="math">\(\tilde\omega\)</span> is</p>
<div class="math">
\[\sin^2(\frac{\tilde\omega\Delta t}{2}) = \left(\frac{\omega\Delta t}{2}\right)^2
{\thinspace .}\]</div>
<p>Then, taking the square root, applying the inverse sine function, and
multiplying by <span class="math">\(2/\Delta t\)</span>, results in</p>
<div class="math" id="eq-vib-ode1-tildeomega">
\[\tag{18}
\tilde\omega = \pm \frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
    {\thinspace .}\]</div>
</div>
<div class="section" id="the-error-in-the-numerical-frequency">
<span id="vib-ode1-analysis-numfreq"></span><h3>The error in the numerical frequency<a class="headerlink" href="#the-error-in-the-numerical-frequency" title="Permalink to this headline">¶</a></h3>
<p>The first observation of <a class="reference internal" href="#eq-vib-ode1-tildeomega"><span class="std std-ref">(18)</span></a> tells that there
is a phase error since the numerical frequency <span class="math">\(\tilde\omega\)</span> never
equals the exact frequency <span class="math">\(\omega\)</span>. But how good is the approximation
<a class="reference internal" href="#eq-vib-ode1-tildeomega"><span class="std std-ref">(18)</span></a>? That is, what is the error <span class="math">\(\omega -
\tilde\omega\)</span> or <span class="math">\(\tilde\omega/\omega\)</span>?  Taylor series expansion for
small <span class="math">\(\Delta t\)</span> may give an expression that is easier to understand
than the complicated function in <a class="reference internal" href="#eq-vib-ode1-tildeomega"><span class="std std-ref">(18)</span></a>:</p>
<div class="highlight-ipy"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dt</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;dt w&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w_tilde_e</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="n">dt</span><span class="o">*</span><span class="n">asin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w_tilde_series</span> <span class="o">=</span> <span class="n">w_tilde_e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">w_tilde_series</span>
<span class="n">w</span> <span class="o">+</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mi">24</span> <span class="o">+</span> <span class="n">O</span><span class="p">(</span><span class="n">dt</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>This means that</p>
<div class="math" id="eq-vib-ode1-tildeomega-series">
\[\tag{19}
\tilde\omega = \omega\left( 1 + \frac{1}{24}\omega^2\Delta t^2\right)
    + {\mathcal{O}(\Delta t^4)}
    {\thinspace .}\]</div>
<p>The error in the numerical frequency is of second-order in <span class="math">\(\Delta t\)</span>,
and the error vanishes as <span class="math">\(\Delta t\rightarrow 0\)</span>.  We see that
<span class="math">\(\tilde\omega &gt; \omega\)</span> since the term <span class="math">\(\omega^3\Delta t^2/24 &gt;0\)</span> and
this is by far the biggest term in the series expansion for small
<span class="math">\(\omega\Delta t\)</span>. A numerical frequency that is too large gives an
oscillating curve that oscillates too fast and therefore &#8220;lags
behind&#8221; the exact oscillations, a feature that can be seen in the
left plot in Figure <a class="reference internal" href="#vib-ode1-2dt"><span class="std std-ref">Effect of halving the time step</span></a>.</p>
<p>Figure <a class="reference internal" href="#vib-ode1-tildeomega-plot"><span class="std std-ref">Exact discrete frequency and its second-order series expansion</span></a> plots the discrete frequency
<a class="reference internal" href="#eq-vib-ode1-tildeomega"><span class="std std-ref">(18)</span></a> and its approximation
<a class="reference internal" href="#eq-vib-ode1-tildeomega-series"><span class="std std-ref">(19)</span></a> for <span class="math">\(\omega =1\)</span> (based on the
program <a class="reference external" href="http://tinyurl.com/nu656p2/vib/vib_plot_freq.py">vib_plot_freq.py</a>).
Although <span class="math">\(\tilde\omega\)</span> is a function of <span class="math">\(\Delta t\)</span> in
<a class="reference internal" href="#eq-vib-ode1-tildeomega-series"><span class="std std-ref">(19)</span></a>, it is misleading to think of
<span class="math">\(\Delta t\)</span> as the important discretization parameter. It is the
product <span class="math">\(\omega\Delta t\)</span> that is the key discretization
parameter. This quantity reflects the <em>number of time steps per
period</em> of the oscillations.  To see this, we set <span class="math">\(P=N_P\Delta t\)</span>,
where <span class="math">\(P\)</span> is the length of a period, and <span class="math">\(N_P\)</span> is the number of time
steps during a period.  Since <span class="math">\(P\)</span> and <span class="math">\(\omega\)</span> are related by
<span class="math">\(P=2\pi/\omega\)</span>, we get that <span class="math">\(\omega\Delta t = 2\pi/N_P\)</span>, which shows
that <span class="math">\(\omega\Delta t\)</span> is directly related to <span class="math">\(N_P\)</span>.</p>
<p>The plot shows that at least <span class="math">\(N_P\sim 25-30\)</span> points per period are
necessary for reasonable accuracy, but this depends on the length of
the simulation (<span class="math">\(T\)</span>) as the total phase error due to the frequency
error grows linearly with time (see <a class="reference internal" href="#vib-exer-phase-err-growth"><span class="std std-ref">Exercise 1.2: Show linear growth of the phase with time</span></a>).</p>
<div class="figure" id="id14">
<span id="vib-ode1-tildeomega-plot"></span><a class="reference internal image-reference" href="_images/discrete_freq.png"><img alt="_images/discrete_freq.png" src="_images/discrete_freq.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>Exact discrete frequency and its second-order series expansion</em></span></p>
</div>
</div>
<div class="section" id="empirical-convergence-rates-and-adjusted">
<h3>Empirical convergence rates and adjusted <span class="math">\(\omega\)</span><a class="headerlink" href="#empirical-convergence-rates-and-adjusted" title="Permalink to this headline">¶</a></h3>
<p>The expression <a class="reference internal" href="#eq-vib-ode1-tildeomega-series"><span class="std std-ref">(19)</span></a> suggest that
adjusting omega to</p>
<div class="math">
\[\omega\left( 1 - \frac{1}{24}\omega^2\Delta t^2\right),\]</div>
<p>could have effect on the <em>convergence rate</em> of the global error in <span class="math">\(u\)</span>
(cf. the section <a class="reference internal" href="#vib-ode1-verify"><span class="std std-ref">Verification</span></a>). With the <code class="docutils literal"><span class="pre">convergence_rates</span></code> function
in <code class="docutils literal"><span class="pre">vib_undamped.py</span></code> we can easily check this. A special solver, with
adjusted <span class="math">\(w\)</span>, is available as the function <code class="docutils literal"><span class="pre">solver_adjust_w</span></code>. A
call to <code class="docutils literal"><span class="pre">convergence_rates</span></code> with this solver reveals that the rate is
4.0! With the original, physical <span class="math">\(\omega\)</span> the rate is 2.0  - as expected
from using second-order finite difference approximations,
as expected from the forthcoming derivation of the global error,
and as expected from truncation error analysis
analysis as explained in  <a class="reference internal" href="._book023.html#trunc-vib-undamped"><span class="std std-ref">Linear model without damping</span></a>.</p>
<p>Adjusting <span class="math">\(\omega\)</span> is an ideal trick for this simple problem, but when
adding damping and nonlinear terms, we have no simple formula for the
impact on <span class="math">\(\omega\)</span>, and therefore we cannot use the trick.</p>
</div>
<div class="section" id="exact-discrete-solution">
<span id="vib-ode1-analysis-sol"></span><h3>Exact discrete solution<a class="headerlink" href="#exact-discrete-solution" title="Permalink to this headline">¶</a></h3>
<p>Perhaps more important than the <span class="math">\(\tilde\omega = \omega + {\cal O}(\Delta t^2)\)</span>
result found above is the fact that we have an exact discrete solution of
the problem:</p>
<div class="math" id="eq-vib-ode1-un-exact">
\[\tag{20}
u^n = I\cos\left(\tilde\omega n\Delta t\right),\quad
    \tilde\omega = \frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
    {\thinspace .}\]</div>
<p>We can then compute the error mesh function</p>
<div class="math" id="eq-vib-ode1-en">
\[\tag{21}
e^n = {u_{\small\mbox{e}}}(t_n) - u^n =
    I\cos\left(\omega n\Delta t\right) - I\cos\left(\tilde\omega n\Delta t\right){\thinspace .}\]</div>
<p>From the formula <span class="math">\(\cos 2x - \cos 2y = -2\sin(x-y)\sin(x+y)\)</span> we can
rewrite <span class="math">\(e^n\)</span> so the expression is easier to interpret:</p>
<div class="math" id="eq-vib-ode1-en2">
\[\tag{22}
e^n = -2I\sin\left(t\frac{1}{2}\left( \omega - \tilde\omega\right)\right)
    \sin\left(t\frac{1}{2}\left( \omega + \tilde\omega\right)\right){\thinspace .}\]</div>
<p>The error mesh function is ideal for verification purposes and you are
strongly encouraged to make a test based on <a class="reference internal" href="#eq-vib-ode1-un-exact"><span class="std std-ref">(20)</span></a>
by doing <a class="reference internal" href="#vib-exer-discrete-omega"><span class="std std-ref">Exercise 1.11: Use an exact discrete solution for verification</span></a>.</p>
</div>
<div class="section" id="convergence">
<span id="vib-ode1-analysis-conv"></span><h3>Convergence<a class="headerlink" href="#convergence" title="Permalink to this headline">¶</a></h3>
<p>We can use <a class="reference internal" href="#eq-vib-ode1-tildeomega-series"><span class="std std-ref">(19)</span></a>, <a class="reference internal" href="#eq-vib-ode1-en"><span class="std std-ref">(21)</span></a>, or
<a class="reference internal" href="#eq-vib-ode1-en2"><span class="std std-ref">(22)</span></a> to show <em>convergence</em> of the numerical scheme,
i.e., <span class="math">\(e^n\rightarrow 0\)</span> as <span class="math">\(\Delta t\rightarrow 0\)</span>, which implies
that the numerical solution approaches the exact solution as <span class="math">\(\Delta
t\)</span> approaches to zero.  We have that</p>
<div class="math">
\[\lim_{\Delta t\rightarrow 0}
\tilde\omega = \lim_{\Delta t\rightarrow 0}
\frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
= \omega,\]</div>
<p>by L&#8217;Hopital&#8217;s rule. This result could also been computed <a class="reference external" href="http://www.wolframalpha.com/input/?i=%282%2Fx%29*asin%28w*x%2F2%29+as+x-%3E0">WolframAlpha</a>, or
we could use the limit functionality in <code class="docutils literal"><span class="pre">sympy</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x w&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sym</span><span class="o">.</span><span class="n">limit</span><span class="p">((</span><span class="mi">2</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">asin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>
<span class="go">w</span>
</pre></div>
</div>
<p>Also <a class="reference internal" href="#eq-vib-ode1-tildeomega-series"><span class="std std-ref">(19)</span></a> can be used to establish
that <span class="math">\(\tilde\omega\rightarrow\omega\)</span> when <span class="math">\(\Delta t\rightarrow 0\)</span>.
It then follows from the expression(s) for <span class="math">\(e^n\)</span> that <span class="math">\(e^n\rightarrow 0\)</span>.</p>
</div>
<div class="section" id="the-global-error">
<h3>The global error<a class="headerlink" href="#the-global-error" title="Permalink to this headline">¶</a></h3>
<p id="index-29">To achieve more analytical insight into the nature of the global
error, we can Taylor expand the error mesh function
<a class="reference internal" href="#eq-vib-ode1-en"><span class="std std-ref">(21)</span></a>.  Since <span class="math">\(\tilde\omega\)</span> in
<a class="reference internal" href="#eq-vib-ode1-tildeomega"><span class="std std-ref">(18)</span></a> contains <span class="math">\(\Delta t\)</span> in the denominator we
use the series expansion for <span class="math">\(\tilde\omega\)</span> inside the cosine
function. A relevant <code class="docutils literal"><span class="pre">sympy</span></code> session is</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;dt w t&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w_tilde_e</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="n">dt</span><span class="o">*</span><span class="n">asin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w_tilde_series</span> <span class="o">=</span> <span class="n">w_tilde_e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w_tilde_series</span>
<span class="go">w + dt**2*w**3/24 + O(dt**4)</span>
</pre></div>
</div>
<p>Series expansions in <code class="docutils literal"><span class="pre">sympy</span></code> have the inconvenient <code class="docutils literal"><span class="pre">O()</span></code> term that
prevents further calculations with the series. We can use the
<code class="docutils literal"><span class="pre">removeO()</span></code> command to get rid of the <code class="docutils literal"><span class="pre">O()</span></code> term:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w_tilde_series</span> <span class="o">=</span> <span class="n">w_tilde_series</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w_tilde_series</span>
<span class="go">dt**2*w**3/24 + w</span>
</pre></div>
</div>
<p>Using this <code class="docutils literal"><span class="pre">w_tilde_series</span></code> expression for <span class="math">\(\tilde w\)</span> in
<a class="reference internal" href="#eq-vib-ode1-en"><span class="std std-ref">(21)</span></a>, dropping <span class="math">\(I\)</span> (which is a common factor), and
performing a series expansion of the error yields</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">error</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">w_tilde_series</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">error</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">dt**2*t*w**3*sin(t*w)/24 + dt**4*t**2*w**6*cos(t*w)/1152 + O(dt**6)</span>
</pre></div>
</div>
<p>Since we are mainly interested in the leading-order term in
such expansions (the term with lowest power in <span class="math">\(\Delta t\)</span>, which
goes most slowly to zero), we use the <code class="docutils literal"><span class="pre">.as_leading_term(dt)</span></code>
construction to pick out this term:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">error</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">as_leading_term</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
<span class="go">dt**2*t*w**3*sin(t*w)/24</span>
</pre></div>
</div>
<p>The last result
means that the leading order global (true) error at a point <span class="math">\(t\)</span>
is proportional to <span class="math">\(\omega^3t\Delta t^2\)</span>. Considering only the
discrete <span class="math">\(t_n\)</span> values for <span class="math">\(t\)</span>, <span class="math">\(t_n\)</span> is related
to <span class="math">\(\Delta t\)</span> through <span class="math">\(t_n=n\Delta t\)</span>. The factor
<span class="math">\(\sin(\omega t)\)</span> can at most be 1, so we use this value to
bound the leading-order expression to its maximum value</p>
<div class="math">
\[e^n = \frac{1}{24}n\omega^3\Delta t^3{\thinspace .}\]</div>
<p>This is the dominating term of the error <em>at a point</em>.</p>
<p>We are interested in the accumulated global error, which can be taken
as the <span class="math">\(\ell^2\)</span> norm of <span class="math">\(e^n\)</span>.  The norm is simply computed by summing
contributions from all mesh points:</p>
<div class="math">
\[||e^n||_{\ell^2}^2 = \Delta t\sum_{n=0}^{N_t} \frac{1}{24^2}n^2\omega^6\Delta t^6
=\frac{1}{24^2}\omega^6\Delta t^7 \sum_{n=0}^{N_t} n^2{\thinspace .}\]</div>
<p>The sum <span class="math">\(\sum_{n=0}^{N_t} n^2\)</span> is approximately equal to
<span class="math">\(\frac{1}{3}N_t^3\)</span>. Replacing <span class="math">\(N_t\)</span> by <span class="math">\(T/\Delta t\)</span> and taking
the square root gives the expression</p>
<div class="math">
\[||e^n||_{\ell^2} = \frac{1}{24}\sqrt{\frac{T^3}{3}}\omega^3\Delta t^2{\thinspace .}\]</div>
<p>This is our expression for the global (or integrated) error.
A primary result from this expression is that the global error
is proportional to <span class="math">\(\Delta t^2\)</span>.</p>
</div>
<div class="section" id="stability-1">
<h3>Stability<a class="headerlink" href="#stability-1" title="Permalink to this headline">¶</a></h3>
<p>Looking at <a class="reference internal" href="#eq-vib-ode1-un-exact"><span class="std std-ref">(20)</span></a>, it appears that the numerical
solution has constant and correct amplitude, but an error in the
angular frequency. A constant amplitude is not necessarily the case,
however! To see this, note that if only <span class="math">\(\Delta t\)</span> is large enough,
the magnitude of the argument to <span class="math">\(\sin^{-1}\)</span> in
<a class="reference internal" href="#eq-vib-ode1-tildeomega"><span class="std std-ref">(18)</span></a> may be larger than 1, i.e., <span class="math">\(\omega\Delta
t/2 &gt; 1\)</span>. In this case, <span class="math">\(\sin^{-1}(\omega\Delta t/2)\)</span> has a complex
value and therefore <span class="math">\(\tilde\omega\)</span> becomes complex.  Type, for
example, <code class="docutils literal"><span class="pre">asin(x)</span></code> in <a class="reference external" href="http://www.wolframalpha.com">wolframalpha.com</a> to see basic properties of <span class="math">\(\sin^{-1}
(x)\)</span>).</p>
<p>A complex <span class="math">\(\tilde\omega\)</span> can be written <span class="math">\(\tilde\omega = \tilde\omega_r
+ i\tilde\omega_i\)</span>. Since <span class="math">\(\sin^{-1}(x)\)</span> has a <em>negative</em> imaginary
part for <span class="math">\(x&gt;1\)</span>, <span class="math">\(\tilde\omega_i &lt; 0\)</span>, which means that
<span class="math">\(e^{i\tilde\omega t}=e^{-\tilde\omega_i t}e^{i\tilde\omega_r t}\)</span> will
lead to exponential growth in time because <span class="math">\(e^{-\tilde\omega_i t}\)</span>
with <span class="math">\(\tilde\omega_i &lt;0\)</span> has a positive exponent.</p>
<div class="admonition-stability-criterion admonition" id="index-30">
<p class="first admonition-title">Stability criterion</p>
<p class="last">We do not tolerate growth in the amplitude since such growth is not
present in the exact solution. Therefore, we
must impose a <em>stability criterion</em> so that
the argument in the inverse sine function leads
to real and not complex values of <span class="math">\(\tilde\omega\)</span>. The stability
criterion reads</p>
</div>
<div class="math" id="eq-auto8">
\[\tag{23}
\frac{\omega\Delta t}{2} \leq 1\quad\Rightarrow\quad
       \Delta t \leq \frac{2}{\omega}
       {\thinspace .}\]</div>
<p>With <span class="math">\(\omega =2\pi\)</span>, <span class="math">\(\Delta t &gt; \pi^{-1} = 0.3183098861837907\)</span> will give
growing solutions. Figure <a class="reference internal" href="#vib-ode1-dt-unstable"><span class="std std-ref">Growing, unstable solution because of a time step slightly beyond the stability limit</span></a>
displays what happens when <span class="math">\(\Delta t =0.3184\)</span>,
which is slightly above the critical value: <span class="math">\(\Delta t =\pi^{-1} + 9.01\cdot
10^{-5}\)</span>.</p>
<div class="figure" id="id15">
<span id="vib-ode1-dt-unstable"></span><a class="reference internal image-reference" href="_images/vib_unstable.png"><img alt="_images/vib_unstable.png" src="_images/vib_unstable.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>Growing, unstable solution because of a time step slightly beyond the stability limit</em></span></p>
</div>
</div>
<div class="section" id="about-the-accuracy-at-the-stability-limit">
<h3>About the accuracy at the stability limit<a class="headerlink" href="#about-the-accuracy-at-the-stability-limit" title="Permalink to this headline">¶</a></h3>
<p>An interesting question is whether the stability condition <span class="math">\(\Delta t &lt;
2/\omega\)</span> is unfortunate, or more precisely: would it be meaningful to
take larger time steps to speed up computations?  The answer is a
clear no. At the stability limit, we have that <span class="math">\(\sin^{-1}\omega\Delta
t/2 = \sin^{-1} 1 = \pi/2\)</span>, and therefore <span class="math">\(\tilde\omega = \pi/\Delta
t\)</span>. (Note that the approximate formula
<a class="reference internal" href="#eq-vib-ode1-tildeomega-series"><span class="std std-ref">(19)</span></a> is very inaccurate for this value of
<span class="math">\(\Delta t\)</span> as it predicts <span class="math">\(\tilde\omega = 2.34/pi\)</span>, which is a 25
percent reduction.) The corresponding period of the numerical solution
is <span class="math">\(\tilde P=2\pi/\tilde\omega = 2\Delta t\)</span>, which means that there is
just one time step <span class="math">\(\Delta t\)</span> between a peak (maximum) and a
<a class="reference external" href="https://simple.wikipedia.org/wiki/Wave_(physics)">through</a>
(minimum) in the numerical solution. This is the shortest possible
wave that can be represented in the mesh! In other words, it is not
meaningful to use a larger time step than the stability limit.</p>
<p>Also, the error in angular frequency when <span class="math">\(\Delta t = 2/\omega\)</span> is
severe: Figure <a class="reference internal" href="#vib-ode1-dt-stablimit"><span class="std std-ref">Numerical solution with  \( Delta t \)  exactly at the stability limit</span></a> shows a comparison of the
numerical and analytical solution with <span class="math">\(\omega = 2\pi\)</span> and <span class="math">\(\Delta t =
2/\omega = \pi^{-1}\)</span>. Already after one period, the numerical solution
has a through while the exact solution has a peak (!).  The error in
frequency when <span class="math">\(\Delta t\)</span> is at the stability limit becomes <span class="math">\(\omega -
\tilde\omega = \omega(1-\pi/2)\approx -0.57\omega\)</span>.  The corresponding
error in the period is <span class="math">\(P - \tilde P \approx 0.36P\)</span>.  The error after
<span class="math">\(m\)</span> periods is then <span class="math">\(0.36mP\)</span>. This error has reached half a period
when <span class="math">\(m=1/(2\cdot 0.36)\approx 1.38\)</span>, which theoretically confirms the
observations in Figure <a class="reference internal" href="#vib-ode1-dt-stablimit"><span class="std std-ref">Numerical solution with  \( Delta t \)  exactly at the stability limit</span></a> that the numerical
solution is a through ahead of a peak already after one and a half
period. Consequently, <span class="math">\(\Delta t\)</span> should be chosen much less than the
stability limit to achieve meaningful numerical computations.</p>
<div class="figure" id="id16">
<span id="vib-ode1-dt-stablimit"></span><a class="reference internal image-reference" href="_images/vib_stability_limit.png"><img alt="_images/vib_stability_limit.png" src="_images/vib_stability_limit.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>Numerical solution with  \( Delta t \)  exactly at the stability limit</em></span></p>
</div>
<div class="admonition-summary admonition">
<p class="first admonition-title">Summary</p>
<p>From the accuracy and stability
analysis we can draw three important conclusions:</p>
<ol class="last arabic simple">
<li>The key parameter in the formulas is <span class="math">\(p=\omega\Delta t\)</span>.
The period of oscillations is <span class="math">\(P=2\pi/\omega\)</span>, and the
number of time steps per period is <span class="math">\(N_P=P/\Delta t\)</span>.
Therefore, <span class="math">\(p=\omega\Delta t = 2\pi/N_P\)</span>, showing that the
critical parameter is the number of time steps per period.
The smallest possible <span class="math">\(N_P\)</span> is 2, showing that <span class="math">\(p\in (0,\pi]\)</span>.</li>
<li>Provided <span class="math">\(p\leq 2\)</span>, the amplitude of the numerical solution is
constant.</li>
<li>The ratio of the numerical angular frequency and the exact
one is
<span class="math">\(\tilde\omega/\omega \approx 1 + \frac{1}{24}p^2\)</span>.
The error <span class="math">\(\frac{1}{24}p^2\)</span> leads to wrongly displaced peaks of the numerical
solution, and the error in peak location grows linearly with time
(see <a class="reference internal" href="#vib-exer-phase-err-growth"><span class="std std-ref">Exercise 1.2: Show linear growth of the phase with time</span></a>).</li>
</ol>
</div>
</div>
</div>
<div class="section" id="alternative-schemes-based-on-1st-order-equations">
<span id="vib-model2x2"></span><h2>Alternative schemes based on 1st-order equations<a class="headerlink" href="#alternative-schemes-based-on-1st-order-equations" title="Permalink to this headline">¶</a></h2>
<p>A standard technique for solving second-order ODEs is to rewrite them
as a system of first-order ODEs and then choose a solution strategy
from the vast collection of methods for first-order ODE systems.
Given the second-order ODE problem</p>
<div class="math">
\[u^{\prime\prime} + \omega^2 u = 0,\quad u(0)=I,\ u^{\prime}(0)=0,\]</div>
<p>we introduce the auxiliary variable <span class="math">\(v=u^{\prime}\)</span> and express the ODE problem
in terms of first-order derivatives of <span class="math">\(u\)</span> and <span class="math">\(v\)</span>:</p>
<div class="math" id="eq-vib-model2x2-ueq">
\[\tag{24}
u^{\prime} = v,\]</div>
<div class="math" id="eq-vib-model2x2-veq">
\[ \begin{align}\begin{aligned}\tag{25}
v^{\prime} = -\omega^2 u\\    {\thinspace .}\end{aligned}\end{align} \]</div>
<p>The initial conditions become <span class="math">\(u(0)=I\)</span> and <span class="math">\(v(0)=0\)</span>.</p>
<div class="section" id="the-forward-euler-scheme-1">
<h3>The Forward Euler scheme<a class="headerlink" href="#the-forward-euler-scheme-1" title="Permalink to this headline">¶</a></h3>
<p>A Forward Euler approximation to our <span class="math">\(2\times 2\)</span> system of ODEs
<a class="reference internal" href="#eq-vib-model2x2-ueq"><span class="std std-ref">(24)</span></a>-<a class="reference internal" href="#eq-vib-model2x2-veq"><span class="std std-ref">(25)</span></a> becomes</p>
<div class="math" id="eq-auto9">
\[\tag{26}
\lbrack D_t^+ u = v\rbrack^n,\]</div>
<div class="math" id="eq-auto10">
\[\tag{27}
\lbrack D_t^+ v = -\omega^2 u\rbrack^n,\]</div>
<p>or written out,</p>
<div class="math" id="eq-vib-undamped-fe1">
\[\tag{28}
u^{n+1} = u^n + \Delta t v^n,\]</div>
<div class="math" id="eq-vib-undamped-fe2">
\[ \begin{align}\begin{aligned}\tag{29}
v^{n+1} = v^n -\Delta t \omega^2 u^n\\    {\thinspace .}\end{aligned}\end{align} \]</div>
<p>Let us briefly compare this Forward Euler method with the centered
difference scheme for the second-order differential equation. We have
from <a class="reference internal" href="#eq-vib-undamped-fe1"><span class="std std-ref">(28)</span></a> and <a class="reference internal" href="#eq-vib-undamped-fe2"><span class="std std-ref">(29)</span></a> applied at
levels <span class="math">\(n\)</span> and <span class="math">\(n-1\)</span> that</p>
<div class="math">
\[u^{n+1} = u^n + \Delta t v^n = u^n + \Delta t (v^{n-1} -\Delta t \omega^2 u^{n-1}){\thinspace .}\]</div>
<p>Since from <a class="reference internal" href="#eq-vib-undamped-fe1"><span class="std std-ref">(28)</span></a></p>
<div class="math">
\[v^{n-1} = \frac{1}{\Delta t}(u^{n}-u^{n-1}),\]</div>
<p>it follows that</p>
<div class="math">
\[u^{n+1} = 2u^n - u^{n-1} -\Delta t^2\omega^2 u^{n-1},\]</div>
<p>which is very close to the centered difference scheme, but the last
term is evaluated at <span class="math">\(t_{n-1}\)</span> instead of <span class="math">\(t_n\)</span>.  Rewriting, so that
<span class="math">\(\Delta t^2\omega^2u^{n-1}\)</span> appears alone on the right-hand side, and
then dividing by <span class="math">\(\Delta t^2\)</span>, the new left-hand side is an
approximation to <span class="math">\(u^{\prime\prime}\)</span> at <span class="math">\(t_n\)</span>, while the right-hand
side is sampled at <span class="math">\(t_{n-1}\)</span>.  All terms should be sampled at the same
mesh point, so using <span class="math">\(\omega^2 u^{n-1}\)</span> instead of <span class="math">\(\omega^2 u^n\)</span>
points to a kind of mathematical error in the derivation of the
scheme. This error turns out to be rather crucial for the accuracy of
the Forward Euler method applied to vibration problems (the section <a class="reference internal" href="#vib-model2x2-compare"><span class="std std-ref">Comparison of schemes</span></a> has examples).</p>
<p>The reasoning above does not imply that the Forward Euler scheme is not
correct, but more that it is almost equivalent to a second-order accurate
scheme for the second-order ODE formulation, and that the error
committed has to do with a wrong sampling point.</p>
</div>
<div class="section" id="the-backward-euler-scheme-1">
<h3>The Backward Euler scheme<a class="headerlink" href="#the-backward-euler-scheme-1" title="Permalink to this headline">¶</a></h3>
<p>A Backward Euler approximation to the ODE system is equally easy to
write up in the operator notation:</p>
<div class="math" id="eq-auto11">
\[\tag{30}
\lbrack D_t^- u = v\rbrack^{n+1},\]</div>
<div class="math" id="eq-auto12">
\[\tag{31}
\lbrack D_t^- v = -\omega u\rbrack^{n+1} {\thinspace .}\]</div>
<p>This becomes a coupled system for <span class="math">\(u^{n+1}\)</span> and <span class="math">\(v^{n+1}\)</span>:</p>
<div class="math" id="eq-vib-undamped-be1">
\[\tag{32}
u^{n+1} - \Delta t v^{n+1} = u^{n},\]</div>
<div class="math" id="eq-vib-undamped-be2">
\[ \begin{align}\begin{aligned}\tag{33}
v^{n+1} + \Delta t \omega^2 u^{n+1} = v^{n}\\    {\thinspace .}\end{aligned}\end{align} \]</div>
<p>We can compare <a class="reference internal" href="#eq-vib-undamped-be1"><span class="std std-ref">(32)</span></a>-<a class="reference internal" href="#eq-vib-undamped-be2"><span class="std std-ref">(33)</span></a> with
the centered scheme <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a> for the second-order
differential equation.  To this end, we eliminate <span class="math">\(v^{n+1}\)</span> in
<a class="reference internal" href="#eq-vib-undamped-be1"><span class="std std-ref">(32)</span></a> using <a class="reference internal" href="#eq-vib-undamped-be2"><span class="std std-ref">(33)</span></a> solved with
respect to <span class="math">\(v^{n+1}\)</span>.  Thereafter, we eliminate <span class="math">\(v^n\)</span> using
<a class="reference internal" href="#eq-vib-undamped-be1"><span class="std std-ref">(32)</span></a> solved with respect to <span class="math">\(v^{n+1}\)</span> and also
replacing <span class="math">\(n+1\)</span> by <span class="math">\(n\)</span> and <span class="math">\(n\)</span> by <span class="math">\(n-1\)</span>.  The resulting equation
involving only <span class="math">\(u^{n+1}\)</span>, <span class="math">\(u^n\)</span>, and <span class="math">\(u^{n-1}\)</span> can be ordered as</p>
<div class="math">
\[\frac{u^{n+1}-2u^n+u^{n-1}}{\Delta t^2} = -\omega^2 u^{n+1},\]</div>
<p>which has almost the same form as the centered scheme for the
second-order differential equation, but the right-hand side is
evaluated at <span class="math">\(u^{n+1}\)</span> and not <span class="math">\(u^n\)</span>. This inconsistent sampling
of terms has a dramatic effect on the numerical solution, as we
demonstrate in the section <a class="reference internal" href="#vib-model2x2-compare"><span class="std std-ref">Comparison of schemes</span></a>.</p>
</div>
<div class="section" id="the-crank-nicolson-scheme-1">
<span id="vib-undamped-cn"></span><h3>The Crank-Nicolson scheme<a class="headerlink" href="#the-crank-nicolson-scheme-1" title="Permalink to this headline">¶</a></h3>
<p>The Crank-Nicolson scheme takes this form in the operator notation:</p>
<div class="math" id="eq-auto13">
\[\tag{34}
\lbrack D_t u = \overline{v}^t\rbrack^{n+\frac{1}{2}},\]</div>
<div class="math" id="eq-auto14">
\[\tag{35}
\lbrack D_t v = -\omega^2 \overline{u}^t\rbrack^{n+\frac{1}{2}}
    {\thinspace .}\]</div>
<p>Writing the equations out and rearranging terms,
shows that this is also a coupled system of two linear equations
at each time level:</p>
<div class="math" id="eq-auto15">
\[\tag{36}
u^{n+1} - \frac{1}{2}\Delta t v^{n+1} = u^{n} + \frac{1}{2}\Delta t v^{n},\]</div>
<div class="math" id="eq-auto16">
\[\tag{37}
v^{n+1} + \frac{1}{2}\Delta t \omega^2 u^{n+1} = v^{n}
    - \frac{1}{2}\Delta t \omega^2 u^{n}
    {\thinspace .}\]</div>
<p>We may compare also this scheme to the centered discretization of
the second-order ODE. It turns out that the Crank-Nicolson scheme is
equivalent to the discretization</p>
<div class="math" id="eq-vib-undamped-cn-equiv-utt">
\[\tag{38}
\frac{u^{n+1} - 2u^n + u^{n-1}}{\Delta t^2} = - \omega^2
    \frac{1}{4}(u^{n+1} + 2u^n + u^{n-1}) = -\omega^2 u^{n} +
    {\mathcal{O}(\Delta t^2)}{\thinspace .}\]</div>
<p>That is, the Crank-Nicolson is equivalent to <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a>
for the second-order ODE, apart from an extra term of size
<span class="math">\(\Delta t^2\)</span>, but this is an error of the same order as in
the finite difference approximation on the left-hand side of the
equation anyway. The fact that the Crank-Nicolson scheme is so
close to <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a> makes it a much better method than
the Forward or Backward Euler methods for vibration problems,
as will be illustrated in the section <a class="reference internal" href="#vib-model2x2-compare"><span class="std std-ref">Comparison of schemes</span></a>.</p>
<p>Deriving <a class="reference internal" href="#eq-vib-undamped-cn-equiv-utt"><span class="std std-ref">(38)</span></a> is a bit tricky.
We start with rewriting the Crank-Nicolson equations as follows</p>
<div class="math" id="eq-vib-undamped-cn3a">
\[\tag{39}
u^{n+1} - u^n = \frac{1}{2}\Delta t(v^{n+1} + v^n),\]</div>
<div class="math" id="eq-vib-undamped-cn4a">
\[\tag{40}
v^{n+1}  = v^n -\frac{1}{2}\Delta t\omega^2 (u^{n+1} + u^n),\]</div>
<p>and add the latter at the previous time level as well:</p>
<div class="math" id="eq-vib-undamped-cn4b1">
\[\tag{41}
v^{n}  = v^{n-1} -\frac{1}{2}\Delta t\omega^2(u^{n} + u^{n-1})\]</div>
<p>We can also rewrite <a class="reference internal" href="#eq-vib-undamped-cn3a"><span class="std std-ref">(39)</span></a> at the previous time level
as</p>
<div class="math" id="eq-vib-undamped-cn4b">
\[\tag{42}
v^{n} + v^{n-1} = \frac{2}{\Delta t}(u^{n} - u^{n-1}){\thinspace .}\]</div>
<p>Inserting <a class="reference internal" href="#eq-vib-undamped-cn4a"><span class="std std-ref">(40)</span></a> for <span class="math">\(v^{n+1}\)</span> in
<a class="reference internal" href="#eq-vib-undamped-cn3a"><span class="std std-ref">(39)</span></a> and
<a class="reference internal" href="#eq-vib-undamped-cn4b1"><span class="std std-ref">(41)</span></a> for <span class="math">\(v^{n}\)</span> in
<a class="reference internal" href="#eq-vib-undamped-cn3a"><span class="std std-ref">(39)</span></a> yields after some reordering:</p>
<div class="math">
\[u^{n+1} - u^n = \frac{1}{2}(-\frac{1}{2}\Delta t\omega^2
(u^{n+1} + 2u^n + u^{n-1}) + v^n + v^{n-1}){\thinspace .}\]</div>
<p>Now, <span class="math">\(v^n + v^{n-1}\)</span> can be eliminated by means of
<a class="reference internal" href="#eq-vib-undamped-cn4b"><span class="std std-ref">(42)</span></a>. The result becomes</p>
<div class="math" id="eq-vib-undamped-cn5">
\[\tag{43}
u^{n+1} - 2u^n + u^{n-1} = -\Delta t^2\omega^2
    \frac{1}{4}(u^{n+1} + 2u^n + u^{n-1}){\thinspace .}\]</div>
<p>It can be shown that</p>
<div class="math">
\[\frac{1}{4}(u^{n+1} + 2u^n + u^{n-1}) \approx u^n + {\mathcal{O}(\Delta t^2)},\]</div>
<p>meaning that <a class="reference internal" href="#eq-vib-undamped-cn5"><span class="std std-ref">(43)</span></a> is an approximation to
the centered scheme <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a> for the second-order ODE where
the sampling error in the term <span class="math">\(\Delta t^2\omega^2 u^n\)</span> is of the same
order as the approximation errors in the finite differences, i.e.,
<span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>. The Crank-Nicolson scheme written as
<a class="reference internal" href="#eq-vib-undamped-cn5"><span class="std std-ref">(43)</span></a> therefore has consistent sampling of all
terms at the same time point <span class="math">\(t_n\)</span>.</p>
</div>
<div class="section" id="comparison-of-schemes">
<span id="vib-model2x2-compare"></span><h3>Comparison of schemes<a class="headerlink" href="#comparison-of-schemes" title="Permalink to this headline">¶</a></h3>
<p>We can easily compare methods like the ones above (and many more!)
with the aid of the
<a class="reference external" href="https://github.com/hplgit/odespy">Odespy</a> package. Below is
a sketch of the code.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">odespy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># v, u numbering for EulerCromer to work well</span>
    <span class="n">v</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">u</span>  <span class="c1"># u is array of length 2 holding our [v, u]</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">-</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">run_solvers_and_plot</span><span class="p">(</span><span class="n">solvers</span><span class="p">,</span> <span class="n">timesteps_per_period</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                         <span class="n">num_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">):</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>  <span class="c1"># duration of one period</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">P</span><span class="o">/</span><span class="n">timesteps_per_period</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="n">num_periods</span><span class="o">*</span><span class="n">timesteps_per_period</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span>
    <span class="n">t_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">legends</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">solver</span> <span class="ow">in</span> <span class="n">solvers</span><span class="p">:</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">f_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="n">w</span><span class="p">})</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">I</span><span class="p">])</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">t_mesh</span><span class="p">)</span>
</pre></div>
</div>
<p>There is quite some more code dealing with plots also, and we refer
to the source file <a class="reference external" href="http://tinyurl.com/nu656p2/vib/vib_undamped_odespy.py">vib_undamped_odespy.py</a>
for details. Observe that keyword arguments in <code class="docutils literal"><span class="pre">f(u,t,w=1)</span></code> can
be supplied through a solver parameter <code class="docutils literal"><span class="pre">f_kwargs</span></code> (dictionary of
additional keyword arguments to <code class="docutils literal"><span class="pre">f</span></code>).</p>
<p>Specification of the Forward Euler, Backward Euler, and
Crank-Nicolson schemes is done like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">solvers</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">odespy</span><span class="o">.</span><span class="n">ForwardEuler</span><span class="p">(</span><span class="n">f</span><span class="p">),</span>
    <span class="c1"># Implicit methods must use Newton solver to converge</span>
    <span class="n">odespy</span><span class="o">.</span><span class="n">BackwardEuler</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nonlinear_solver</span><span class="o">=</span><span class="s1">&#39;Newton&#39;</span><span class="p">),</span>
    <span class="n">odespy</span><span class="o">.</span><span class="n">CrankNicolson</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nonlinear_solver</span><span class="o">=</span><span class="s1">&#39;Newton&#39;</span><span class="p">),</span>
    <span class="p">]</span>
</pre></div>
</div>
<p id="index-31">The <code class="docutils literal"><span class="pre">vib_undamped_odespy.py</span></code> program makes two plots of the computed
solutions with the various methods in the <code class="docutils literal"><span class="pre">solvers</span></code> list: one plot
with <span class="math">\(u(t)\)</span> versus <span class="math">\(t\)</span>, and one <em>phase plane plot</em> where <span class="math">\(v\)</span> is
plotted against <span class="math">\(u\)</span>.  That is, the phase plane plot is the curve
<span class="math">\((u(t),v(t))\)</span> parameterized by <span class="math">\(t\)</span>. Analytically, <span class="math">\(u=I\cos(\omega t)\)</span>
and <span class="math">\(v=u^{\prime}=-\omega I\sin(\omega t)\)</span>.  The exact curve
<span class="math">\((u(t),v(t))\)</span> is therefore an ellipse, which often looks like a circle
in a plot if the axes are automatically scaled. The important feature,
however, is that the exact curve <span class="math">\((u(t),v(t))\)</span> is closed and repeats
itself for every period. Not all numerical schemes are capable of
doing that, meaning that the amplitude instead shrinks or grows with
time.</p>
<p>Figure <a class="reference internal" href="#vib-ode1-1st-odespy-theta-phaseplane"><span class="std std-ref">Comparison of classical schemes in the phase plane for two time step values</span></a> show the
results. Note that Odespy applies the label MidpointImplicit for what
we have specified as <code class="docutils literal"><span class="pre">CrankNicolson</span></code> in the code (<code class="docutils literal"><span class="pre">CrankNicolson</span></code> is
just a synonym for class <code class="docutils literal"><span class="pre">MidpointImplicit</span></code> in the Odespy code).  The
Forward Euler scheme in Figure
<a class="reference internal" href="#vib-ode1-1st-odespy-theta-phaseplane"><span class="std std-ref">Comparison of classical schemes in the phase plane for two time step values</span></a> has a pronounced spiral
curve, pointing to the fact that the amplitude steadily grows, which
is also evident in Figure <a class="reference internal" href="#vib-ode1-1st-odespy-theta"><span class="std std-ref">Comparison of solution curves for classical schemes</span></a>.  The
Backward Euler scheme has a similar feature, except that the spriral
goes inward and the amplitude is significantly damped.  The changing
amplitude and the spiral form decreases with decreasing time step.
The Crank-Nicolson scheme looks much more accurate.  In fact, these
plots tell that the Forward and Backward Euler schemes are not
suitable for solving our ODEs with oscillating solutions.</p>
<div class="figure" id="id17">
<span id="vib-ode1-1st-odespy-theta-phaseplane"></span><a class="reference internal image-reference" href="_images/vib_theta_1_pp.png"><img alt="_images/vib_theta_1_pp.png" src="_images/vib_theta_1_pp.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Comparison of classical schemes in the phase plane for two time step values</em></span></p>
</div>
<div class="figure" id="id18">
<span id="vib-ode1-1st-odespy-theta"></span><a class="reference internal image-reference" href="_images/vib_theta_1_u.png"><img alt="_images/vib_theta_1_u.png" src="_images/vib_theta_1_u.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Comparison of solution curves for classical schemes</em></span></p>
</div>
</div>
<div class="section" id="runge-kutta-methods">
<h3>Runge-Kutta methods<a class="headerlink" href="#runge-kutta-methods" title="Permalink to this headline">¶</a></h3>
<p>We may run two other popular standard methods for first-order ODEs,
the 2nd- and 4th-order Runge-Kutta methods, to see how they
perform. Figures <a class="reference internal" href="#vib-ode1-1st-odespy-rk-phaseplane"><span class="std std-ref">Comparison of Runge-Kutta schemes in the phase plane</span></a> and
<a class="reference internal" href="#vib-ode1-1st-odespy-rk"><span class="std std-ref">Comparison of Runge-Kutta schemes</span></a> show the solutions with larger <span class="math">\(\Delta t\)</span>
values than what was used in the previous two plots.</p>
<div class="figure" id="id19">
<span id="vib-ode1-1st-odespy-rk-phaseplane"></span><a class="reference internal image-reference" href="_images/vib_RK_1_pp.png"><img alt="_images/vib_RK_1_pp.png" src="_images/vib_RK_1_pp.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Comparison of Runge-Kutta schemes in the phase plane</em></span></p>
</div>
<div class="figure" id="id20">
<span id="vib-ode1-1st-odespy-rk"></span><a class="reference internal image-reference" href="_images/vib_RK_1_u.png"><img alt="_images/vib_RK_1_u.png" src="_images/vib_RK_1_u.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Comparison of Runge-Kutta schemes</em></span></p>
</div>
<p>The visual impression is that the 4th-order Runge-Kutta method is very
accurate, under all circumstances in these tests, while the 2nd-order
scheme suffers from amplitude errors unless the time step is very
small.</p>
<p>The corresponding results for the Crank-Nicolson scheme are shown in
Figure <a class="reference internal" href="#vib-ode1-1st-odespy-cn-long-phaseplane"><span class="std std-ref">Long-time behavior of the Crank-Nicolson scheme in the phase plane</span></a>.  It is clear that
the Crank-Nicolson scheme outperforms the 2nd-order Runge-Kutta
method. Both schemes have the same order of accuracy <span class="math">\(\Oof{\Delta
t^2}\)</span>, but their differences in the accuracy that matters in a real
physical application is very clearly pronounced in this example.
<a class="reference internal" href="#vib-exer-undamped-odespy"><span class="std std-ref">Exercise 1.13: Investigate the amplitude errors of many solvers</span></a> invites you to investigate how
the amplitude is computed by a series of famous methods for
first-order ODEs.</p>
<div class="figure" id="id21">
<span id="vib-ode1-1st-odespy-cn-long-phaseplane"></span><a class="reference internal image-reference" href="_images/vib_CN_10_pp.png"><img alt="_images/vib_CN_10_pp.png" src="_images/vib_CN_10_pp.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Long-time behavior of the Crank-Nicolson scheme in the phase plane</em></span></p>
</div>
</div>
<div class="section" id="analysis-of-the-forward-euler-scheme-1">
<h3>Analysis of the Forward Euler scheme<a class="headerlink" href="#analysis-of-the-forward-euler-scheme-1" title="Permalink to this headline">¶</a></h3>
<p>We may try to find exact solutions of the discrete equations
<a class="reference internal" href="#eq-vib-undamped-fe1"><span class="std std-ref">(28)</span></a>-<a class="reference internal" href="#eq-vib-undamped-fe2"><span class="std std-ref">(29)</span></a> in the Forward Euler
method to better understand why this otherwise useful method has so
bad performance for vibration ODEs. An &#8220;ansatz&#8221; for the solution of
the discrete equations is</p>
<div class="math">
\[\begin{split}\begin{align*}
u^n &amp;= IA^n,\\
v^n &amp;= qIA^n,
\end{align*}\end{split}\]</div>
<p>where <span class="math">\(q\)</span> and <span class="math">\(A\)</span> are scalars to be determined. We could have used a complex
exponential form <span class="math">\(e^{i\tilde\omega n\Delta t}\)</span> since we get
oscillatory solutions, but the oscillations grow in the Forward Euler
method, so the numerical frequency <span class="math">\(\tilde\omega\)</span> will be complex
anyway (producing an exponentially growing amplitude). Therefore, it is
easier to just work with potentially complex <span class="math">\(A\)</span> and <span class="math">\(q\)</span> as introduced
above.</p>
<p>The Forward Euler scheme leads to</p>
<div class="math">
\[\begin{split}\begin{align*}
A &amp;= 1 + \Delta t q,\\
A &amp;= 1 - \Delta t\omega^2 q^{-1}{\thinspace .}
\end{align*}\end{split}\]</div>
<p>We can easily eliminate <span class="math">\(A\)</span>, get <span class="math">\(q^2 + \omega^2=0\)</span>, and solve for</p>
<div class="math">
\[q = \pm i\omega,\]</div>
<p>which gives</p>
<div class="math">
\[A = 1 \pm \Delta t i\omega{\thinspace .}\]</div>
<p>We shall take the real part of <span class="math">\(A^n\)</span> as the solution. The two values
of <span class="math">\(A\)</span> are complex conjugates, and the real part of <span class="math">\(A^n\)</span> will be the
same for both roots. This is easy to realize if we rewrite the complex
numbers in polar form, which is also convenient for further analysis
and understanding.  The polar form <span class="math">\(re^{i\theta}\)</span> of a complex number
<span class="math">\(x+iy\)</span> has <span class="math">\(r=\sqrt{x^2+y^2}\)</span> and <span class="math">\(\theta = \tan^{-1}(y/x)\)</span>.  Hence,
the polar form of the two values for <span class="math">\(A\)</span> becomes</p>
<div class="math">
\[1 \pm \Delta t i\omega = \sqrt{1+\omega^2\Delta t^2}e^{\pm i\tan^{-1}(\omega\Delta t)}{\thinspace .}\]</div>
<p>Now it is very easy to compute <span class="math">\(A^n\)</span>:</p>
<div class="math">
\[(1 \pm \Delta t i\omega)^n = (1+\omega^2\Delta t^2)^{n/2}e^{\pm ni\tan^{-1}(\omega\Delta t)}{\thinspace .}\]</div>
<p>Since <span class="math">\(\cos (\theta n) = \cos (-\theta n)\)</span>, the real parts of the two
numbers become the same. We therefore continue with the solution that has
the plus sign.</p>
<p>The general solution is <span class="math">\(u^n = CA^n\)</span>, where <span class="math">\(C\)</span> is a constant
determined from the initial condition: <span class="math">\(u^0=C=I\)</span>. We have <span class="math">\(u^n=IA^n\)</span>
and <span class="math">\(v^n=qIA^n\)</span>. The final solutions are just the real part of the
expressions in polar form:</p>
<div class="math" id="eq-auto17">
\[\tag{44}
u^n  =
    I(1+\omega^2\Delta t^2)^{n/2}\cos (n\tan^{-1}(\omega\Delta t)),\]</div>
<div class="math" id="eq-auto18">
\[\tag{45}
v^n =- \omega
    I(1+\omega^2\Delta t^2)^{n/2}\sin (n\tan^{-1}(\omega\Delta t)){\thinspace .}\]</div>
<p>The expression <span class="math">\((1+\omega^2\Delta t^2)^{n/2}\)</span> causes growth of
the amplitude, since a number greater than one is raised to a positive
exponent <span class="math">\(n/2\)</span>. We can develop a series expression to better understand
the formula for the amplitude. Introducing <span class="math">\(p=\omega\Delta t\)</span> as the
key variable and using <code class="docutils literal"><span class="pre">sympy</span></code> gives</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amplitude</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amplitude</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">1 + n*p**2/2 + O(p**4)</span>
</pre></div>
</div>
<p>The amplitude goes like <span class="math">\(1 + \frac{1}{2} n\omega^2\Delta t^2\)</span>, clearly growing
linearly in time (with <span class="math">\(n\)</span>).</p>
<p>We can also investigate the error in the angular frequency by a
series expansion:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">*</span><span class="n">atan</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">n*(p - p**3/3 + O(p**4))</span>
</pre></div>
</div>
<p>This means that the solution for <span class="math">\(u^n\)</span> can be written as</p>
<div class="math">
\[u^n = (1 + \frac{1}{2} n\omega^2\Delta t^2 + {\mathcal{O}(\Delta t^4)})
\cos\left(\omega t - \frac{1}{3}\omega t\Delta t^2 + {\mathcal{O}(\Delta t^4)}\right)
{\thinspace .}\]</div>
<p>The error in the angular frequency is of the same order as in the
scheme <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a> for the second-order ODE, but the error
in the amplitude is severe.</p>
</div>
</div>
<div class="section" id="energy-considerations">
<span id="vib-model1-energy"></span><h2>Energy considerations<a class="headerlink" href="#energy-considerations" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-32"></span><p id="index-33">The observations of various methods in the previous section can be
better interpreted if we compute a quantity reflecting
the total <em>energy of the system</em>. It turns out that this quantity,</p>
<div class="math">
\[E(t) = \frac{1}{2}(u^{\prime})^2 + \frac{1}{2}\omega^2u^2,\]</div>
<p>is <em>constant</em> for all <span class="math">\(t\)</span>. Checking that <span class="math">\(E(t)\)</span> really remains constant
brings evidence that the numerical computations are sound.
It turns out that <span class="math">\(E\)</span> is proportional to the mechanical energy
in the system. Conservation of energy is
much used to check numerical simulations, so it is well invested time to
dive into this subject.</p>
<div class="section" id="derivation-of-the-energy-expression">
<span id="vib-model1-energy-expr"></span><h3>Derivation of the energy expression<a class="headerlink" href="#derivation-of-the-energy-expression" title="Permalink to this headline">¶</a></h3>
<p>We start out with multiplying</p>
<div class="math">
\[u^{\prime\prime} + \omega^2 u = 0,\]</div>
<p>by <span class="math">\(u^{\prime}\)</span> and integrating from <span class="math">\(0\)</span> to <span class="math">\(T\)</span>:</p>
<div class="math">
\[\int_0^T u^{\prime\prime}u^{\prime} dt + \int_0^T\omega^2 u u^{\prime} dt = 0{\thinspace .}\]</div>
<p>Observing that</p>
<div class="math">
\[u^{\prime\prime}u^{\prime} = \frac{d}{dt}\frac{1}{2}(u^{\prime})^2,\quad uu^{\prime} = \frac{d}{dt} {\frac{1}{2}}u^2,\]</div>
<p>we get</p>
<div class="math">
\[\int_0^T (\frac{d}{dt}\frac{1}{2}(u^{\prime})^2 + \frac{d}{dt} \frac{1}{2}\omega^2u^2)dt = E(T) - E(0)=0,\]</div>
<p>where we have introduced</p>
<div class="math" id="eq-vib-model1-energy-balance1">
\[\tag{46}
E(t) = \frac{1}{2}(u^{\prime})^2 + \frac{1}{2}\omega^2u^2{\thinspace .}\]</div>
<p>The important result from this derivation is that the total energy
is constant:</p>
<div class="math">
\[E(t) = E(0){\thinspace .}\]</div>
<div class="admonition-math-e-t-is-closely-related-to-the-system-s-energy admonition">
<p class="first admonition-title"><span class="math">\(E(t)\)</span> is closely related to the system&#8217;s energy</p>
<p>The quantity <span class="math">\(E(t)\)</span> derived above is physically not the mechanical energy of a
vibrating mechanical system, but the energy per unit mass. To see this,
we start with Newton&#8217;s second law <span class="math">\(F=ma\)</span> (<span class="math">\(F\)</span> is the sum of forces, <span class="math">\(m\)</span>
is the mass of the system, and <span class="math">\(a\)</span> is the acceleration).
The displacement <span class="math">\(u\)</span> is related to <span class="math">\(a\)</span> through
<span class="math">\(a=u^{\prime\prime}\)</span>. With a spring force as the only force we have <span class="math">\(F=-ku\)</span>, where
<span class="math">\(k\)</span> is a spring constant measuring the stiffness of the spring.
Newton&#8217;s second law then implies the differential equation</p>
<div class="math">
\[-ku = mu^{\prime\prime}\quad\Rightarrow mu^{\prime\prime} + ku = 0{\thinspace .}\]</div>
<p>This equation of motion can be turned into an energy balance equation
by finding the work done by each term during a time interval <span class="math">\([0,T]\)</span>.
To this end, we multiply the equation by <span class="math">\(du=u^{\prime}dt\)</span> and integrate:</p>
<div class="math">
\[\int_0^T muu^{\prime}dt + \int_0^T kuu^{\prime}dt = 0{\thinspace .}\]</div>
<p>The result is</p>
<div class="math">
\[\tilde E(t) = E_k(t) + E_p(t) = 0,\]</div>
<p class="last">where</p>
</div>
<div class="math" id="eq-vib-model1-energy-kinetic">
\[ \begin{align}\begin{aligned} \tag{47}
 E_k(t) = \frac{1}{2}mv^2,\quad v=u^{\prime},\\is the *kinetic energy* of the system, and\\.. _Eq:vib:model1:energy:potential:\end{aligned}\end{align} \]</div>
<div class="math">
\[ \begin{align}\begin{aligned} \tag{48}
 E_p(t) = {\frac{1}{2}}ku^2\\is the *potential energy*. The sum  \( \tilde E(t) \)  is the total mechanical energy.
The derivation demonstrates the famous energy principle that, under
the right physical circumstances, any
change in the kinetic energy is due to a change in potential energy
and vice versa. (This principle breaks down when we introduce damping
in the system, as we do in the section :ref:`vib:model2`.)\\The equation  \( mu^{\prime\prime}+ku=0 \)  can be divided by  \( m \)  and written as
 \( u^{\prime\prime} + \omega^2u=0 \)  for  \( \omega=\sqrt{k/m} \) . The energy expression
 \( E(t)=\frac{1}{2}(u^{\prime})^2 + \frac{1}{2}\omega^2u^2 \)  derived earlier is then
 \( \tilde E(t)/m \) , i.e., mechanical energy per unit mass.\end{aligned}\end{align} \]</div>
<div class="section" id="energy-of-the-exact-solution">
<h4>Energy of the exact solution<a class="headerlink" href="#energy-of-the-exact-solution" title="Permalink to this headline">¶</a></h4>
<p>Analytically, we have <span class="math">\(u(t)=I\cos\omega t\)</span>, if <span class="math">\(u(0)=I\)</span> and <span class="math">\(u^{\prime}(0)=0\)</span>,
so we can easily check the energy evolution and confirm that <span class="math">\(E(t)\)</span>
is constant:</p>
<div class="math">
\[E(t) = {\frac{1}{2}}I^2 (-\omega\sin\omega t)^2
+ \frac{1}{2}\omega^2 I^2 \cos^2\omega t
= \frac{1}{2}\omega^2 (\sin^2\omega t + \cos^2\omega t) = \frac{1}{2}\omega^2
{\thinspace .}\]</div>
</div>
<div class="section" id="growth-of-energy-in-the-forward-euler-scheme">
<h4>Growth of energy in the Forward Euler scheme<a class="headerlink" href="#growth-of-energy-in-the-forward-euler-scheme" title="Permalink to this headline">¶</a></h4>
<p>The energy at time level <span class="math">\(n+1\)</span> in the Forward Euler scheme can easily
be shown to increase:</p>
<div class="math">
\[\begin{split}\begin{align*}
E^{n+1} &amp;= \frac{1}{2}(v^{n+1})^2 + \frac{1}{2}\omega^2 (u^{n+1})^2\\
&amp;= \frac{1}{2}(v^n - \omega^2\Delta t u^n)^2 + \frac{1}{2}\omega^2(u^n + \Delta t v^n)^2\\
&amp;= (1 + \Delta t^2\omega^2)E^n{\thinspace .}
\end{align*}\end{split}\]</div>
</div>
</div>
<div class="section" id="an-error-measure-based-on-energy">
<span id="vib-model1-energy-measure"></span><h3>An error measure based on energy<a class="headerlink" href="#an-error-measure-based-on-energy" title="Permalink to this headline">¶</a></h3>
<p>The constant energy is well expressed by its initial value <span class="math">\(E(0)\)</span>, so that
the error in mechanical energy can be computed as a mesh function by</p>
<div class="math" id="eq-auto19">
\[\tag{49}
e_E^n = \frac{1}{2}\left(\frac{u^{n+1}-u^{n-1}}{2\Delta t}\right)^2
    + \frac{1}{2}\omega^2 (u^n)^2 - E(0),
    \quad n=1,\ldots,N_t-1,\]</div>
<p>where</p>
<div class="math">
\[E(0) = {\frac{1}{2}}V^2 + \frac{1}{2}\omega^2I^2,\]</div>
<p>if <span class="math">\(u(0)=I\)</span> and <span class="math">\(u^{\prime}(0)=V\)</span>. Note that we have used a centered
approximation to <span class="math">\(u^{\prime}\)</span>: <span class="math">\(u^{\prime}(t_n)\approx [D_{2t}u]^n\)</span>.</p>
<p>A useful norm of the mesh function <span class="math">\(e_E^n\)</span> for the discrete mechanical
energy can be the maximum absolute value of <span class="math">\(e_E^n\)</span>:</p>
<div class="math">
\[||e_E^n||_{\ell^\infty} = \max_{1\leq n &lt;N_t} |e_E^n|{\thinspace .}\]</div>
<p>Alternatively, we can compute other norms involving integration over
all mesh points, but we are often interested in worst case deviation
of the energy, and then the maximum value is of particular relevance.</p>
<p>A vectorized Python implementation of <span class="math">\(e_E^n\)</span> takes the form</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># import numpy as np and compute u, t</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">E</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">((</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
<span class="n">E0</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">V</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">**</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="o">**</span><span class="mi">2</span>
<span class="n">e_E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">-</span> <span class="n">E0</span>
<span class="n">e_E_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">e_E</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
</pre></div>
</div>
<p>The convergence rates of the quantity <code class="docutils literal"><span class="pre">e_E_norm</span></code> can be used for
verification.  The value of <code class="docutils literal"><span class="pre">e_E_norm</span></code> is also useful for comparing
schemes through their ability to preserve energy. Below is a table
demonstrating the relative error in total energy for various schemes
(computed by the <a class="reference external" href="http://tinyurl.com/nu656p2/vib/vib_undamped_odespy.py">vib_undamped_odespy.py</a> program). The test problem is
<span class="math">\(u^{\prime\prime} + 4\pi^2 u =0\)</span> with <span class="math">\(u(0)=1\)</span> and <span class="math">\(u'(0)=0\)</span>, so the
period is 1 and <span class="math">\(E(t)\approx 4.93\)</span>. We clearly see that the
Crank-Nicolson and the Runge-Kutta schemes are superior to the Forward
and Backward Euler schemes already after one period.</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="10%" />
<col width="17%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head"><span class="math">\(T\)</span></th>
<th class="head"><span class="math">\(\Delta t\)</span></th>
<th class="head"><span class="math">\(\max \left\vert e_E^n\right\vert/e_E^0\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Forward Euler</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(1.678\cdot 10^{0}\)</span></td>
</tr>
<tr class="row-odd"><td>Backward Euler</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(6.235\cdot 10^{-1}\)</span></td>
</tr>
<tr class="row-even"><td>Crank-Nicolson</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(1.221\cdot 10^{-2}\)</span></td>
</tr>
<tr class="row-odd"><td>Runge-Kutta 2nd-order</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(6.076\cdot 10^{-3}\)</span></td>
</tr>
<tr class="row-even"><td>Runge-Kutta 4th-order</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(8.214\cdot 10^{-3}\)</span></td>
</tr>
</tbody>
</table>
<p>However, after 10 periods, the picture is much more dramatic:</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="11%" />
<col width="17%" />
<col width="49%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head"><span class="math">\(T\)</span></th>
<th class="head"><span class="math">\(\Delta t\)</span></th>
<th class="head"><span class="math">\(\max \left\vert e_E^n\right\vert/e_E^0\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Forward Euler</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(1.788\cdot 10^{4}\)</span></td>
</tr>
<tr class="row-odd"><td>Backward Euler</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(1.000\cdot 10^{0}\)</span></td>
</tr>
<tr class="row-even"><td>Crank-Nicolson</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(1.221\cdot 10^{-2}\)</span></td>
</tr>
<tr class="row-odd"><td>Runge-Kutta 2nd-order</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(6.250\cdot 10^{-2}\)</span></td>
</tr>
<tr class="row-even"><td>Runge-Kutta 4th-order</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(8.288\cdot 10^{-3}\)</span></td>
</tr>
</tbody>
</table>
<p>The Runge-Kutta and Crank-Nicolson methods hardly change their energy
error with <span class="math">\(T\)</span>, while the error in the Forward Euler method grows to
huge levels and a relative error of 1 in the Backward Euler method
points to <span class="math">\(E(t)\rightarrow 0\)</span> as <span class="math">\(t\)</span> grows large.</p>
<p>Running multiple values of <span class="math">\(\Delta t\)</span>, we can get some insight into
the convergence of the energy error:</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="11%" />
<col width="17%" />
<col width="49%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head"><span class="math">\(T\)</span></th>
<th class="head"><span class="math">\(\Delta t\)</span></th>
<th class="head"><span class="math">\(\max \left\vert e_E^n\right\vert/e_E^0\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Forward Euler</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(1.120\cdot 10^{8}\)</span></td>
</tr>
<tr class="row-odd"><td>Forward Euler</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(1.788\cdot 10^{4}\)</span></td>
</tr>
<tr class="row-even"><td>Forward Euler</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.0125\)</span></td>
<td><span class="math">\(1.374\cdot 10^{2}\)</span></td>
</tr>
<tr class="row-odd"><td>Backward Euler</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(1.000\cdot 10^{0}\)</span></td>
</tr>
<tr class="row-even"><td>Backward Euler</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(1.000\cdot 10^{0}\)</span></td>
</tr>
<tr class="row-odd"><td>Backward Euler</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.0125\)</span></td>
<td><span class="math">\(9.928\cdot 10^{-1}\)</span></td>
</tr>
<tr class="row-even"><td>Crank-Nicolson</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(4.756\cdot 10^{-2}\)</span></td>
</tr>
<tr class="row-odd"><td>Crank-Nicolson</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(1.221\cdot 10^{-2}\)</span></td>
</tr>
<tr class="row-even"><td>Crank-Nicolson</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.0125\)</span></td>
<td><span class="math">\(3.125\cdot 10^{-3}\)</span></td>
</tr>
<tr class="row-odd"><td>Runge-Kutta 2nd-order</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(6.152\cdot 10^{-1}\)</span></td>
</tr>
<tr class="row-even"><td>Runge-Kutta 2nd-order</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(6.250\cdot 10^{-2}\)</span></td>
</tr>
<tr class="row-odd"><td>Runge-Kutta 2nd-order</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.0125\)</span></td>
<td><span class="math">\(7.631\cdot 10^{-3}\)</span></td>
</tr>
<tr class="row-even"><td>Runge-Kutta 4th-order</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(3.510\cdot 10^{-2}\)</span></td>
</tr>
<tr class="row-odd"><td>Runge-Kutta 4th-order</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(8.288\cdot 10^{-3}\)</span></td>
</tr>
<tr class="row-even"><td>Runge-Kutta 4th-order</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.0125\)</span></td>
<td><span class="math">\(2.058\cdot 10^{-3}\)</span></td>
</tr>
</tbody>
</table>
<p>A striking fact from this table is that the error of the Forward Euler
method is reduced by the same factor as <span class="math">\(\Delta t\)</span> is reduced by,
while the error in the Crank-Nicolson method has a reduction
proportional to <span class="math">\(\Delta t^2\)</span> (we cannot say anything for the Backward
Euler method). However, for the RK2 method, halving <span class="math">\(\Delta t\)</span> reduces
the error by almost a factor of 10 (!), and for the RK4 method the
reduction seems proportional to <span class="math">\(\Delta t^2\)</span> only (and the trend is
confirmed by running smaller time steps, so for <span class="math">\(\Delta t = 3.9\cdot
10^{-4}\)</span> the relative error of RK2 is a factor 10 smaller than that of
RK4!).</p>
</div>
</div>
<div class="section" id="the-euler-cromer-method">
<span id="vib-model2x2-eulercromer"></span><h2>The Euler-Cromer method<a class="headerlink" href="#the-euler-cromer-method" title="Permalink to this headline">¶</a></h2>
<p>While the Runge-Kutta methods and the Crank-Nicolson scheme work well
for the vibration equation modeled as a first-order ODE system, both
were inferior to the straightforward centered difference scheme for
the second-order equation <span class="math">\(u^{\prime\prime}+\omega^2u=0\)</span>. However,
there is a similarly successful scheme available for the first-order
system <span class="math">\(u^{\prime}=v\)</span>, <span class="math">\(v^{\prime}=-\omega^2u\)</span>, to be presented below.
The ideas of the scheme and their further developments have become
very popular in particle and rigid body dynamics and hence widely
used by physicists.</p>
<span class="target" id="index-34"></span><div class="section" id="forward-backward-discretization">
<span id="index-35"></span><h3>Forward-backward discretization<a class="headerlink" href="#forward-backward-discretization" title="Permalink to this headline">¶</a></h3>
<p>The idea is to apply a Forward Euler discretization to the first
equation and a Backward Euler discretization to the second. In
operator notation this is stated as</p>
<div class="math" id="eq-auto20">
\[\tag{50}
\lbrack D_t^+u = v\rbrack^n,\]</div>
<div class="math" id="eq-auto21">
\[\tag{51}
\lbrack D_t^-v = -\omega^2 u\rbrack^{n+1}
    {\thinspace .}\]</div>
<p>We can write out the formulas and collect the unknowns on the left-hand side:</p>
<div class="math" id="eq-vib-model2x2-eulercromer-ueq1">
\[\tag{52}
u^{n+1} = u^n + \Delta t v^n,\]</div>
<div class="math" id="eq-vib-model2x2-eulercromer-veq1">
\[ \begin{align}\begin{aligned}\tag{53}
v^{n+1} = v^n -\Delta t \omega^2u^{n+1}\\    {\thinspace .}\end{aligned}\end{align} \]</div>
<p>We realize that after <span class="math">\(u^{n+1}\)</span> has been computed from
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1"><span class="std std-ref">(52)</span></a>, it may be used directly
in
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1"><span class="std std-ref">(53)</span></a> to compute <span class="math">\(v^{n+1}\)</span>.</p>
<p>In physics, it is more common to update the <span class="math">\(v\)</span> equation first, with a
forward difference, and thereafter the <span class="math">\(u\)</span> equation, with a backward
difference that applies the most recently computed <span class="math">\(v\)</span> value:</p>
<div class="math" id="eq-vib-model2x2-eulercromer-veq1b">
\[\tag{54}
v^{n+1} = v^n -\Delta t \omega^2u^{n},\]</div>
<div class="math" id="eq-vib-model2x2-eulercromer-ueq1b">
\[\tag{55}
u^{n+1} = u^n + \Delta t v^{n+1}{\thinspace .}\]</div>
<p>The advantage of ordering the ODEs as in
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1b"><span class="std std-ref">(54)</span></a>-<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><span class="std std-ref">(55)</span></a>
becomes evident when considering complicated models. Such models are
included if we write our vibration ODE more generally as</p>
<div class="math">
\[u^{\prime\prime} + g(u, u^{\prime}, t)=0{\thinspace .}\]</div>
<p>We can rewrite this second-order ODE as two first-order ODEs,</p>
<div class="math">
\[\begin{split}\begin{align*}
v^{\prime} &amp;= -g(u,v,t),\\
u^{\prime} &amp;= v{\thinspace .}
\end{align*}\end{split}\]</div>
<p>This rewrite allows the following scheme to be used:</p>
<div class="math">
\[\begin{split}\begin{align*}
v^{n+1} &amp;= v^n -\Delta t\, g(u^n,v^n,t),\\
u^{n+1} &amp;= u^n + \Delta t\, v^{n+1}{\thinspace .}
\end{align*}\end{split}\]</div>
<p>We realize that the first update works well with any <span class="math">\(g\)</span> since old
values <span class="math">\(u^n\)</span> and <span class="math">\(v^n\)</span> are used. Switching the equations would
demand <span class="math">\(u^{n+1}\)</span> and <span class="math">\(v^{n+1}\)</span> values in <span class="math">\(g\)</span> and result in nonlinear
algebraic equations to be solved at each time level.</p>
<p id="index-36">The scheme
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1b"><span class="std std-ref">(54)</span></a>-<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><span class="std std-ref">(55)</span></a>
goes under several names: forward-backward scheme, <a class="reference external" href="http://en.wikipedia.org/wiki/Semi-implicit_Euler_method">semi-implicit
Euler method</a>,
semi-explicit Euler, symplectic Euler,
Newton-Stoermer-Verlet,
and Euler-Cromer.  We shall stick to the latter name.
Since both time
discretizations are based on first-order difference approximation, one
may think that the scheme is only of first-order, but this is not
true: the use of a forward and then a backward difference make errors
cancel so that the overall error in the scheme is <span class="math">\(\Oof{\Delta
t^2}\)</span>. This is explained below.</p>
<p>How does the Euler-Cromer method preserve the total energy?
We may run the example from the section <a class="reference internal" href="#vib-model1-energy-measure"><span class="std std-ref">An error measure based on energy</span></a>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="12%" />
<col width="19%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head"><span class="math">\(T\)</span></th>
<th class="head"><span class="math">\(\Delta t\)</span></th>
<th class="head"><span class="math">\(\max \left\vert e_E^n\right\vert/e_E^0\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Euler-Cromer</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(2.530\cdot 10^{-2}\)</span></td>
</tr>
<tr class="row-odd"><td>Euler-Cromer</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(6.206\cdot 10^{-3}\)</span></td>
</tr>
<tr class="row-even"><td>Euler-Cromer</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.0125\)</span></td>
<td><span class="math">\(1.544\cdot 10^{-3}\)</span></td>
</tr>
</tbody>
</table>
<p>The relative error in the total energy decreases as <span class="math">\(\Delta t^2\)</span>,
and the error level is slightly lower than for the Crank-Nicolson and
Runge-Kutta methods.</p>
</div>
<div class="section" id="equivalence-with-the-scheme-for-the-second-order-ode">
<span id="vib-model2x2-eulercromer-equiv"></span><h3>Equivalence with the scheme for the second-order ODE<a class="headerlink" href="#equivalence-with-the-scheme-for-the-second-order-ode" title="Permalink to this headline">¶</a></h3>
<p>We shall now show that the Euler-Cromer scheme for the system of
first-order equations is equivalent to the centered finite difference
method for the second-order vibration ODE (!).</p>
<p>We may eliminate the <span class="math">\(v^n\)</span> variable from
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1"><span class="std std-ref">(52)</span></a>-<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1"><span class="std std-ref">(53)</span></a>
or
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1b"><span class="std std-ref">(54)</span></a>-<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><span class="std std-ref">(55)</span></a>.
The <span class="math">\(v^{n+1}\)</span> term in <a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1b"><span class="std std-ref">(54)</span></a> can
be eliminated from <a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><span class="std std-ref">(55)</span></a>:</p>
<div class="math" id="eq-vib-model2x2-eulercromer-elim1">
\[\tag{56}
u^{n+1} = u^n + \Delta t (v^n - \omega^2\Delta t u^n){\thinspace .}\]</div>
<p>The <span class="math">\(v^{n}\)</span> quantity can be expressed by <span class="math">\(u^n\)</span> and <span class="math">\(u^{n-1}\)</span>
using <a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><span class="std std-ref">(55)</span></a>:</p>
<div class="math">
\[v^{n} = \frac{u^n - u^{n-1}}{\Delta t},\]</div>
<p>and when this is inserted in <a class="reference internal" href="#eq-vib-model2x2-eulercromer-elim1"><span class="std std-ref">(56)</span></a> we get</p>
<div class="math" id="eq-auto22">
\[\tag{57}
u^{n+1} = 2u^n - u^{n-1} - \Delta t^2 \omega^2u^{n},\]</div>
<p>which is nothing but the centered scheme <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a>!  The
two seemingly different numerical methods are mathematically
equivalent. Consequently, the previous analysis of
<a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a> also applies to the Euler-Cromer method. In
particular, the amplitude is constant, given that the stability
criterion is fulfilled, but there is always an angular frequency error
<a class="reference internal" href="#eq-vib-ode1-tildeomega-series"><span class="std std-ref">(19)</span></a>. <a class="reference internal" href="#vib-exer-eulercromer-analysis"><span class="std std-ref">Exercise 1.18: Analysis of the Euler-Cromer scheme</span></a> gives guidance on how to derive the
exact discrete solution of the two equations in the Euler-Cromer
method.</p>
<p>Although the Euler-Cromer scheme and the method <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a>
are equivalent, there could be differences in the way they handle the
initial conditions. Let is look into this topic.  The initial
condition <span class="math">\(u^{\prime}=0\)</span> means <span class="math">\(u^{\prime}=v=0\)</span>.  From
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1b"><span class="std std-ref">(54)</span></a> we get</p>
<div class="math">
\[v^1=v^0-\Delta t\omega^2 u^0
=\Delta t\omega^2 u^0,\]</div>
<p>and from <a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><span class="std std-ref">(55)</span></a>
it follows that</p>
<div class="math">
\[u^1=u^0 + \Delta t v^1 = u^0 - \omega^2\Delta t^2 u^0{\thinspace .}\]</div>
<p>When we previously used a centered approximation of <span class="math">\(u^{\prime}(0)=0\)</span>
combined with the discretization <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a> of the
second-order ODE, we got a slightly different result: <span class="math">\(u^1=u^0 -
\frac{1}{2}\omega^2\Delta t^2 u^0\)</span>. The difference is
<span class="math">\(\frac{1}{2}\omega^2\Delta t^2 u^0\)</span>, which is of second order in
<span class="math">\(\Delta t\)</span>, seemingly consistent with the overall error in the scheme
for the differential equation model.</p>
<p>A different view can also be taken.  If we approximate
<span class="math">\(u^{\prime}(0)=0\)</span> by a backward difference, <span class="math">\((u^0-u^{-1})/\Delta t
=0\)</span>, we get <span class="math">\(u^{-1}=u^0\)</span>, and when combined with
<a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a>, it results in <span class="math">\(u^1=u^0 - \omega^2\Delta t^2
u^0\)</span>. This means that the Euler-Cromer method based on
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><span class="std std-ref">(55)</span></a>-<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1b"><span class="std std-ref">(54)</span></a>
corresponds to using only a first-order approximation to the initial
condition in the method from the section <a class="reference internal" href="#vib-ode1-fdm"><span class="std std-ref">A centered finite difference scheme</span></a>.</p>
<p>Correspondingly, using the formulation
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1"><span class="std std-ref">(52)</span></a>-<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1"><span class="std std-ref">(53)</span></a>
with <span class="math">\(v^n=0\)</span> leads to <span class="math">\(u^1=u^0\)</span>, which can be interpreted as using a
forward difference approximation for the initial condition
<span class="math">\(u^{\prime}(0)=0\)</span>.  Both Euler-Cromer formulations lead to slightly
different values for <span class="math">\(u^1\)</span> compared to the method in the section <a class="reference internal" href="#vib-ode1-fdm"><span class="std std-ref">A centered finite difference scheme</span></a>.  The error is <span class="math">\(\frac{1}{2}\omega^2\Delta t^2 u^0\)</span>.</p>
</div>
<div class="section" id="implementation-2">
<span id="vib-model2x2-eulercromer-impl"></span><h3>Implementation<a class="headerlink" href="#implementation-2" title="Permalink to this headline">¶</a></h3>
<div class="section" id="solver-function">
<h4>Solver function<a class="headerlink" href="#solver-function" title="Permalink to this headline">¶</a></h4>
<p>The function below, found in <a class="reference external" href="http://tinyurl.com/nu656p2/vib/vib_undamped_EulerCromer.py">vib_undamped_EulerCromer.py</a>, implements the Euler-Cromer scheme
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1b"><span class="std std-ref">(54)</span></a>-<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><span class="std std-ref">(55)</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve v&#39; = - w**2*u, u&#39;=v for t in (0,T], u(0)=I and v(0)=0,</span>
<span class="sd">    by an Euler-Cromer method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
</div>
<div class="section" id="verification-2">
<h4>Verification<a class="headerlink" href="#verification-2" title="Permalink to this headline">¶</a></h4>
<p>Since the Euler-Cromer scheme is equivalent to the finite difference
method for the second-order ODE <span class="math">\(u^{\prime\prime}+\omega^2u=0\)</span> (see the section <a class="reference internal" href="#vib-model2x2-eulercromer-equiv"><span class="std std-ref">Equivalence with the scheme for the second-order ODE</span></a>), the performance of the above
<code class="docutils literal"><span class="pre">solver</span></code> function is the same as for the <code class="docutils literal"><span class="pre">solver</span></code> function in the section <a class="reference internal" href="#vib-impl1"><span class="std std-ref">Implementation</span></a>. The only difference is the formula for the first time
step, as discussed above.  This deviation in the Euler-Cromer scheme
means that the discrete solution listed in the section <a class="reference internal" href="#vib-ode1-analysis-sol"><span class="std std-ref">Exact discrete solution</span></a> is not a solution of the Euler-Cromer
scheme!</p>
<p>To verify the implementation of the Euler-Cromer method we can adjust
<code class="docutils literal"><span class="pre">v[1]</span></code> so that the computer-generated values can be compared with the
formula <a class="reference internal" href="#eq-vib-ode1-un-exact"><span class="std std-ref">(20)</span></a> from in the section <a class="reference internal" href="#vib-ode1-analysis-sol"><span class="std std-ref">Exact discrete solution</span></a>. This adjustment is done in an alternative
solver function, <code class="docutils literal"><span class="pre">solver_ic_fix</span></code> in <code class="docutils literal"><span class="pre">vib_EulerCromer.py</span></code>. Since we now
have an exact solution of the discrete equations available, we can
write a test function <code class="docutils literal"><span class="pre">test_solver</span></code> for checking the equality of
computed values with the formula <a class="reference internal" href="#eq-vib-ode1-un-exact"><span class="std std-ref">(20)</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_solver</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test solver with fixed initial condition against</span>
<span class="sd">    equivalent scheme for the 2nd-order ODE u&#39;&#39; + u = 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">I</span> <span class="o">=</span> <span class="mf">1.2</span><span class="p">;</span> <span class="n">w</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span> <span class="n">T</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="n">w</span>  <span class="c1"># longest possible time step</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver_ic_fix</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">vib_undamped</span> <span class="kn">import</span> <span class="n">solver</span> <span class="k">as</span> <span class="n">solver2</span>  <span class="c1"># 2nd-order ODE</span>
    <span class="n">u2</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">solver2</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u2</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">assert</span> <span class="n">error</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
<p>Another function, <code class="docutils literal"><span class="pre">demo</span></code>, visualizes the difference between the
Euler-Cromer scheme and the scheme <a class="reference internal" href="#eq-vib-ode1-step4"><span class="std std-ref">(7)</span></a> for the
second-oder ODE, arising from the mismatch in the first time level.</p>
</div>
<div class="section" id="using-odespy">
<h4>Using Odespy<a class="headerlink" href="#using-odespy" title="Permalink to this headline">¶</a></h4>
<p>The Euler-Cromer method is also available in the Odespy package.  The
important thing to remember, when using this implementation, is that
we must order the unknowns as <span class="math">\(v\)</span> and <span class="math">\(u\)</span>, so the <code class="docutils literal"><span class="pre">u</span></code> vector at each
time level consists of the velocity <span class="math">\(v\)</span> as first component and the
displacement <span class="math">\(u\)</span> as second component:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Define ODE</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">v</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">u</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">-</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span>

<span class="c1"># Initialize solver</span>
<span class="n">I</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">w</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="kn">import</span> <span class="nn">odespy</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">EulerCromer</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="n">w</span><span class="p">})</span>
<span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">I</span><span class="p">])</span>

<span class="c1"># Compute time mesh</span>
<span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>  <span class="c1"># duration of one period</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">P</span><span class="o">/</span><span class="n">timesteps_per_period</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="n">num_periods</span><span class="o">*</span><span class="n">timesteps_per_period</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="n">t_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Solve ODE</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">t_mesh</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Extract displacement</span>
</pre></div>
</div>
</div>
<div class="section" id="convergence-rates-1">
<h4>Convergence rates<a class="headerlink" href="#convergence-rates-1" title="Permalink to this headline">¶</a></h4>
<p>We may use the <code class="docutils literal"><span class="pre">convergence_rates</span></code> function in the file
<code class="docutils literal"><span class="pre">vib_undamped.py</span></code> to investigate the convergence rate of the
Euler-Cromer method, see the <code class="docutils literal"><span class="pre">convergence_rate</span></code> function in the file
<code class="docutils literal"><span class="pre">vib_undamped_EulerCromer.py</span></code>.  Since we could eliminate <span class="math">\(v\)</span> to get a
scheme for <span class="math">\(u\)</span> that is equivalent to the finite difference method for
the second-order equation in <span class="math">\(u\)</span>, we would expect the convergence
rates to be the same, i.e., <span class="math">\(\mathcal{O}(\Delta t^2)\)</span>. However,
measuring the convergence rate of <span class="math">\(u\)</span> in the Euler-Cromer scheme shows
that it is <span class="math">\(\mathcal{O}(\Delta t)\)</span>!  Adjusting the initial condition
does not change the rate. Adjusting <span class="math">\(\omega\)</span>, as outlined in the section <a class="reference internal" href="#vib-ode1-analysis-numfreq"><span class="std std-ref">The error in the numerical frequency</span></a>, gives a 4th-order method there, while
there is no increase in the measured rate in the Euler-Cromer
scheme. It is obvious that the Euler-Cromer scheme is dramatically
much better than the two other first-order methods, Forward Euler and
Backward Euler, but this is not reflected in the convergence rate of
<span class="math">\(u\)</span>.</p>
</div>
</div>
<div class="section" id="the-stoermer-verlet-algorithm">
<span id="vib-model2x2-stormerverlet"></span><h3>The Stoermer-Verlet algorithm<a class="headerlink" href="#the-stoermer-verlet-algorithm" title="Permalink to this headline">¶</a></h3>
<p id="index-37">Another very popular algorithm for vibration problems, especially
for long time simulations, is the
Stoermer-Verlet
algorithm. It has become <em>the</em> method among physicists
for molecular simulations as well as particle and rigid body dynamics.</p>
<p>The method can be derived by applying the Euler-Cromer idea
twice, in a symmetric fashion, during the interval <span class="math">\([t_n,t_{n+1}]\)</span>:</p>
<ol class="arabic simple">
<li>solve <span class="math">\(v^{\prime}=-\omega u\)</span> by a Forward Euler step in <span class="math">\([t_n,t_{n+\frac{1}{2}}]\)</span></li>
<li>solve <span class="math">\(u^{\prime}=v\)</span> by a Backward Euler step in <span class="math">\([t_n,t_{n+\frac{1}{2}}]\)</span></li>
<li>solve <span class="math">\(u^{\prime}=v\)</span> by a Forward Euler step in <span class="math">\([t_{n+\frac{1}{2}}, t_{n+1}]\)</span></li>
<li>solve <span class="math">\(v^{\prime}=-\omega u\)</span> by a Backward Euler step in <span class="math">\([t_{n+\frac{1}{2}}, t_{n+1}]\)</span></li>
</ol>
<p>With mathematics,</p>
<div class="math">
\[\begin{split}\begin{align*}
\frac{v^{n+\frac{1}{2}}-v^n}{\frac{1}{2}\Delta t} &amp;= -\omega^2 u^n,\\
\frac{u^{n+\frac{1}{2}}-u^n}{\frac{1}{2}\Delta t} &amp;= v^{n+\frac{1}{2}},\\
\frac{u^{n+1}-u^{n-\frac{1}{2}}}{\frac{1}{2}\Delta t} &amp;= v^{n+\frac{1}{2}},\\
\frac{v^{n+1}-v^{n+\frac{1}{2}}}{\frac{1}{2}\Delta t} &amp;= -\omega^2 u^{n+1}{\thinspace .}
\end{align*}\end{split}\]</div>
<p>The two steps in the middle can be combined to</p>
<div class="math">
\[\frac{u^{n+1}-u^{n-1}}{\Delta t} = v^{n+\frac{1}{2}},\]</div>
<p>and consequently</p>
<div class="math" id="eq-auto23">
\[\tag{58}
v^{n+\frac{1}{2}} = v^n - \frac{1}{2}\Delta t \omega^2 u^n,\]</div>
<div class="math" id="eq-auto24">
\[\tag{59}
u^{n+1} = u^{n} + \Delta t v^{n+\frac{1}{2}},\]</div>
<div class="math" id="eq-auto25">
\[\tag{60}
v^{n+1} = v^{n+\frac{1}{2}} - \frac{1}{2}\Delta t \omega^2 u^{n+1}{\thinspace .}\]</div>
<p>Writing the last equation as <span class="math">\(v^n = v^{n-\frac{1}{2}} - \frac{1}{2}\Delta
t\omega^2 u^n\)</span> and using this <span class="math">\(v^n\)</span> in the first equation gives
<span class="math">\(v^{n+\frac{1}{2}} = v^{n-\frac{1}{2}} - \Delta t\omega^2 u^n\)</span>, and the scheme can
be written as two steps:</p>
<div class="math" id="eq-vib-model2x2-stormerverlet-eqv">
\[\tag{61}
v^{n+\frac{1}{2}} = v^{n-\frac{1}{2}} - \Delta t \omega^2 u^n,\]</div>
<div class="math" id="eq-vib-model2x2-stormerverlet-equ">
\[\tag{62}
u^{n+1} = u^{n} + \Delta t v^{n+\frac{1}{2}},\]</div>
<p>which is nothing but straightforward centered differences for the
<span class="math">\(2\times 2\)</span> ODE system on a <em>staggered mesh</em>, see
the section <a class="reference internal" href="#vib-model2x2-staggered"><span class="std std-ref">The Euler-Cromer scheme on a staggered mesh</span></a>. We have thus seen that
four different reasonings (discretizing <span class="math">\(u^{\prime\prime}+\omega^2 u\)</span>
directly, using Euler-Cromer, using
Stoermer-Verlet,
and using centered differences for the <span class="math">\(2times 2\)</span> system on a staggered
mesh) all end up with the same equations! The main difference is that
the traditional Euler-Cromer displays first-order convergence in <span class="math">\(\Delta t\)</span>
(due to less symmetry in the way <span class="math">\(u\)</span> and <span class="math">\(v\)</span> are treated)
while the others are <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span> schemes.</p>
<p>The most numerical stable scheme, with respect to accumulation of
rounding errors, is
<a class="reference internal" href="#eq-vib-model2x2-stormerverlet-eqv"><span class="std std-ref">(61)</span></a>-<a class="reference internal" href="#eq-vib-model2x2-stormerverlet-equ"><span class="std std-ref">(62)</span></a>.
It has, according to <a class="reference internal" href="._book027.html#ref04" id="id9">[Ref04]</a>, better
properties in this regard than the direct scheme for the second-order
ODE.</p>
</div>
</div>
<div class="section" id="staggered-mesh">
<h2>Staggered mesh<a class="headerlink" href="#staggered-mesh" title="Permalink to this headline">¶</a></h2>
<p>A more intuitive discretization than the Euler-Cromer method, yet
equivalent, employs solely centered differences in a natural way
for the <span class="math">\(2\times 2\)</span> first-order ODE system.
The scheme is in fact fully equivalent to the second-order scheme for
<span class="math">\(u''+\omega u=0\)</span>, also for the first time step.
Such a scheme needs to operate on a <em>staggered mesh</em> in time.
Staggered meshes are very popular in many physical application, maybe foremost
fluid dynamics and electromagnetics, so the topic is important to learn.</p>
<div class="section" id="the-euler-cromer-scheme-on-a-staggered-mesh">
<span id="vib-model2x2-staggered"></span><h3>The Euler-Cromer scheme on a staggered mesh<a class="headerlink" href="#the-euler-cromer-scheme-on-a-staggered-mesh" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-38"></span><span class="target" id="index-39"></span><p id="index-40">In a staggered mesh, the unknowns are sought at different points in
the mesh. Specifically, <span class="math">\(u\)</span> is sought at
integer time points <span class="math">\(t_n\)</span> and <span class="math">\(v\)</span> is sought at <span class="math">\(t_{n+1/2}\)</span>
<em>between</em> two <span class="math">\(u\)</span> points.
The unknowns are then <span class="math">\(u^1, v^{3/2}, u^2, v^{5/2}\)</span>, and so on.
We typically use the notation
<span class="math">\(u^n\)</span> and <span class="math">\(v^{n+\frac{1}{2}}\)</span> for the two unknown mesh functions.
Figure <a class="reference internal" href="#staggered-ec-fig1"><span class="std std-ref">Examples on mesh functions on a staggered mesh in time</span></a> presents a graphical sketch of two
mesh functions <span class="math">\(u\)</span> and <span class="math">\(v\)</span> on a staggered mesh.</p>
<div class="figure" id="id22">
<span id="staggered-ec-fig1"></span><a class="reference internal image-reference" href="_images/staggered_time.png"><img alt="_images/staggered_time.png" src="_images/staggered_time.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text"><em>Examples on mesh functions on a staggered mesh in time</em></span></p>
</div>
<p>On a staggered mesh it is natural to
use centered difference approximations, expressed
in operator notation as</p>
<div class="math" id="eq-auto26">
\[\tag{63}
\lbrack D_t u = v\rbrack^{n+\frac{1}{2}},\]</div>
<div class="math" id="eq-auto27">
\[\tag{64}
\lbrack D_t v = -\omega u\rbrack^{n+1}
    {\thinspace .}\]</div>
<p>or if we switch the sequence of the equations:</p>
<div class="math" id="eq-auto28">
\[\tag{65}
\lbrack D_t v = -\omega u\rbrack^{n},\]</div>
<div class="math" id="eq-auto29">
\[\tag{66}
\lbrack D_t u = v\rbrack^{n+\frac{1}{2}}
    {\thinspace .}\]</div>
<p>Writing out the formulas gives</p>
<div class="math" id="eq-vib-model2x2-eulercromer-veq1s2">
\[\tag{67}
v^{n+\frac{1}{2}} = v^{n-\frac{1}{2}} -\Delta t \omega^2u^{n}
    ,\]</div>
<div class="math" id="eq-vib-model2x2-eulercromer-ueq1s2">
\[ \begin{align}\begin{aligned}\tag{68}
u^{n+1} = u^{n} + \Delta t v^{n+\frac{1}{2}}\\    {\thinspace .}\end{aligned}\end{align} \]</div>
<p>We can eliminate the <span class="math">\(v\)</span>
values and get back the centered scheme based on the second-order
differential equation <span class="math">\(u^{\prime\prime} +\omega^2 u = 0\)</span>,
so all these three schemes are equivalent.
However, they differ somewhat in the treatment of the initial
conditions.</p>
<p>Suppose we have <span class="math">\(u(0)=I\)</span> and <span class="math">\(u'(0)=v(0)=0\)</span> as mathematical
initial conditions. This means <span class="math">\(u^0=I\)</span> and</p>
<div class="math">
\[v(0)\approx \frac{1}{2}(v^{-\frac{1}{2}} + v^{\frac{1}{2}}) = 0,
\quad\Rightarrow\quad v^{-\frac{1}{2}} =- v^\frac{1}{2}{\thinspace .}\]</div>
<p>Using the discretized equation <a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1s2"><span class="std std-ref">(67)</span></a> for
<span class="math">\(n=0\)</span> yields</p>
<div class="math">
\[v^\frac{1}{2} = v^{-\frac{1}{2}} -\Delta t\omega^2 I,\]</div>
<p>and eliminating <span class="math">\(v^{-\frac{1}{2}} =- v^{\frac{1}{2}}\)</span>
results in</p>
<div class="math">
\[v^\frac{1}{2} = -\frac{1}{2}\Delta t\omega^2I,\]</div>
<p>and</p>
<div class="math">
\[u^1 = u^0 - \frac{1}{2}\Delta t^2\omega^2 I,\]</div>
<p>which is exactly the same equation for <span class="math">\(u^1\)</span> as we had in the
centered scheme based on the second-order differential equation
(and hence corresponds to a centered difference approximation of
the initial condition for <span class="math">\(u'(0)\)</span>).
The conclusion is that a staggered mesh is fully equivalent with
that scheme, while the forward-backward version gives a slight
deviation in the computation of <span class="math">\(u^1\)</span>.</p>
<p>We can redo the derivation of the initial conditions when <span class="math">\(u'(0)=V\)</span>:</p>
<div class="math">
\[v(0)\approx \frac{1}{2}(v^{-\frac{1}{2}} + v^{\frac{1}{2}}) = V,
\quad\Rightarrow\quad v^{-\frac{1}{2}} = 2V - v^\frac{1}{2}{\thinspace .}\]</div>
<p>Using this <span class="math">\(v^{-\frac{1}{2}}\)</span> in</p>
<div class="math">
\[v^\frac{1}{2} = v^{-\frac{1}{2}} -\Delta t\omega^2 I,\]</div>
<p>then gives <span class="math">\(v^\frac{1}{2} = V - \frac{1}{2}\Delta t\omega^2 I\)</span>.
The general initial conditions are therefore</p>
<div class="math" id="eq-vib-ode2-staggered-u0">
\[\tag{69}
u^0 = I,\]</div>
<div class="math" id="eq-vib-ode2-staggered-v0">
\[\tag{70}
v^\frac{1}{2} = V - \frac{1}{2}\Delta t\omega^2I
    {\thinspace .}\]</div>
</div>
<div class="section" id="implementation-of-the-scheme-on-a-staggered-mesh">
<h3>Implementation of the scheme on a staggered mesh<a class="headerlink" href="#implementation-of-the-scheme-on-a-staggered-mesh" title="Permalink to this headline">¶</a></h3>
<p>The algorithm goes like this:</p>
<ol class="arabic simple">
<li>Set the initial values <a class="reference internal" href="#eq-vib-ode2-staggered-u0"><span class="std std-ref">(69)</span></a> and
<a class="reference internal" href="#eq-vib-ode2-staggered-v0"><span class="std std-ref">(70)</span></a>.</li>
<li>For <span class="math">\(n=1,2,\ldots\)</span>:</li>
</ol>
<blockquote>
<div><ol class="loweralpha simple">
<li>Compute <span class="math">\(u^{n}\)</span> from <a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1s2"><span class="std std-ref">(68)</span></a>.</li>
<li>Compute <span class="math">\(v^{n+\frac{1}{2}}\)</span> from <a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1s2"><span class="std std-ref">(67)</span></a>.</li>
</ol>
</div></blockquote>
<div class="section" id="implementation-with-integer-indices">
<h4>Implementation with integer indices<a class="headerlink" href="#implementation-with-integer-indices" title="Permalink to this headline">¶</a></h4>
<p>Translating the schemes <a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1s2"><span class="std std-ref">(68)</span></a>
and <a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1s2"><span class="std std-ref">(67)</span></a> to computer code
faces the problem of how to store and access <span class="math">\(v^{n+\frac{1}{2}}\)</span>,
since arrays only allow integer indices with base 0.
We must then introduce a convention: <span class="math">\(v^{1+\frac{1}{2}}\)</span> is stored
in <code class="docutils literal"><span class="pre">v[n]</span></code> while <span class="math">\(v^{1-\frac{1}{2}}\)</span> is stored in <code class="docutils literal"><span class="pre">v[n-1]</span></code>.
We can then write the algorithm in Python as</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># mesh for u</span>
    <span class="n">t_v</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mi">2</span>                <span class="c1"># mesh for v</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t_v</span>
</pre></div>
</div>
<p>Note that <span class="math">\(u\)</span> and <span class="math">\(v\)</span> are returned together with the mesh points such
that the complete mesh function for <span class="math">\(u\)</span> is described by <code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">t</span></code>,
while <code class="docutils literal"><span class="pre">v</span></code> and <code class="docutils literal"><span class="pre">t_v</span></code> represent the mesh function for <span class="math">\(v\)</span>.
Implementation with half-integer indices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p>
<p>Some prefer to see a closer relationship between the code and
the mathematics for the quantities with half-integer indices.
For example, we would like to replace the updating equation for
<code class="docutils literal"><span class="pre">v[n]</span></code> by</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="n">half</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="n">half</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<p>This is easy to do if we could be sure that <code class="docutils literal"><span class="pre">n+half</span></code> means <code class="docutils literal"><span class="pre">n</span></code> and
<code class="docutils literal"><span class="pre">n-half</span></code> means <code class="docutils literal"><span class="pre">n-1</span></code>. A possible solution is to define <code class="docutils literal"><span class="pre">half</span></code> as a
special object such that an integer plus <code class="docutils literal"><span class="pre">half</span></code> results in the integer,
while an integer minus <code class="docutils literal"><span class="pre">half</span></code> equals the integer minus 1.
A simple Python class may realize the <code class="docutils literal"><span class="pre">half</span></code> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">HalfInt</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">other</span> <span class="o">-</span> <span class="mi">1</span>

<span class="n">half</span> <span class="o">=</span> <span class="n">HalfInt</span><span class="p">()</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">__radd__</span></code> function is invoked for all expressions <code class="docutils literal"><span class="pre">n+half</span></code>
(&#8220;right add&#8221; with <code class="docutils literal"><span class="pre">self</span></code> as <code class="docutils literal"><span class="pre">half</span></code> and <code class="docutils literal"><span class="pre">other</span></code> as <code class="docutils literal"><span class="pre">n</span></code>). Similarly,
the <code class="docutils literal"><span class="pre">__rsub__</span></code> function is invoked for <code class="docutils literal"><span class="pre">n-half</span></code> and results in <code class="docutils literal"><span class="pre">n-1</span></code>.</p>
<p>Using the <code class="docutils literal"><span class="pre">half</span></code> object, we can implement the algorithms in an even
more readable way:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;=v, v&#39; = - w**2*u for t in (0,T], u(0)=I and v(0)=0,</span>
<span class="sd">    by a central finite difference method with time step dt on</span>
<span class="sd">    a staggered mesh with v as unknown at (i+1/2)*dt time points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># mesh for u</span>
    <span class="n">t_v</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mi">2</span>                <span class="c1"># mesh for v</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="o">+</span><span class="n">half</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="n">half</span><span class="p">]</span>
        <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="n">half</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="n">half</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t_v</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Verification of this code is easy as we can just compare the computed
<code class="docutils literal"><span class="pre">u</span></code> with the <code class="docutils literal"><span class="pre">u</span></code> produced by the <code class="docutils literal"><span class="pre">solver</span></code> function in
<code class="docutils literal"><span class="pre">vib_undamped.py</span></code> (which solves <span class="math">\(u''+\omega^2u=0\)</span> directly).  The
values should coincide to machine precision since the two numerical
methods are mathematically equivalent.  We refer to the file
<a class="reference external" href="http://tinyurl.com/nu656p2/vib/vib_undamped_staggered.py">vib_undamped_staggered.py</a>
for the details of a unit test (<code class="docutils literal"><span class="pre">test_staggered</span></code>) that checks this property.</p>
</div>
</div>
</div>
<div class="section" id="exercises-and-problems-1">
<h2>Exercises and Problems<a class="headerlink" href="#exercises-and-problems-1" title="Permalink to this headline">¶</a></h2>
<div class="section" id="problem-1-1-use-linear-quadratic-functions-for-verification">
<span id="vib-exer-undamped-verify-linquad"></span><h3>Problem 1.1: Use linear/quadratic functions for verification<a class="headerlink" href="#problem-1-1-use-linear-quadratic-functions-for-verification" title="Permalink to this headline">¶</a></h3>
<p>Consider the ODE problem</p>
<div class="math">
\[u^{\prime\prime} + \omega^2u=f(t), \quad u(0)=I,\ u^{\prime}(0)=V,\ t\in(0,T]{\thinspace .}\]</div>
<p><strong>a)</strong>
Discretize this equation according to <span class="math">\([D_tD_t u + \omega^2 u = f]^n\)</span> and
derive the equation for the first time step (<span class="math">\(u^1\)</span>).</p>
<p><strong>b)</strong>
For verification purposes, we use the method of manufactured solutions (MMS) with the
choice of <span class="math">\({u_{\small\mbox{e}}}(t)= ct+d\)</span>. Find restrictions on <span class="math">\(c\)</span> and <span class="math">\(d\)</span> from
the initial conditions. Compute the corresponding source term <span class="math">\(f\)</span>.
Show that <span class="math">\([D_tD_t t]^n=0\)</span> and use the fact
that the <span class="math">\(D_tD_t\)</span> operator is linear,
<span class="math">\([D_tD_t (ct+d)]^n = c[D_tD_t t]^n + [D_tD_t d]^n = 0\)</span>, to show that
<span class="math">\({u_{\small\mbox{e}}}\)</span> is also a perfect solution of the discrete equations.</p>
<p><strong>c)</strong>
Use <code class="docutils literal"><span class="pre">sympy</span></code> to do the symbolic calculations above. Here is a
sketch of the program <code class="docutils literal"><span class="pre">vib_undamped_verify_mms.py</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="n">V</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;V t I w dt&#39;</span><span class="p">)</span>  <span class="c1"># global symbols</span>
<span class="n">f</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># global variable for the source term in the ODE</span>

<span class="k">def</span> <span class="nf">ode_source_term</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the terms in the ODE that the source term</span>
<span class="sd">    must balance, here u&#39;&#39; + w**2*u.</span>
<span class="sd">    u is symbolic Python function of t.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">residual_discrete_eq</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the residual of the discrete eq. with u inserted.&quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">return</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">residual_discrete_eq_step1</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the residual of the discrete eq. at the first</span>
<span class="sd">    step with u inserted.&quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">return</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DtDt</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return 2nd-order finite difference for u_tt.</span>
<span class="sd">    u is a symbolic Python function of t.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given some chosen solution u (as a function of t, implemented</span>
<span class="sd">    as a Python function), use the method of manufactured solutions</span>
<span class="sd">    to compute the source term f, and check if u also solves</span>
<span class="sd">    the discrete equations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">print</span> <span class="s1">&#39;=== Testing exact solution: </span><span class="si">%s</span><span class="s1"> ===&#39;</span> <span class="o">%</span> <span class="n">u</span>
    <span class="k">print</span> <span class="s2">&quot;Initial conditions u(0)=</span><span class="si">%s</span><span class="s2">, u&#39;(0)=</span><span class="si">%s</span><span class="s2">:&quot;</span> <span class="o">%</span> \
          <span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c1"># Method of manufactured solution requires fitting f</span>
    <span class="k">global</span> <span class="n">f</span>  <span class="c1"># source term in the ODE</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">ode_lhs</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>

    <span class="c1"># Residual in discrete equations (should be 0)</span>
    <span class="k">print</span> <span class="s1">&#39;residual step1:&#39;</span><span class="p">,</span> <span class="n">residual_discrete_eq_step1</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="k">print</span> <span class="s1">&#39;residual:&#39;</span><span class="p">,</span> <span class="n">residual_discrete_eq</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">linear</span><span class="p">():</span>
    <span class="n">main</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">V</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">I</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">linear</span><span class="p">()</span>
</pre></div>
</div>
<p>Fill in the various functions such that the calls in the <code class="docutils literal"><span class="pre">main</span></code>
function works.</p>
<p><strong>d)</strong>
The purpose now is to choose a quadratic function
<span class="math">\({u_{\small\mbox{e}}} = bt^2 + ct + d\)</span> as exact solution. Extend the <code class="docutils literal"><span class="pre">sympy</span></code>
code above with a function <code class="docutils literal"><span class="pre">quadratic</span></code> for fitting <code class="docutils literal"><span class="pre">f</span></code> and checking
if the discrete equations are fulfilled. (The function is very similar
to <code class="docutils literal"><span class="pre">linear</span></code>.)</p>
<p><strong>e)</strong>
Will a polynomial of degree three fulfill the discrete equations?</p>
<p><strong>f)</strong>
Implement a <code class="docutils literal"><span class="pre">solver</span></code> function for computing the numerical
solution of this problem.</p>
<p><strong>g)</strong>
Write a test function for checking that the quadratic solution
is computed correctly (to machine precision, but the
round-off errors accumulate and increase with <span class="math">\(T\)</span>) by the <code class="docutils literal"><span class="pre">solver</span></code>
function.</p>
<p>Filename: <code class="docutils literal"><span class="pre">vib_undamped_verify_mms</span></code>.</p>
</div>
<div class="section" id="exercise-1-2-show-linear-growth-of-the-phase-with-time">
<span id="vib-exer-phase-err-growth"></span><h3>Exercise 1.2: Show linear growth of the phase with time<a class="headerlink" href="#exercise-1-2-show-linear-growth-of-the-phase-with-time" title="Permalink to this headline">¶</a></h3>
<p>Consider an exact solution <span class="math">\(I\cos (\omega t)\)</span> and an
approximation <span class="math">\(I\cos(\tilde\omega t)\)</span>.
Define the phase error as the time lag between the peak <span class="math">\(I\)</span>
in the exact solution and the corresponding peak in the approximation
after <span class="math">\(m\)</span> periods of oscillations. Show that this phase error
is linear in <span class="math">\(m\)</span>.</p>
<p>Filename: <code class="docutils literal"><span class="pre">vib_phase_error_growth</span></code>.</p>
</div>
<div class="section" id="exercise-1-3-improve-the-accuracy-by-adjusting-the-frequency">
<span id="vib-exer-w-adjust"></span><h3>Exercise 1.3: Improve the accuracy by adjusting the frequency<a class="headerlink" href="#exercise-1-3-improve-the-accuracy-by-adjusting-the-frequency" title="Permalink to this headline">¶</a></h3>
<p>According to <a class="reference internal" href="#eq-vib-ode1-tildeomega-series"><span class="std std-ref">(19)</span></a>, the numerical
frequency deviates from the exact frequency by a (dominating) amount
<span class="math">\(\omega^3\Delta t^2/24 &gt;0\)</span>. Replace the <code class="docutils literal"><span class="pre">w</span></code> parameter in the algorithm
in the <code class="docutils literal"><span class="pre">solver</span></code> function in <code class="docutils literal"><span class="pre">vib_undamped.py</span></code> by <code class="docutils literal"><span class="pre">w*(1</span> <span class="pre">-</span>
<span class="pre">(1./24)*w**2*dt**2</span></code> and test how this adjustment in the numerical
algorithm improves the accuracy (use <span class="math">\(\Delta t =0.1\)</span> and simulate
for 80 periods, with and without adjustment of <span class="math">\(\omega\)</span>).</p>
<p>Filename: <code class="docutils literal"><span class="pre">vib_adjust_w</span></code>.</p>
</div>
<div class="section" id="exercise-1-4-see-if-adaptive-methods-improve-the-phase-error">
<span id="vib-exer-undamped-adaptive"></span><h3>Exercise 1.4: See if adaptive methods improve the phase error<a class="headerlink" href="#exercise-1-4-see-if-adaptive-methods-improve-the-phase-error" title="Permalink to this headline">¶</a></h3>
<p>Adaptive methods for solving ODEs aim at adjusting <span class="math">\(\Delta t\)</span> such
that the error is within a user-prescribed tolerance. Implement the
equation <span class="math">\(u^{\prime\prime}+u=0\)</span> in the <a class="reference external" href="https://github.com/hplgit/odespy">Odespy</a>
software. Use the example <a class="reference external" href="http://hplgit.github.io/decay-book/doc/pub/book/sphinx/._book006.html#example-adaptive-runge-kutta-methods">on adaptive
schemes</a>
in <a class="reference internal" href="._book027.html#ref02" id="id10">[Ref02]</a>.  Run the scheme with a very low
tolerance (say <span class="math">\(10^{-14}\)</span>) and for a long time, check the number of
time points in the solver&#8217;s mesh (<code class="docutils literal"><span class="pre">len(solver.t_all)</span></code>), and compare
the phase error with that produced by the simple finite difference
method from the section <a class="reference internal" href="#vib-ode1-fdm"><span class="std std-ref">A centered finite difference scheme</span></a> with the same number of (equally
spaced) mesh points. The question is whether it pays off to use an
adaptive solver or if equally many points with a simple method gives
about the same accuracy.</p>
<p>Filename: <code class="docutils literal"><span class="pre">vib_undamped_adaptive</span></code>.</p>
</div>
<div class="section" id="exercise-1-5-use-a-taylor-polynomial-to-compute">
<span id="vib-exer-step4b-alt"></span><h3>Exercise 1.5: Use a Taylor polynomial to compute <span class="math">\(u^1\)</span><a class="headerlink" href="#exercise-1-5-use-a-taylor-polynomial-to-compute" title="Permalink to this headline">¶</a></h3>
<p>As an alternative to computing <span class="math">\(u^1\)</span> by <a class="reference internal" href="#eq-vib-ode1-step4b"><span class="std std-ref">(8)</span></a>,
one can use a Taylor polynomial with three terms:</p>
<div class="math">
\[u(t_1) \approx u(0) + u^{\prime}(0)\Delta t + {\frac{1}{2}}u^{\prime\prime}(0)\Delta t^2\]</div>
<p>With <span class="math">\(u^{\prime\prime}=-\omega^2 u\)</span> and <span class="math">\(u^{\prime}(0)=0\)</span>, show that this method also leads to
<a class="reference internal" href="#eq-vib-ode1-step4b"><span class="std std-ref">(8)</span></a>. Generalize the condition on <span class="math">\(u^{\prime}(0)\)</span> to
be <span class="math">\(u^{\prime}(0)=V\)</span> and compute <span class="math">\(u^1\)</span> in this case with both methods.</p>
<p>Filename: <code class="docutils literal"><span class="pre">vib_first_step</span></code>.</p>
</div>
<div class="section" id="problem-1-6-derive-and-investigate-the-velocity-verlet-method">
<h3>Problem 1.6: Derive and investigate the velocity Verlet method<a class="headerlink" href="#problem-1-6-derive-and-investigate-the-velocity-verlet-method" title="Permalink to this headline">¶</a></h3>
<p>The velocity Verlet method for <span class="math">\(u^{\prime\prime} + \omega^2u=0\)</span> is
based on the following ideas:</p>
<ol class="arabic simple">
<li>step <span class="math">\(u\)</span> forward from <span class="math">\(t_n\)</span> to <span class="math">\(t_{n+1}\)</span> using a three-term Taylor
series,</li>
<li>replace <span class="math">\(u^{\prime\prime}\)</span> by <span class="math">\(-\omega^2u\)</span></li>
<li>discretize <span class="math">\(v^{\prime}=-\omega^2u\)</span> by a Crank-Nicolson method.</li>
</ol>
<p>Derive the scheme, implement it, and determine empirically the convergence rate.</p>
</div>
<div class="section" id="problem-1-7-find-the-minimal-resolution-of-an-oscillatory-function">
<span id="vib-exer-wdt-limit"></span><h3>Problem 1.7: Find the minimal resolution of an oscillatory function<a class="headerlink" href="#problem-1-7-find-the-minimal-resolution-of-an-oscillatory-function" title="Permalink to this headline">¶</a></h3>
<p>Sketch the function on a given mesh which has the highest possible
frequency. That is, this oscillatory &#8220;cos-like&#8221; function has its
maxima and minima at every two grid points.  Find an expression for
the frequency of this function, and use the result to find the largest
relevant value of <span class="math">\(\omega\Delta t\)</span> when <span class="math">\(\omega\)</span> is the frequency
of an oscillating function and <span class="math">\(\Delta t\)</span> is the mesh spacing.</p>
<p>Filename: <code class="docutils literal"><span class="pre">vib_largest_wdt</span></code>.</p>
</div>
<div class="section" id="exercise-1-8-visualize-the-accuracy-of-finite-differences-for-a-cosine-function">
<span id="vib-exer-fd-exp-plot"></span><h3>Exercise 1.8: Visualize the accuracy of finite differences for a cosine function<a class="headerlink" href="#exercise-1-8-visualize-the-accuracy-of-finite-differences-for-a-cosine-function" title="Permalink to this headline">¶</a></h3>
<p>We introduce the error fraction</p>
<div class="math">
\[E = \frac{[D_tD_t u]^n}{u^{\prime\prime}(t_n)}\]</div>
<p>to measure the error in the finite difference approximation <span class="math">\(D_tD_tu\)</span> to
<span class="math">\(u^{\prime\prime}\)</span>.
Compute <span class="math">\(E\)</span>
for the specific choice of a cosine/sine function of the
form <span class="math">\(u=\exp{(i\omega t)}\)</span> and show that</p>
<div class="math">
\[E = \left(\frac{2}{\omega\Delta t}\right)^2
\sin^2(\frac{\omega\Delta t}{2})
{\thinspace .}\]</div>
<p>Plot <span class="math">\(E\)</span> as a function of <span class="math">\(p=\omega\Delta t\)</span>. The relevant
values of <span class="math">\(p\)</span> are <span class="math">\([0,\pi]\)</span> (see <a class="reference internal" href="#vib-exer-wdt-limit"><span class="std std-ref">Problem 1.7: Find the minimal resolution of an oscillatory function</span></a>
for why <span class="math">\(p&gt;\pi\)</span> does not make sense).
The deviation of the curve from unity visualizes the error in the
approximation. Also expand <span class="math">\(E\)</span> as a Taylor polynomial in <span class="math">\(p\)</span> up to
fourth degree (use, e.g., <code class="docutils literal"><span class="pre">sympy</span></code>).</p>
<p>Filename: <code class="docutils literal"><span class="pre">vib_plot_fd_exp_error</span></code>.</p>
</div>
<div class="section" id="exercise-1-9-verify-convergence-rates-of-the-error-in-energy">
<span id="vib-exer-energy-convrate"></span><h3>Exercise 1.9: Verify convergence rates of the error in energy<a class="headerlink" href="#exercise-1-9-verify-convergence-rates-of-the-error-in-energy" title="Permalink to this headline">¶</a></h3>
<p>We consider the ODE problem <span class="math">\(u^{\prime\prime} + \omega^2u=0\)</span>, <span class="math">\(u(0)=I\)</span>, <span class="math">\(u^{\prime}(0)=V\)</span>,
for <span class="math">\(t\in (0,T]\)</span>. The total energy of the solution
<span class="math">\(E(t)=\frac{1}{2}(u^{\prime})^2 + \frac{1}{2}\omega^2 u^2\)</span> should stay
constant.
The error in energy can be computed as explained in
the section <a class="reference internal" href="#vib-model1-energy"><span class="std std-ref">Energy considerations</span></a>.</p>
<p>Make a test function in a separate file, where code from
<code class="docutils literal"><span class="pre">vib_undamped.py</span></code> is imported, but the <code class="docutils literal"><span class="pre">convergence_rates</span></code> and
<code class="docutils literal"><span class="pre">test_convergence_rates</span></code> functions are copied and modified to also
incorporate computations of the error in energy and the convergence
rate of this error. The expected rate is 2, just as for the solution
itself.</p>
<p>Filename: <code class="docutils literal"><span class="pre">test_error_conv</span></code>.</p>
</div>
<div class="section" id="exercise-1-10-use-linear-quadratic-functions-for-verification">
<span id="vib-exer-verify-gen-linear"></span><h3>Exercise 1.10: Use linear/quadratic functions for verification<a class="headerlink" href="#exercise-1-10-use-linear-quadratic-functions-for-verification" title="Permalink to this headline">¶</a></h3>
<p>This exercise is a generalization of <a class="reference internal" href="#vib-exer-undamped-verify-linquad"><span class="std std-ref">Problem 1.1: Use linear/quadratic functions for verification</span></a> to the extended model problem
<a class="reference internal" href="._book003.html#eq-vib-ode2"><span class="std std-ref">(71)</span></a> where the damping term is either linear or quadratic.
Solve the various subproblems and see how the results and problem
settings change with the generalized ODE in case of linear or
quadratic damping. By modifying the code from <a class="reference internal" href="#vib-exer-undamped-verify-linquad"><span class="std std-ref">Problem 1.1: Use linear/quadratic functions for verification</span></a>, <code class="docutils literal"><span class="pre">sympy</span></code> will do most
of the work required to analyze the generalized problem.</p>
<p>Filename: <code class="docutils literal"><span class="pre">vib_verify_mms</span></code>.</p>
</div>
<div class="section" id="exercise-1-11-use-an-exact-discrete-solution-for-verification">
<span id="vib-exer-discrete-omega"></span><h3>Exercise 1.11: Use an exact discrete solution for verification<a class="headerlink" href="#exercise-1-11-use-an-exact-discrete-solution-for-verification" title="Permalink to this headline">¶</a></h3>
<p>Write a test function in a separate file
that employs the exact discrete solution
<a class="reference internal" href="#eq-vib-ode1-un-exact"><span class="std std-ref">(20)</span></a> to verify the implementation of the
<code class="docutils literal"><span class="pre">solver</span></code> function in the file <code class="docutils literal"><span class="pre">vib_undamped.py</span></code>.</p>
<p>Filename: <code class="docutils literal"><span class="pre">test_vib_undamped_exact_discrete_sol</span></code>.</p>
</div>
<div class="section" id="exercise-1-12-use-analytical-solution-for-convergence-rate-tests">
<span id="vib-exer-conv-rate"></span><h3>Exercise 1.12: Use analytical solution for convergence rate tests<a class="headerlink" href="#exercise-1-12-use-analytical-solution-for-convergence-rate-tests" title="Permalink to this headline">¶</a></h3>
<p>The purpose of this exercise is to perform convergence tests of the
problem <a class="reference internal" href="._book003.html#eq-vib-ode2"><span class="std std-ref">(71)</span></a> when <span class="math">\(s(u)=cu\)</span>, <span class="math">\(F(t)=A\sin\phi t\)</span> and there
is no damping.  Find the complete analytical solution to the problem
in this case (most textbooks on mechanics or ordinary differential
equations list the various elements you need to write down the exact
solution, or you can use symbolic tools like <code class="docutils literal"><span class="pre">sympy</span></code> or <code class="docutils literal"><span class="pre">wolframalpha.com</span></code>).
Modify the <code class="docutils literal"><span class="pre">convergence_rate</span></code> function from the
<code class="docutils literal"><span class="pre">vib_undamped.py</span></code> program to perform experiments with the extended
model.  Verify that the error is of order <span class="math">\(\Delta t^2\)</span>.</p>
<p>Filename: <code class="docutils literal"><span class="pre">vib_conv_rate</span></code>.</p>
</div>
<div class="section" id="exercise-1-13-investigate-the-amplitude-errors-of-many-solvers">
<span id="vib-exer-undamped-odespy"></span><h3>Exercise 1.13: Investigate the amplitude errors of many solvers<a class="headerlink" href="#exercise-1-13-investigate-the-amplitude-errors-of-many-solvers" title="Permalink to this headline">¶</a></h3>
<p>Use the program <code class="docutils literal"><span class="pre">vib_undamped_odespy.py</span></code> from the section <a class="reference internal" href="#vib-model2x2-compare"><span class="std std-ref">Comparison of schemes</span></a> (utilize the function <code class="docutils literal"><span class="pre">amplitudes</span></code>) to investigate
how well famous methods for 1st-order ODEs can preserve the amplitude of <span class="math">\(u\)</span> in undamped
oscillations.  Test, for example, the 3rd- and 4th-order Runge-Kutta
methods (<code class="docutils literal"><span class="pre">RK3</span></code>, <code class="docutils literal"><span class="pre">RK4</span></code>), the Crank-Nicolson method (<code class="docutils literal"><span class="pre">CrankNicolson</span></code>),
the 2nd- and 3rd-order Adams-Bashforth methods (<code class="docutils literal"><span class="pre">AdamsBashforth2</span></code>,
<code class="docutils literal"><span class="pre">AdamsBashforth3</span></code>), and a 2nd-order Backwards scheme
(<code class="docutils literal"><span class="pre">Backward2Step</span></code>).  The relevant governing equations are listed in
the beginning of the section <a class="reference internal" href="#vib-model2x2"><span class="std std-ref">Alternative schemes based on 1st-order equations</span></a>.</p>
<p>Running the code, we get the plots seen in Figure <a class="reference internal" href="#vib-exer-fig-ampl-rk34"><span class="std std-ref">The amplitude as it changes over 100 periods for RK3 and RK4</span></a>,
<a class="reference internal" href="#vib-exer-fig-ampl-cnb2"><span class="std std-ref">The amplitude as it changes over 100 periods for Crank-Nicolson and Backward 2 step</span></a>, and <a class="reference internal" href="#vib-exer-fig-ampl-ab"><span class="std std-ref">The amplitude as it changes over 100 periods for Adams-Bashforth 2 and 3</span></a>. They
show that <code class="docutils literal"><span class="pre">RK4</span></code> is superior to the others, but that also <code class="docutils literal"><span class="pre">CrankNicolson</span></code> performs well. In fact, with <code class="docutils literal"><span class="pre">RK4</span></code> the amplitude changes by less than <span class="math">\(0.1\)</span> per cent over the interval.</p>
<div class="figure" id="id23">
<span id="vib-exer-fig-ampl-rk34"></span><a class="reference internal image-reference" href="_images/Amplitudes_RK3_RK4.png"><img alt="_images/Amplitudes_RK3_RK4.png" src="_images/Amplitudes_RK3_RK4.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>The amplitude as it changes over 100 periods for RK3 and RK4</em></span></p>
</div>
<div class="figure" id="id24">
<span id="vib-exer-fig-ampl-cnb2"></span><a class="reference internal image-reference" href="_images/Amplitudes_CrankNicolson_Backward2Step.png"><img alt="_images/Amplitudes_CrankNicolson_Backward2Step.png" src="_images/Amplitudes_CrankNicolson_Backward2Step.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>The amplitude as it changes over 100 periods for Crank-Nicolson and Backward 2 step</em></span></p>
</div>
<div class="figure" id="id25">
<span id="vib-exer-fig-ampl-ab"></span><a class="reference internal image-reference" href="_images/Amplitudes_AdamsBashforth2_AdamsBashforth3.png"><img alt="_images/Amplitudes_AdamsBashforth2_AdamsBashforth3.png" src="_images/Amplitudes_AdamsBashforth2_AdamsBashforth3.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>The amplitude as it changes over 100 periods for Adams-Bashforth 2 and 3</em></span></p>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">vib_amplitude_errors</span></code>.</p>
</div>
<div class="section" id="problem-1-14-minimize-memory-usage-of-a-simple-vibration-solver">
<span id="vib-exer-memsave0"></span><h3>Problem 1.14: Minimize memory usage of a simple vibration solver<a class="headerlink" href="#problem-1-14-minimize-memory-usage-of-a-simple-vibration-solver" title="Permalink to this headline">¶</a></h3>
<p>We consider the model problem <span class="math">\(u''+\omega^2 u = 0\)</span>, <span class="math">\(u(0)=I\)</span>, <span class="math">\(u'(0)=V\)</span>,
solved by a second-order finite difference scheme. A standard implementation
typically employs an array <code class="docutils literal"><span class="pre">u</span></code> for storing all the <span class="math">\(u^n\)</span> values. However,
at some time level <code class="docutils literal"><span class="pre">n+1</span></code> where we want to compute <code class="docutils literal"><span class="pre">u[n+1]</span></code>, all we need
of previous <code class="docutils literal"><span class="pre">u</span></code> values are from level <code class="docutils literal"><span class="pre">n</span></code> and <code class="docutils literal"><span class="pre">n-1</span></code>. We can therefore avoid
storing the entire array <code class="docutils literal"><span class="pre">u</span></code>, and instead work with <code class="docutils literal"><span class="pre">u[n+1]</span></code>, <code class="docutils literal"><span class="pre">u[n],</span></code>
and <code class="docutils literal"><span class="pre">u[n-1]</span></code>, named as <code class="docutils literal"><span class="pre">u</span></code>, <code class="docutils literal"><span class="pre">u_n</span></code>, <code class="docutils literal"><span class="pre">u_nmp1</span></code>, for instance. Another
possible naming convention is <code class="docutils literal"><span class="pre">u</span></code>, <code class="docutils literal"><span class="pre">u_n[0]</span></code>, <code class="docutils literal"><span class="pre">u_n[-1]</span></code>.
Store the solution in a file
for later visualization. Make a test function that verifies the implementation
by comparing with the another code for the same problem.</p>
<p>Filename: <code class="docutils literal"><span class="pre">vib_memsave0</span></code>.</p>
</div>
<div class="section" id="problem-1-15-minimize-memory-usage-of-a-general-vibration-solver">
<span id="vib-exer-memsave"></span><h3>Problem 1.15: Minimize memory usage of a general vibration solver<a class="headerlink" href="#problem-1-15-minimize-memory-usage-of-a-general-vibration-solver" title="Permalink to this headline">¶</a></h3>
<p>The program <a class="reference external" href="http://tinyurl.com/nu656p2/vib/vib.py">vib.py</a> stores the complete
solution <span class="math">\(u^0,u^1,\ldots,u^{N_t}\)</span> in memory, which is convenient for
later plotting.  Make a memory minimizing version of this program
where only the last three <span class="math">\(u^{n+1}\)</span>, <span class="math">\(u^n\)</span>, and <span class="math">\(u^{n-1}\)</span> values are
stored in memory under the names <code class="docutils literal"><span class="pre">u</span></code>, <code class="docutils literal"><span class="pre">u_n</span></code>, and <code class="docutils literal"><span class="pre">u_nm1</span></code> (this is the
naming convention used in this book).
Write each computed <span class="math">\((t_{n+1}, u^{n+1})\)</span> pair to
file.  Visualize the data in the file (a cool solution is to read one
line at a time and plot the <span class="math">\(u\)</span> value using the line-by-line plotter
in the <code class="docutils literal"><span class="pre">visualize_front_ascii</span></code> function - this technique makes it
trivial to visualize very long time simulations).</p>
<p>Filename: <code class="docutils literal"><span class="pre">vib_memsave</span></code>.</p>
</div>
<div class="section" id="exercise-1-16-implement-the-euler-cromer-scheme-for-the-generalized-model">
<span id="vib-exer-ec-vs-centered"></span><h3>Exercise 1.16: Implement the Euler-Cromer scheme for the generalized model<a class="headerlink" href="#exercise-1-16-implement-the-euler-cromer-scheme-for-the-generalized-model" title="Permalink to this headline">¶</a></h3>
<p>We consider the generalized model problem</p>
<div class="math">
\[mu'' + f(u') + s(u) = F(t),\quad u(0)=I,\ u'(0)=V{\thinspace .}\]</div>
<p><strong>a)</strong>
Implement the Euler-Cromer method from the section <a class="reference internal" href="._book003.html#vib-ode2-eulercromer"><span class="std std-ref">The Euler-Cromer scheme for the generalized model</span></a>.</p>
<p><strong>b)</strong>
We expect the Euler-Cromer method to have first-order convergence rate.
Make a unit test based on this expectation.</p>
<p><strong>c)</strong>
Consider a system with <span class="math">\(m=4\)</span>, <span class="math">\(f(v)=b|v|v\)</span>, <span class="math">\(b=0.2\)</span>, <span class="math">\(s=2u\)</span>, <span class="math">\(F=0\)</span>.
Compute the solution using the centered difference scheme
from the section <a class="reference internal" href="._book003.html#vib-ode2-fdm-flin"><span class="std std-ref">A centered scheme for linear damping</span></a> and the Euler-Cromer scheme
for the longest possible time step <span class="math">\(\Delta t\)</span>. We can use the
result from the case without damping, i.e., the largest <span class="math">\(\Delta t= 2/\omega\)</span>,
<span class="math">\(\omega\approx
\sqrt{0.5}\)</span> in this case, but since <span class="math">\(b\)</span> will modify the frequency, we
take the longest possible time step as a safety factor 0.9 times <span class="math">\(2/\omega\)</span>.
Refine <span class="math">\(\Delta t\)</span> three times by a factor of two and compare the
two curves.</p>
<p>Filename: <code class="docutils literal"><span class="pre">vib_EulerCromer</span></code>.</p>
</div>
<div class="section" id="problem-1-17-interpret-as-a-forward-backward-difference">
<span id="vib-exer-dtdt-asdtpdtm"></span><h3>Problem 1.17: Interpret <span class="math">\([D_tD_t u]^n\)</span> as a forward-backward difference<a class="headerlink" href="#problem-1-17-interpret-as-a-forward-backward-difference" title="Permalink to this headline">¶</a></h3>
<p>Show that the difference <span class="math">\([D_t D_tu]^n\)</span> is equal to <span class="math">\([D_t^+D_t^-u]^n\)</span>
and <span class="math">\(D_t^-D_t^+u]^n\)</span>. That is, instead of applying a centered difference
twice one can alternatively apply a mixture of forward and backward
differences.</p>
<p>Filename: <code class="docutils literal"><span class="pre">vib_DtDt_fw_bw</span></code>.</p>
</div>
<div class="section" id="exercise-1-18-analysis-of-the-euler-cromer-scheme">
<span id="vib-exer-eulercromer-analysis"></span><h3>Exercise 1.18: Analysis of the Euler-Cromer scheme<a class="headerlink" href="#exercise-1-18-analysis-of-the-euler-cromer-scheme" title="Permalink to this headline">¶</a></h3>
<p>The Euler-Cromer scheme for the model problem
<span class="math">\(u^{\prime\prime} + \omega^2 u =0\)</span>, <span class="math">\(u(0)=I\)</span>, <span class="math">\(u^{\prime}(0)=0\)</span>, is given in
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><span class="std std-ref">(55)</span></a>-<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1b"><span class="std std-ref">(54)</span></a>.
Find the exact discrete solutions of this scheme and show that the solution
for <span class="math">\(u^n\)</span> coincides with that found in the section <a class="reference internal" href="#vib-ode1-analysis"><span class="std std-ref">Analysis of the numerical scheme</span></a>.</p>
<p><strong>Hint.</strong>
Use an &#8220;ansatz&#8221; <span class="math">\(u^n=I\exp{(i\tilde\omega\Delta t\,n)}\)</span> and
<span class="math">\(v^n=qu^n\)</span>, where <span class="math">\(\tilde\omega\)</span> and <span class="math">\(q\)</span> are unknown parameters. The
following formula is handy:</p>
<div class="math">
\[\boldsymbol{e}^{i\tilde\omega\Delta t} + e^{i\tilde\omega(-\Delta t)} - 2
= 2\left(\cosh(i\tilde\omega\Delta t) -1 \right)
=-4\sin^2(\frac{\tilde\omega\Delta t}{2}){\thinspace .}\]</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Vibration ODEs</a><ul>
<li><a class="reference internal" href="#finite-difference-discretization-1">Finite difference discretization</a><ul>
<li><a class="reference internal" href="#a-basic-model-for-vibrations">A basic model for vibrations</a></li>
<li><a class="reference internal" href="#a-centered-finite-difference-scheme-1">A centered finite difference scheme</a><ul>
<li><a class="reference internal" href="#step-1-discretizing-the-domain">Step 1: Discretizing the domain</a></li>
<li><a class="reference internal" href="#step-2-fulfilling-the-equation-at-discrete-time-points">Step 2: Fulfilling the equation at discrete time points</a></li>
<li><a class="reference internal" href="#step-3-replacing-derivatives-by-finite-differences">Step 3: Replacing derivatives by finite differences</a></li>
<li><a class="reference internal" href="#step-4-formulating-a-recursive-algorithm">Step 4: Formulating a recursive algorithm</a></li>
<li><a class="reference internal" href="#computing-the-first-step">Computing the first step</a></li>
<li><a class="reference internal" href="#the-computational-algorithm">The computational algorithm</a></li>
<li><a class="reference internal" href="#operator-notation">Operator notation</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-1">Implementation</a><ul>
<li><a class="reference internal" href="#making-a-solver-function">Making a solver function</a><ul>
<li><a class="reference internal" href="#computing">Computing <span class="math">\(u^{\prime}\)</span></a></li>
</ul>
</li>
<li><a class="reference internal" href="#verification-1">Verification</a><ul>
<li><a class="reference internal" href="#manual-calculation">Manual calculation</a></li>
<li><a class="reference internal" href="#testing-very-simple-polynomial-solutions">Testing very simple polynomial solutions</a></li>
<li><a class="reference internal" href="#checking-convergence-rates-1">Checking convergence rates</a></li>
<li><a class="reference internal" href="#visualizing-convergence-rates-with-slope-markers">Visualizing convergence rates with slope markers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#scaled-model">Scaled model</a></li>
</ul>
</li>
<li><a class="reference internal" href="#visualization-of-long-time-simulations">Visualization of long time simulations</a><ul>
<li><a class="reference internal" href="#using-a-moving-plot-window">Using a moving plot window</a></li>
<li><a class="reference internal" href="#making-animations">Making animations</a><ul>
<li><a class="reference internal" href="#producing-standard-video-formats">Producing standard video formats</a></li>
<li><a class="reference internal" href="#playing-png-files-in-a-web-browser">Playing PNG files in a web browser</a></li>
<li><a class="reference internal" href="#making-animated-gif-files">Making animated GIF files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-bokeh-to-compare-graphs">Using Bokeh to compare graphs</a></li>
<li><a class="reference internal" href="#using-a-line-by-line-ascii-plotter">Using a line-by-line ascii plotter</a></li>
<li><a class="reference internal" href="#empirical-analysis-of-the-solution">Empirical analysis of the solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#analysis-of-the-numerical-scheme">Analysis of the numerical scheme</a><ul>
<li><a class="reference internal" href="#deriving-a-solution-of-the-numerical-scheme">Deriving a solution of the numerical scheme</a></li>
<li><a class="reference internal" href="#the-error-in-the-numerical-frequency">The error in the numerical frequency</a></li>
<li><a class="reference internal" href="#empirical-convergence-rates-and-adjusted">Empirical convergence rates and adjusted <span class="math">\(\omega\)</span></a></li>
<li><a class="reference internal" href="#exact-discrete-solution">Exact discrete solution</a></li>
<li><a class="reference internal" href="#convergence">Convergence</a></li>
<li><a class="reference internal" href="#the-global-error">The global error</a></li>
<li><a class="reference internal" href="#stability-1">Stability</a></li>
<li><a class="reference internal" href="#about-the-accuracy-at-the-stability-limit">About the accuracy at the stability limit</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alternative-schemes-based-on-1st-order-equations">Alternative schemes based on 1st-order equations</a><ul>
<li><a class="reference internal" href="#the-forward-euler-scheme-1">The Forward Euler scheme</a></li>
<li><a class="reference internal" href="#the-backward-euler-scheme-1">The Backward Euler scheme</a></li>
<li><a class="reference internal" href="#the-crank-nicolson-scheme-1">The Crank-Nicolson scheme</a></li>
<li><a class="reference internal" href="#comparison-of-schemes">Comparison of schemes</a></li>
<li><a class="reference internal" href="#runge-kutta-methods">Runge-Kutta methods</a></li>
<li><a class="reference internal" href="#analysis-of-the-forward-euler-scheme-1">Analysis of the Forward Euler scheme</a></li>
</ul>
</li>
<li><a class="reference internal" href="#energy-considerations">Energy considerations</a><ul>
<li><a class="reference internal" href="#derivation-of-the-energy-expression">Derivation of the energy expression</a><ul>
<li><a class="reference internal" href="#energy-of-the-exact-solution">Energy of the exact solution</a></li>
<li><a class="reference internal" href="#growth-of-energy-in-the-forward-euler-scheme">Growth of energy in the Forward Euler scheme</a></li>
</ul>
</li>
<li><a class="reference internal" href="#an-error-measure-based-on-energy">An error measure based on energy</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-euler-cromer-method">The Euler-Cromer method</a><ul>
<li><a class="reference internal" href="#forward-backward-discretization">Forward-backward discretization</a></li>
<li><a class="reference internal" href="#equivalence-with-the-scheme-for-the-second-order-ode">Equivalence with the scheme for the second-order ODE</a></li>
<li><a class="reference internal" href="#implementation-2">Implementation</a><ul>
<li><a class="reference internal" href="#solver-function">Solver function</a></li>
<li><a class="reference internal" href="#verification-2">Verification</a></li>
<li><a class="reference internal" href="#using-odespy">Using Odespy</a></li>
<li><a class="reference internal" href="#convergence-rates-1">Convergence rates</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-stoermer-verlet-algorithm">The Stoermer-Verlet algorithm</a></li>
</ul>
</li>
<li><a class="reference internal" href="#staggered-mesh">Staggered mesh</a><ul>
<li><a class="reference internal" href="#the-euler-cromer-scheme-on-a-staggered-mesh">The Euler-Cromer scheme on a staggered mesh</a></li>
<li><a class="reference internal" href="#implementation-of-the-scheme-on-a-staggered-mesh">Implementation of the scheme on a staggered mesh</a><ul>
<li><a class="reference internal" href="#implementation-with-integer-indices">Implementation with integer indices</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#exercises-and-problems-1">Exercises and Problems</a><ul>
<li><a class="reference internal" href="#problem-1-1-use-linear-quadratic-functions-for-verification">Problem 1.1: Use linear/quadratic functions for verification</a></li>
<li><a class="reference internal" href="#exercise-1-2-show-linear-growth-of-the-phase-with-time">Exercise 1.2: Show linear growth of the phase with time</a></li>
<li><a class="reference internal" href="#exercise-1-3-improve-the-accuracy-by-adjusting-the-frequency">Exercise 1.3: Improve the accuracy by adjusting the frequency</a></li>
<li><a class="reference internal" href="#exercise-1-4-see-if-adaptive-methods-improve-the-phase-error">Exercise 1.4: See if adaptive methods improve the phase error</a></li>
<li><a class="reference internal" href="#exercise-1-5-use-a-taylor-polynomial-to-compute">Exercise 1.5: Use a Taylor polynomial to compute <span class="math">\(u^1\)</span></a></li>
<li><a class="reference internal" href="#problem-1-6-derive-and-investigate-the-velocity-verlet-method">Problem 1.6: Derive and investigate the velocity Verlet method</a></li>
<li><a class="reference internal" href="#problem-1-7-find-the-minimal-resolution-of-an-oscillatory-function">Problem 1.7: Find the minimal resolution of an oscillatory function</a></li>
<li><a class="reference internal" href="#exercise-1-8-visualize-the-accuracy-of-finite-differences-for-a-cosine-function">Exercise 1.8: Visualize the accuracy of finite differences for a cosine function</a></li>
<li><a class="reference internal" href="#exercise-1-9-verify-convergence-rates-of-the-error-in-energy">Exercise 1.9: Verify convergence rates of the error in energy</a></li>
<li><a class="reference internal" href="#exercise-1-10-use-linear-quadratic-functions-for-verification">Exercise 1.10: Use linear/quadratic functions for verification</a></li>
<li><a class="reference internal" href="#exercise-1-11-use-an-exact-discrete-solution-for-verification">Exercise 1.11: Use an exact discrete solution for verification</a></li>
<li><a class="reference internal" href="#exercise-1-12-use-analytical-solution-for-convergence-rate-tests">Exercise 1.12: Use analytical solution for convergence rate tests</a></li>
<li><a class="reference internal" href="#exercise-1-13-investigate-the-amplitude-errors-of-many-solvers">Exercise 1.13: Investigate the amplitude errors of many solvers</a></li>
<li><a class="reference internal" href="#problem-1-14-minimize-memory-usage-of-a-simple-vibration-solver">Problem 1.14: Minimize memory usage of a simple vibration solver</a></li>
<li><a class="reference internal" href="#problem-1-15-minimize-memory-usage-of-a-general-vibration-solver">Problem 1.15: Minimize memory usage of a general vibration solver</a></li>
<li><a class="reference internal" href="#exercise-1-16-implement-the-euler-cromer-scheme-for-the-generalized-model">Exercise 1.16: Implement the Euler-Cromer scheme for the generalized model</a></li>
<li><a class="reference internal" href="#problem-1-17-interpret-as-a-forward-backward-difference">Problem 1.17: Interpret <span class="math">\([D_tD_t u]^n\)</span> as a forward-backward difference</a></li>
<li><a class="reference internal" href="#exercise-1-18-analysis-of-the-euler-cromer-scheme">Exercise 1.18: Analysis of the Euler-Cromer scheme</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._book001.html"
                        title="previous chapter">Preface</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._book003.html"
                        title="next chapter">Generalization: damping, nonlinearities, and excitation</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._book002.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._book003.html" title="Generalization: damping, nonlinearities, and excitation"
             >next</a> |</li>
        <li class="right" >
          <a href="._book001.html" title="Preface"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with PDEs</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2016, Hans Petter Langtangen, Svein Linge. Released under CC Attribution 4.0 license.
  </div>
</div>

  </body>
</html>