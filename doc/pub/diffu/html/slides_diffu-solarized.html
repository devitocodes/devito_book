<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Study guide: Finite difference schemes for diffusion processes">
<meta name="keywords" content="diffusion equation, 1D,heat equation, 1D,mesh finite differences,stencil 1D diffusion equation,mesh function">

<title>Study guide: Finite difference schemes for diffusion processes</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('The 1D diffusion equation', 1, None, '___sec0'),
              ('The initial-boundary value problem for 1D diffusion',
               2,
               None,
               '___sec1'),
              ('Step 1: Discretizing the domain',
               2,
               'diffu:1D:mesh',
               'diffu:1D:mesh'),
              ('The discrete solution',
               2,
               'diffu:1D:numerical:sol',
               'diffu:1D:numerical:sol'),
              ('Step 2: Fulfilling the equation at the mesh points',
               2,
               'diffu:1D:samplingPDE',
               'diffu:1D:samplingPDE'),
              ('Step 3: Replacing derivatives by finite differences',
               2,
               'diffu:1D:fd',
               'diffu:1D:fd'),
              ('Step 4: Formulating a recursive algorithm',
               2,
               'diffu:1D:alg',
               'diffu:1D:alg'),
              ('The mesh Fourier number', 2, None, '___sec7'),
              ('The finite difference stencil', 2, None, '___sec8'),
              ('The computational algorithm for the Forward Euler scheme',
               2,
               None,
               '___sec9'),
              ('The Python implementation of the computational algorithm',
               2,
               None,
               '___sec10'),
              ('Moving finite difference stencil', 2, None, '___sec11'),
              ('Demo program', 2, None, '___sec12'),
              ('Forward Euler applied to an initial plug profile',
               2,
               None,
               '___sec13'),
              ('Forward Euler applied to a Gaussian profile',
               2,
               None,
               '___sec14'),
              ('Backward Euler scheme', 2, 'diffu:pde1:BE', 'diffu:pde1:BE'),
              ("Let's write out the equations for $N_x=3$",
               2,
               None,
               '___sec16'),
              ('Two classes of discretization methods: explicit and implicit',
               2,
               None,
               '___sec17'),
              ('The linear system for a general $N_x$', 2, None, '___sec18'),
              ('$A$ is very sparse: a tridiagonal matrix',
               2,
               None,
               '___sec19'),
              ('Detailed expressions for the matrix entries',
               2,
               None,
               '___sec20'),
              ('The right-hand side', 2, None, '___sec21'),
              ('Naive Python implementation with a dense $(N_x+1)\\times(N_x+1)$ matrix',
               2,
               None,
               '___sec22'),
              ('A sparse matrix representation will dramatically reduce the computational complexity',
               2,
               'diffu:pde1:impl:sparse',
               'diffu:pde1:impl:sparse'),
              ('Computing the sparse matrix', 2, None, '___sec24'),
              ('Backward Euler applied to a plug profile',
               2,
               None,
               '___sec25'),
              ('Backward Euler applied to a Gaussian profile',
               2,
               None,
               '___sec26'),
              ('Crank-Nicolson scheme', 2, None, '___sec27'),
              ('Averaging in time is necessary in the Crank-Nicolson scheme',
               2,
               None,
               '___sec28'),
              ('Crank-Nicolsoon scheme written out', 2, None, '___sec29'),
              ('Crank-Nicolson applied to a plug profile',
               2,
               None,
               '___sec30'),
              ('Crank-Nicolson applied to a Gaussian profile',
               2,
               None,
               '___sec31'),
              ('The $\\theta$ rule',
               2,
               'diffu:pde1:theta',
               'diffu:pde1:theta'),
              ('The Laplace and Poisson equation', 2, None, '___sec33'),
              ('We can solve 1D Poisson/Laplace equation by going to infinity in time-dependent diffusion equations',
               2,
               None,
               '___sec34'),
              ('Extensions', 2, None, '___sec35'),
              ('Analysis of schemes for the diffusion equation',
               1,
               'diffu:pde1:analysis',
               'diffu:pde1:analysis'),
              ('Properties of the solution',
               2,
               'diffu:pde1:analysis:uex',
               'diffu:pde1:analysis:uex'),
              ('Example', 2, None, '___sec38'),
              ('High frequency components of the solution are very quickly damped',
               2,
               None,
               '___sec39'),
              ('Damping of a discontinuity; problem', 2, None, '___sec40'),
              ('Damping of a discontinuity; model', 2, None, '___sec41'),
              ('Damping of a discontinuity; Backward Euler scheme',
               2,
               None,
               '___sec42'),
              ('Damping of a discontinuity; Backward Euler simulation $F=\\half$',
               2,
               None,
               '___sec43'),
              ('Damping of a discontinuity; Forward Euler scheme',
               2,
               None,
               '___sec44'),
              ('Damping of a discontinuity; Forward Euler simulation $F=\\half$',
               2,
               None,
               '___sec45'),
              ('Damping of a discontinuity; Crank-Nicolson scheme',
               2,
               None,
               '___sec46'),
              ('Damping of a discontinuity; Crank-Nicolson simulation $F=5$',
               2,
               None,
               '___sec47'),
              ('Fourier representation', 2, None, '___sec48'),
              ('Analysis of the finite difference schemes',
               2,
               'diffu:pde1:analysis:summary',
               'diffu:pde1:analysis:summary'),
              ('Analysis of the Forward Euler scheme',
               2,
               'diffu:pde1:analysis:FE',
               'diffu:pde1:analysis:FE'),
              ('Results for stability', 2, None, '___sec51'),
              ('Analysis of the Backward Euler scheme',
               2,
               'diffu:pde1:analysis:BE',
               'diffu:pde1:analysis:BE'),
              ('Analysis of the Crank-Nicolson scheme',
               2,
               'diffu:pde1:analysis:CN',
               'diffu:pde1:analysis:CN'),
              ('Summary of amplification factors', 2, None, '___sec54'),
              ('Summary of accuracy of amplification factors; large time steps',
               2,
               None,
               '___sec55'),
              ('Summary of accuracy of amplification factors; time steps around the Forward Euler stability limit',
               2,
               None,
               '___sec56'),
              ('Summary of accuracy of amplification factors; small time steps',
               2,
               None,
               '___sec57'),
              ('Observations', 2, None, '___sec58')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
$$




    
<!-- ------------------- main content ---------------------- -->



<center><h1>Study guide: Finite difference schemes for diffusion processes</h1></center>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen, and Svein Linge -->

<center>
<b>Hans Petter Langtangen</b> [1, 2]
</center>

<center>
<b>Svein Linge</b> [3, 1]
</center>

<p>
<!-- institution(s) -->

<center>[1] <b>Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b>Department of Informatics, University of Oslo</b></center>
<center>[3] <b>Department of Process, Energy and Environmental Technology, University College of Southeast Norway</b></center>
<br>
<p>
<center><h4>Aug 15, 2017</h4></center> <!-- date -->
<br>
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Table of contents</h2>

<p>
<a href="#___sec0"> The 1D diffusion equation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec1"> The initial-boundary value problem for 1D diffusion </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:1D:mesh"> Step 1: Discretizing the domain </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:1D:numerical:sol"> The discrete solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:1D:samplingPDE"> Step 2: Fulfilling the equation at the mesh points </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:1D:fd"> Step 3: Replacing derivatives by finite differences </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:1D:alg"> Step 4: Formulating a recursive algorithm </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec7"> The mesh Fourier number </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec8"> The finite difference stencil </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec9"> The computational algorithm for the Forward Euler scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec10"> The Python implementation of the computational algorithm </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec11"> Moving finite difference stencil </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec12"> Demo program </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec13"> Forward Euler applied to an initial plug profile </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec14"> Forward Euler applied to a Gaussian profile </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:pde1:BE"> Backward Euler scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec16"> Let's write out the equations for \( N_x=3 \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec17"> Two classes of discretization methods: explicit and implicit </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec18"> The linear system for a general \( N_x \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec19"> \( A \) is very sparse: a tridiagonal matrix </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec20"> Detailed expressions for the matrix entries </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec21"> The right-hand side </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec22"> Naive Python implementation with a dense \( (N_x+1)\times(N_x+1) \) matrix </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:pde1:impl:sparse"> A sparse matrix representation will dramatically reduce the computational complexity </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec24"> Computing the sparse matrix </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec25"> Backward Euler applied to a plug profile </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec26"> Backward Euler applied to a Gaussian profile </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec27"> Crank-Nicolson scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec28"> Averaging in time is necessary in the Crank-Nicolson scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec29"> Crank-Nicolsoon scheme written out </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec30"> Crank-Nicolson applied to a plug profile </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec31"> Crank-Nicolson applied to a Gaussian profile </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:pde1:theta"> The \( \theta \) rule </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec33"> The Laplace and Poisson equation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec34"> We can solve 1D Poisson/Laplace equation by going to infinity in time-dependent diffusion equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec35"> Extensions </a><br>
<a href="#diffu:pde1:analysis"> Analysis of schemes for the diffusion equation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:pde1:analysis:uex"> Properties of the solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec38"> Example </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec39"> High frequency components of the solution are very quickly damped </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec40"> Damping of a discontinuity; problem </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec41"> Damping of a discontinuity; model </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec42"> Damping of a discontinuity; Backward Euler scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec43"> Damping of a discontinuity; Backward Euler simulation \( F=\half \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec44"> Damping of a discontinuity; Forward Euler scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec45"> Damping of a discontinuity; Forward Euler simulation \( F=\half \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec46"> Damping of a discontinuity; Crank-Nicolson scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec47"> Damping of a discontinuity; Crank-Nicolson simulation \( F=5 \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec48"> Fourier representation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:pde1:analysis:summary"> Analysis of the finite difference schemes </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:pde1:analysis:FE"> Analysis of the Forward Euler scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec51"> Results for stability </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:pde1:analysis:BE"> Analysis of the Backward Euler scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:pde1:analysis:CN"> Analysis of the Crank-Nicolson scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec54"> Summary of amplification factors </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec55"> Summary of accuracy of amplification factors; large time steps </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec56"> Summary of accuracy of amplification factors; time steps around the Forward Euler stability limit </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec57"> Summary of accuracy of amplification factors; small time steps </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec58"> Observations </a><br>
</p>
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h1 id="___sec0">The 1D diffusion equation </h1>

<p>
The famous <em>diffusion equation</em>, also known as the <em>heat equation</em>,
reads

$$ \frac{\partial u}{\partial t} =
\dfc \frac{\partial^2 u}{\partial x^2}
$$

<p>
Here,

<ul>
 <p><li> \( u(x,t) \): unknown</li>
 <p><li> \( \dfc \): <em>diffusion coefficient</em></li>
</ul>

Alternative, compact notation:

$$ u_t = \dfc u_{xx} $$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec1">The initial-boundary value problem for 1D diffusion </h2>

$$
\begin{align}
\frac{\partial u}{\partial t} &=
\dfc \frac{\partial^2 u}{\partial x^2}, \quad x\in (0,L),\ t\in (0,T]
\label{diffu:pde1}\\ 
u(x,0) &= I(x), \quad  x\in [0,L]
\label{diffu:pde1:ic:u}\\ 
u(0,t) & = 0, \quad  t>0,
\label{diffu:pde1:bc:0}\\ 
u(L,t) & = 0, \quad  t>0\tp
\label{diffu:pde1:bc:L}
\end{align}
$$

<p>
Note:

<ul>
 <p><li> First-order derivative in time: one initial condition</li>
 <p><li> Second-order derivative in space: a boundary condition at each
   point of the boundary (2 points in 1D)</li>
 <p><li> Numerous applications throughout physics and biology</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="diffu:1D:mesh">Step 1: Discretizing the domain</h2>

<p>
Mesh in time:

$$
\begin{equation}
0 = t_0 < t_1 < t_2 < \cdots < t_{N_t-1} < t_{N_t} = T    \label{_auto1}
\end{equation}
$$

<p>
Mesh in space:

$$
\begin{equation}
0 = x_0 < x_1 < x_2 < \cdots < x_{N_x-1} < x_{N_x} = L    \label{_auto2}
\end{equation}
$$

<p>
Uniform mesh with constant mesh spacings \( \Delta t \) and \( \Delta x \):

$$
\begin{equation}
x_i = i\Delta x,\ i=0,\ldots,N_x,\quad
t_i = n\Delta t,\ n=0,\ldots,N_t
\label{_auto3}
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="diffu:1D:numerical:sol">The discrete solution</h2>

<ul>
 <p><li> The numerical solution is a mesh function: \( u_i^n \approx \uex(x_i,t_n) \)</li>
 <p><li> Finite difference stencil (or scheme): equation for \( u^n_i \) involving
   neighboring space-time points</li>
</ul>

<center><p><img src="mov-diffu/D_stencil_gpl/stencil_n_interior.png" align="bottom" width=500></p></center>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="diffu:1D:samplingPDE">Step 2: Fulfilling the equation at the mesh points</h2>

<p>
Require the PDE \eqref{diffu:pde1} to be fulfilled at an arbitrary
<em>interior mesh point</em> \( (x_i,t_n) \)
leads to

$$
\begin{equation}
\frac{\partial}{\partial t} u(x_i, t_n) =
\dfc\frac{\partial^2}{\partial x^2} u(x_i, t_n)
\label{diffu:pde1:step2}
\end{equation}
$$

<p>
Applies to all interior mesh points: \( i=1,\ldots,N_x-1 \) and \( n=1,\ldots,N_t-1 \)

<p>
For \( n=0 \) we have the initial conditions \( u=I(x) \) and \( u_t=0 \)

<p>
At the boundaries \( i=0,N_x \) we have the boundary condition \( u=0 \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="diffu:1D:fd">Step 3: Replacing derivatives by finite differences</h2>

<p>
Use a forward difference in time and a centered difference in space
(<em>Forward Euler</em> scheme):

$$
\begin{equation}
[D_t^+ u = \dfc D_xD_x u]^n_i
\label{diffu:pde1:step3a}
\end{equation}
$$

<p>
Written out,

$$
\begin{equation}
\frac{u^{n+1}_i-u^n_i}{\Delta t} = \dfc \frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2}
\label{diffu:pde1:step3b}
\end{equation}
$$

<p>
Initial condition: \( u^0_i = I(x_i) \), \( i=0,1,\ldots,N_x \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="diffu:1D:alg">Step 4: Formulating a recursive algorithm</h2>

<ul>
 <p><li> Nature of the algorithm: compute \( u \) in space at \( t=\Delta t, 2\Delta t, 3\Delta t,... \)</li>
 <p><li> Two time levels are involved in the general discrete equation:
   \( n+1 \) and \( n \)</li>
 <p><li> \( u^n_i \) is already computed for \( i=0,\ldots,N_x \),
   and \( u^{n+1}_i \) is the unknown quantity</li>
</ul>

Solve the discretized PDE for the unknown \( u^{n+1}_i \):

$$
\begin{equation}
u^{n+1}_i = u^n_i + F\left(
u^{n}_{i+1} - 2u^n_i + u^n_{i-1}\right)
\label{diffu:pde1:step4}
\end{equation}
$$

<p>
where

$$ F = \dfc\frac{\Delta t}{\Delta x^2} $$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec7">The mesh Fourier number </h2>

$$ F = \dfc\frac{\Delta t}{\Delta x^2} $$

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Observe.</b>
<p>
There is only one parameter, \( F \), in the discrete model:
\( F \) lumps mesh parameters \( \Delta t \) and \( \Delta x \)
with the only physical parameter, the diffusion coefficient
\( \dfc \).
The value \( F \) and the smoothness of \( I(x) \)
govern the quality of the numerical solution.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec8">The finite difference stencil </h2>

<p>
<center><p><img src="mov-diffu/D_stencil_gpl/stencil_n_interior.png" align="bottom" width=500></p></center>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec9">The computational algorithm for the Forward Euler scheme </h2>

<ol>
 <p><li> compute \( u^0_i=I(x_i) \), \( i=0,\ldots,N_x \)</li>
 <p><li> for \( n=0,1,\ldots,N_t \):

<ol type="a"></li>
   <p><li> compute \( u^{n+1}_i \) from \eqref{diffu:pde1:step4} for all the internal
      spatial points \( i=1,\ldots,N_x-1 \)</li>
   <p><li> set the boundary values
      \( u^{n+1}_i=0 \) for \( i=0 \) and \( i=N_x \)</li>
</ol>

</ol>

<div class="alert alert-block alert-notice alert-text-normal">
<b>Notice.</b>
<p>
We visit one mesh point \( (x_i,t_{n+1}) \) at a time,
and we have an explicit formula
for computing the associated \( u^{n+1}_i \) value.
The spatial points can be updated in any sequence, but the
time levels \( t_n \) must be updated in cronological order: \( t_n \) before
\( t_{n+1} \).
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec10">The Python implementation of the computational algorithm </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span></span>x = linspace(<span style="color: #B452CD">0</span>, L, Nx+<span style="color: #B452CD">1</span>)    <span style="color: #228B22"># mesh points in space</span>
dx = x[<span style="color: #B452CD">1</span>] - x[<span style="color: #B452CD">0</span>]
t = linspace(<span style="color: #B452CD">0</span>, T, Nt+<span style="color: #B452CD">1</span>)    <span style="color: #228B22"># mesh points in time</span>
dt = t[<span style="color: #B452CD">1</span>] - t[<span style="color: #B452CD">0</span>]
F = a*dt/dx**<span style="color: #B452CD">2</span>
u   = zeros(Nx+<span style="color: #B452CD">1</span>)
u_1 = zeros(Nx+<span style="color: #B452CD">1</span>)

<span style="color: #228B22"># Set initial condition u(x,0) = I(x)</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nx+<span style="color: #B452CD">1</span>):
    u_1[i] = I(x[i])

<span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):
    <span style="color: #228B22"># Compute u at inner mesh points</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
        u[i] = u_1[i] + F*(u_1[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i] + u_1[i+<span style="color: #B452CD">1</span>])

    <span style="color: #228B22"># Insert boundary conditions</span>
    u[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0</span>;  u[Nx] = <span style="color: #B452CD">0</span>

    <span style="color: #228B22"># Update u_1 before next step</span>
    u_1[:]= u
    <span style="color: #228B22"># or more efficient switch of references</span>
    <span style="color: #228B22">#u_1, u = u, u_1</span>
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec11">Moving finite difference stencil </h2>

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/D_stencil_gpl/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>

<p>
<a href="http://tinyurl.com/hbcasmj/mov-diffu/D_stencil_gpl/index.html" target="_self">web page</a>
or a <a href="http://tinyurl.com/hbcasmj/mov-diffu/D_stencil_gpl/movie.ogg" target="_self">movie file</a>.

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec12">Demo program </h2>

<ul>
 <p><li> Program: <a href="http://tinyurl.com/nu656p2/diffu/diff1D_u0.py" target="_self"><tt>diffu1D_u0.py</tt></a></li>
 <p><li> Produces animation on the screen</li>
 <p><li> Each frame stored in <code>tmp_frame%04d.png</code> files<br />
   <code>tmp_frame0000.png</code>, <code>tmp_frame0001.png</code>, ...</li>
</ul>

How to make movie file in modern formats:

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span></span>Terminal&gt; name=tmp_frame%04d.png
Terminal&gt; fps=8  # frames per second in movie
Terminal&gt; ffmpeg -r $fps -i $name -vcodec flv       movie.flv
Terminal&gt; ffmpeg -r $fps -i $name -vcodec libx64    movie.mp4
Terminal&gt; ffmpeg -r $fps -i $name -vcodec libvpx    movie.webm
Terminal&gt; ffmpeg -r $fps -i $name -vcodec libtheora movie.ogg
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec13">Forward Euler applied to an initial plug profile </h2>

<p>
\( N_x=50 \). The method results in a growing, unstable solution if \( F>0.5 \).

<p>
<!-- !bslidecell 00 -->
Choosing \( F=0.5 \) gives a strange saw tooth-like curve.

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_FE_plug/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_FE_plug/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_FE_plug/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>


<!-- !eslidecell -->

<p>
<!-- !bslidecell 01 -->
Lowering \( F \) to 0.25 gives a smooth (expected) solution.

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_FE_plug_F025/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_FE_plug_F025/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_FE_plug_F025/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>


<!-- !eslidecell -->

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec14">Forward Euler applied to a Gaussian profile </h2>

<p>
\( N_x=50 \). \( F=0.5 \).

<p>
<!-- !bslidecell 00 -->

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian1/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian1/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian1/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>


<!-- !eslidecell -->

<p>
<!-- !bslidecell 01 -->

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian2/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian2/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian2/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>


<!-- !eslidecell -->

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="diffu:pde1:BE">Backward Euler scheme</h2>

<p>
Backward difference in time, centered difference in space:

$$
\begin{equation}
[D_t^- u = D_xD_x u]^n_i
\label{diffu:pde1:step3aBE}
\end{equation}
$$

<p>
Written out:

$$
\begin{equation}
\frac{u^{n}_i-u^{n-1}_i}{\Delta t} = \dfc\frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2}
\label{diffu:pde1:step3bBE}
\end{equation}
$$

<p>
Assumption: \( u^{n-1}_i \) is computed, but all quantities at the new
time level \( t_n \) are unknown.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Notice.</b>
<p>
We cannot solve wrt \( u^n_i \) because that unknown value is coupled to
two other unknown values: \( u^n_{i-1} \) and \( u^n_{i+1} \).
That is, all the new unknown values are coupled to each other
in a <em>linear system of algebraic equations</em>.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec16">Let's write out the equations for \( N_x=3 \) </h2>

<p>
Equation \eqref{diffu:pde1:step3bBE} written for \( i=1,\ldots,Nx-1= 1,2 \) becomes

$$
\begin{align}
\frac{u^{n}_1-u^{n-1}_1}{\Delta t} &= \dfc\frac{u^{n}_{2} - 2u^n_1 + u^n_{0}}{\Delta x^2}
\label{_auto4}\\ 
\frac{u^{n}_2-u^{n-1}_2}{\Delta t} &= \dfc\frac{u^{n}_{3} - 2u^n_2 + u^n_{1}}{\Delta x^2}
\label{_auto5}
\end{align}
$$

<p>
(The boundary values \( u^n_0 \) and \( u^n_3 \) are known as zero.)

<p>
Collecting the unknown new values  on the left-hand side and writing
as \( 2\times 2 \) matrix system:

$$ \left(\begin{array}{cc}
1+  2F &   - F\\ 
- F    & 1+  2F
\end{array}\right)
\left(\begin{array}{c}
u^{n}_1\\ 
u^{n}_{2}\\ 
\end{array}\right)
=
\left(\begin{array}{c}
u^{n-1}_1\\ 
u^{n-1}_2
\end{array}\right)
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec17">Two classes of discretization methods: explicit and implicit </h2>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b>Implicit.</b>
<p>
Discretization methods that lead linear systems are known
as <em>implicit methods</em>.
</div>


<p>
<div class="alert alert-block alert-block alert-text-normal">
<b>Explicit.</b>
<p>
Discretization methods that avoid linear systems and have
an explicit formula for each new value of the unknown are called
<em>explicit methods</em>.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec18">The linear system for a general \( N_x \) </h2>

$$
\begin{equation}
- F_o u^n_{i-1} + \left(1+  2F_o \right) u^{n}_i - F_o u^n_{i+1} =
u_{i-1}^{n-1}
\label{diffu:pde1:step4BE}
\end{equation}
$$

for \( i=1,\ldots,Nx-1 \).

<p>
What are the unknowns in the linear system?

<ol>
<p><li> either \( u^n_i \) for \( i=1,\ldots,N_x-1 \) (all <em>internal</em> spatial mesh points)</li>
<p><li> or \( u^n_i \), \( i=0,\ldots,N_x \) (all spatial points)</li>
</ol>

The linear system in matrix notation:

$$
\begin{equation*} AU = b,\quad U=(u^n_0,\ldots,u^n_{N_x})
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec19">\( A \) is very sparse: a tridiagonal matrix </h2>

$$
\begin{equation}
A =
\left(
\begin{array}{cccccccccc}
A_{0,0} & A_{0,1} & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
A_{1,0} & A_{1,1} & 0 & \ddots &   & &  & &  \vdots \\ 
0 & A_{2,1} & A_{2,2} & A_{2,3} &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & A_{i,i-1} & A_{i,i} & A_{i,i+1} & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & A_{N_x-1,N_x} \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & A_{N_x,N_x-1} & A_{N_x,N_x}
\end{array}
\right)
\label{diffu:pde1:matrix:sparsity}
\end{equation}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec20">Detailed expressions for the matrix entries </h2>

<p>
The nonzero elements are given by

$$
\begin{align}
A_{i,i-1} &= -F_o
\label{_auto6}\\ 
A_{i,i} &= 1+ 2F_o
\label{_auto7}\\ 
A_{i,i+1} &= -F_o
\label{_auto8}
\end{align}
$$

<p>
for \( i=1,\ldots,N_x-1 \).

<p>
The equations for the boundary points correspond to

$$
A_{0,0} = 1,\quad A_{0,1} = 0,\quad A_{N_x,N_x-1} = 0,\quad
A_{N_x,N_x} = 1
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec21">The right-hand side </h2>

$$
\begin{equation}
b = \left(\begin{array}{c}
b_0\\ 
b_1\\ 
\vdots\\ 
b_i\\ 
\vdots\\ 
b_{N_x}
\end{array}\right)
\label{_auto9}
\end{equation}
$$

<p>
with

$$
\begin{align}
b_0 &= 0
\label{_auto10}\\ 
b_i &= u^{n-1}_i,\quad i=1,\ldots,N_x-1
\label{_auto11}\\ 
b_{N_x} &= 0
\label{_auto12}
\end{align}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec22">Naive Python implementation with a dense \( (N_x+1)\times(N_x+1) \) matrix </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span></span>x = linspace(<span style="color: #B452CD">0</span>, L, Nx+<span style="color: #B452CD">1</span>)   <span style="color: #228B22"># mesh points in space</span>
dx = x[<span style="color: #B452CD">1</span>] - x[<span style="color: #B452CD">0</span>]
t = linspace(<span style="color: #B452CD">0</span>, T, N+<span style="color: #B452CD">1</span>)    <span style="color: #228B22"># mesh points in time</span>
u   = zeros(Nx+<span style="color: #B452CD">1</span>)
u_1 = zeros(Nx+<span style="color: #B452CD">1</span>)

<span style="color: #228B22"># Data structures for the linear system</span>
A = zeros((Nx+<span style="color: #B452CD">1</span>, Nx+<span style="color: #B452CD">1</span>))
b = zeros(Nx+<span style="color: #B452CD">1</span>)

<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
    A[i,i-<span style="color: #B452CD">1</span>] = -F
    A[i,i+<span style="color: #B452CD">1</span>] = -F
    A[i,i] = <span style="color: #B452CD">1</span> + <span style="color: #B452CD">2</span>*F
A[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">0</span>] = A[Nx,Nx] = <span style="color: #B452CD">1</span>

<span style="color: #228B22"># Set initial condition u(x,0) = I(x)</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nx+<span style="color: #B452CD">1</span>):
    u_1[i] = I(x[i])

<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">scipy.linalg</span>

<span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):
    <span style="color: #228B22"># Compute b and solve linear system</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
        b[i] = -u_1[i]
    b[<span style="color: #B452CD">0</span>] = b[Nx] = <span style="color: #B452CD">0</span>
    u[:] = scipy.linalg.solve(A, b)

    <span style="color: #228B22"># Update u_1 before next step</span>
    u_1, u = u, u_1
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="diffu:pde1:impl:sparse">A sparse matrix representation will dramatically reduce the computational complexity</h2>

<ul>
 <p><li> With a dense matrix, the algorithm leads to \( \Oof{N_x^3} \) operations</li>
 <p><li> Utilizing the sparsity, the algorithm has complexity \( \Oof{N_x} \)!</li>
 <p><li> <code>scipy.sparse</code> enables storage and calculations with the three
   nonzero diagonals only</li>
</ul>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #228B22"># Representation of sparse matrix and right-hand side</span>
diagonal  = zeros(Nx+<span style="color: #B452CD">1</span>)
lower     = zeros(Nx)
upper     = zeros(Nx)
b         = zeros(Nx+<span style="color: #B452CD">1</span>)
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec24">Computing the sparse matrix </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #228B22"># Precompute sparse matrix</span>
diagonal[:] = <span style="color: #B452CD">1</span> + <span style="color: #B452CD">2</span>*F
lower[:] = -F  <span style="color: #228B22">#1</span>
upper[:] = -F  <span style="color: #228B22">#1</span>
<span style="color: #228B22"># Insert boundary conditions</span>
diagonal[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">1</span>
upper[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0</span>
diagonal[Nx] = <span style="color: #B452CD">1</span>
lower[-<span style="color: #B452CD">1</span>] = <span style="color: #B452CD">0</span>

<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">scipy.sparse</span>
A = scipy.sparse.diags(
    diagonals=[main, lower, upper],
    offsets=[<span style="color: #B452CD">0</span>, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>], shape=(Nx+<span style="color: #B452CD">1</span>, Nx+<span style="color: #B452CD">1</span>),
    format=<span style="color: #CD5555">&#39;csr&#39;</span>)

<span style="color: #228B22"># Set initial condition</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>,Nx+<span style="color: #B452CD">1</span>):
    u_1[i] = I(x[i])

<span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):
    b = u_1
    b[<span style="color: #B452CD">0</span>] = b[-<span style="color: #B452CD">1</span>] = <span style="color: #B452CD">0.0</span>  <span style="color: #228B22"># boundary conditions</span>
    u[:] = scipy.sparse.linalg.spsolve(A, b)
    <span style="color: #228B22"># Switch variables before next step</span>
    u_1, u = u, u_1
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec25">Backward Euler applied to a plug profile </h2>

<p>
\( N_x=50 \).
\( F=0.5 \).

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_BE_plug/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_BE_plug/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_BE_plug/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec26">Backward Euler applied to a Gaussian profile </h2>

<p>
\( N_x=50 \).

<p>
<!-- !bslidecell 00 -->

<p>
\( F=0.5 \).

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_BE_gaussian1/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_BE_gaussian1/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_BE_gaussian1/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>


<!-- !eslidecell -->

<p>
<!-- !bslidecell 01 -->
\( F=5 \).

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_BE_gaussian1_F5/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_BE_gaussian1_F5/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_BE_gaussian1_F5/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>


<!-- !eslidecell -->

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec27">Crank-Nicolson scheme </h2>

<p>
The PDE is sampled at points \( (x_i,t_{n+\half}) \) (at the spatial
mesh points, but in between two temporal mesh points).

$$
\frac{\partial}{\partial t} u(x_i, t_{n+\half}) =
\dfc\frac{\partial^2}{\partial x^2}u(x_i, t_{n+\half})
$$

for \( i=1,\ldots,N_x-1 \) and \( n=0,\ldots, N_t-1 \).

<p>
Centered differences in space and time:

$$ [D_t u = \dfc D_xD_x u]^{n+\half}_i$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec28">Averaging in time is necessary in the Crank-Nicolson scheme </h2>

<p>
Right-hand side term:

$$ \frac{1}{\Delta x^2}\left(u^{n+\half}_{i-1} - 2u^{n+\half}_i + u^{n+\half}_{i+1}\right)$$

<p>
Problem: \( u^{n+\half}_i \) is not one of
the unknowns we compute.

<p>
Solution: replace \( u^{n+\half}_i \) by an arithmetic average:

$$ u^{n+\half}_i\approx
\half\left(u^{n}_i +u^{n+1}_{i}\right)
$$

<p>
In compact notation (arithmetic average in time \( \overline{u}^t \)):

$$ [D_t u = \dfc D_xD_x \overline{u}^t]^{n+\half}_i$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec29">Crank-Nicolsoon scheme written out </h2>

$$
\begin{equation}
u^{n+1}_i - \half F(u^{n+1}_{i-1} - 2u^{n+1}_i + u^{n+1}_{i+1})
= u^{n}_i + \half F(u^{n}_{i-1} - 2u^{n}_i + u^{n}_{i+1})
\label{_auto13}
\end{equation}
$$

<p>
Observe:

<ul>
 <p><li> The unknowns are \( u^{n+1}_{i-1}, u^{n+1}_{i}, u^{n+1}_{i+1} \)</li>
 <p><li> These unknowns are coupled to each other (in a linear system)</li>
 <p><li> Must solve \( AU=b \) at each time level</li>
</ul>

Now,

$$
\begin{align}
A_{i,i-1} &= -\half F_o
\label{_auto14}\\ 
A_{i,i} &= \half + F_o
\label{_auto15}\\ 
A_{i,i+1} &= -\half F_o
\label{_auto16}
\end{align}
$$

<p>
for internal points. For boundary points,

$$
\begin{align}
A_{0,0} &= 1
\label{_auto17}\\ 
A_{0,1} &= 0
\label{_auto18}\\ 
A_{N_x,N_x-1} &= 0
\label{_auto19}\\ 
A_{N_x,N_x} &= 1
\label{_auto20}
\end{align}
$$

<p>
Right-hand side:

$$
\begin{align}
b_0 &= 0
\label{_auto21}\\ 
b_i &= u^{n-1}_i,\quad i=1,\ldots,N_x-1
\label{_auto22}\\ 
b_{N_x} &= 0    \label{_auto23}
\end{align}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec30">Crank-Nicolson applied to a plug profile </h2>

<p>
Crank-Nicolson never blows up, so any \( F \) can be used
(modulo loss of accuracy).

<p>
<!-- !bslidecell 00 -->
\( N_x=50 \).
\( F=5 \) gives instabilities.

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_theta_plug_F5/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_theta_plug_F5/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_theta_plug_F5/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>


<!-- !eslidecell -->

<p>
<!-- !bslidecell 01 -->
\( N_x=50 \).
\( F=0.5 \) gives a smooth solution.

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_theta_plug/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_theta_plug/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_theta_plug/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>


<!-- !eslidecell -->

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec31">Crank-Nicolson applied to a Gaussian profile </h2>

<p>
\( N_x=50 \).

<p>
<!-- !bslidecell 00 -->

<p>
\( F=0.5 \).

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_theta_gaussian1/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_theta_gaussian1/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_theta_gaussian1/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>


<!-- !eslidecell -->

<p>
<!-- !bslidecell 01 -->
\( F=5 \).

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_theta_gaussian1_F5/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_theta_gaussian1_F5/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_theta_gaussian1_F5/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>


<!-- !eslidecell -->

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="diffu:pde1:theta">The \( \theta \) rule</h2>

<p>
The \( \theta \) rule condenses a family of finite difference approximations
in time to one formula

<ul>
 <p><li> \( \theta=0 \) gives the Forward Euler scheme in time</li>
 <p><li> \( \theta=1 \) gives the Backward Euler scheme in time</li>
 <p><li> \( \theta=\half \) gives the Crank-Nicolson scheme in time</li>
</ul>

Applied to \( u_t=\dfc u_{xx} \):

$$ \frac{u^{n+1}_i-u^n_i}{\Delta t} =
\dfc\left( \theta \frac{u^{n+1}_{i+1} - 2u^{n+1}_i + u^{n+1}_{i-1}}{\Delta x^2}
+ (1-\theta) \frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2}\right)
$$

<p>
Matrix entries:

$$ A_{i,i-1} = -F_o\theta,\quad A_{i,i} = 1+2F_o\theta\quad,
A_{i,i+1} = -F_o\theta$$

<p>
Right-hand side:

$$ b_i = u^n_{i} + F_o(1-\theta)
\frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec33">The Laplace and Poisson equation </h2>

<p>
Laplace equation:

$$ \nabla^2 u = 0,\quad \mbox{1D: } u''(x)=0$$

<p>
Poisson equation:

$$ -\nabla^2 u = f,\quad \mbox{1D: } -u''(x)=f(x)$$

<p>
These are limiting behavior of time-dependent diffusion equations if

$$ \lim_{t\rightarrow\infty}\frac{\partial u}{\partial t} = 0$$

<p>
Then \( u_t = \dfc u_{xx} + 0 \) in the limit \( t\rightarrow\infty \)
reduces to

$$ u_{xx} + f = 0$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec34">We can solve 1D Poisson/Laplace equation by going to infinity in time-dependent diffusion equations </h2>

<p>
Looking at the numerical schemes, \( F\rightarrow\infty \) leads to the
Laplace or Poisson equations (without \( f \) or with \( f \), resp.).

<p>
Good news: choose \( F \) large in the BE or CN schemes and <em>one
time step</em> is enough to produce the stationary solution for
\( t\rightarrow\infty \).

<p>
<!-- Need example, but with nonzero boundary conditions -->

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec35">Extensions </h2>

<p>
These extensions are performed exactly as for a wave equation as they
only affect the spatial derivatives (which are the same as in the
wave equation).

<ul>
 <p><li> Variable coefficients</li>
 <p><li> Neumann and Robin conditions</li>
 <p><li> 2D and 3D</li>
</ul>

Future versions of this document will for completeness and
independence of the wave equation document feature info on the three
points. The Robin condition is new, but straightforward to handle:

$$ -\dfc\frac{\partial u}{\partial n} = h_T(u-U_s),\quad
[-\dfc D_x u = h_T(u-U_s)]^n_i
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h1 id="diffu:pde1:analysis">Analysis of schemes for the diffusion equation</h1>

<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">
Solutions of diffusion problems are expected to be smooth. Can we
understand when they are not?
</div>
<!-- end box -->


<p>
<center><p><img src="fig-diffu/discontinuity_CN_F5.png" align="bottom" width=400></p></center>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="diffu:pde1:analysis:uex">Properties of the solution</h2>

<p>
The PDE

$$
u_t = \dfc u_{xx}
$$

admits solutions

$$
u(x,t) = Qe^{-\dfc k^2 t}\sin\left( kx\right)
$$

<p>
Observations from this solution:

<ul>
 <p><li> The initial shape \( I(x)=Q\sin kx \)
   undergoes a damping \( \exp{(-\dfc k^2t)} \)</li>
 <p><li> The damping is very strong for short waves (large \( k \))</li>
 <p><li> The damping is weak for long waves (small \( k \))</li>
 <p><li> Consequence: \( u \) is smoothened with time</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec38">Example </h2>

<p>
Test problem:

$$
\begin{align*}
u_t &= u_{xx},\quad &x\in (0,1),\ t\in (0,T]\\ 
u(0,t) &= u(1,t) = 0,\quad &t\in (0,T]\\ 
u(x,0) & = \sin (\pi x) + 0.1\sin(100\pi x)
\end{align*}
$$

<p>
Exact solution:

$$
u(x,t) = e^{-\pi^2 t}\sin (\pi x) + 0.1e^{-\pi^2 10^4 t}\sin (100\pi x)
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec39">High frequency components of the solution are very quickly damped </h2>

<p>
<center><p><img src="fig-diffu/diffusion_damping.png" align="bottom" width=800></p></center>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec40">Damping of a discontinuity; problem </h2>

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Problem.</b>
<p>
Two pieces of a material, at different temperatures, are brought
in contact at \( t=0 \). Assume the end points of the pieces are
kept at the initial temperature. How does the heat flow from
the hot to the cold piece?

<p>
Or: A huge ion concentration on one side of a synapse in the brain
(concentration discontinuity) is released and
ions move by diffusion.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec41">Damping of a discontinuity; model </h2>

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Solution.</b>
<p>

<p>
Assume a 1D model is sufficient (e.g., insulated rod):

$$
u(x,0)=\left\lbrace
\begin{array}{ll}
U_L, & x < L/2\\ 
U_R,& x\geq L/2
\end{array}\right.
$$


$$ \frac{\partial u}{\partial t} = \dfc
\frac{\partial^2 u}{\partial x^2},\quad u(0,t)=U_L,\ u(L,t)=U_R$$
</div>


<p>
<!-- FIGURE: [fig-diffu/discont_I, width=400 frac=0.6] -->

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec42">Damping of a discontinuity; Backward Euler scheme </h2>

<p>
Discrete model:

$$ [D_t^- u = \dfc D_xD_x]^n_i $$

<p>
results in a (tridiagonal) linear system

$$
- F u^n_{i-1} + \left(1+  2F \right) u^{n}_i - F u^n_{i+1} =
u_{i-1}^{n-1}
$$

<p>
where

$$ F = \dfc\frac{\Delta t}{\Delta x^2} $$

<p>
is the <em>mesh Fourier number</em>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec43">Damping of a discontinuity; Backward Euler simulation \( F=\half \) </h2>

<p>

<div>
<video  loop controls width='500' height='365' preload='none'>
    <source src='mov-diffu/BE_C0.5/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/BE_C0.5/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec44">Damping of a discontinuity; Forward Euler scheme </h2>

<p>
Discrete model:

$$ [D_t^+ u = \dfc D_xD_x]^n_i $$

<p>
results in the explicit updating formula

$$ u^{n+1}_i = u^n_i + F\left(
u^{n}_{i+1} - 2u^n_i + u^n_{i-1}\right)
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec45">Damping of a discontinuity; Forward Euler simulation \( F=\half \) </h2>

<p>

<div>
<video  loop controls width='500' height='365' preload='none'>
    <source src='mov-diffu/FE_C0.5/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/FE_C0.5/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec46">Damping of a discontinuity; Crank-Nicolson scheme </h2>

<p>
Discrete model:

$$ [D_t u = \dfc D_xD_x\overline{u}^t]^n_i $$

<p>
results in a tridiagonal linear system

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec47">Damping of a discontinuity; Crank-Nicolson simulation \( F=5 \) </h2>

<p>

<div>
<video  loop controls width='500' height='365' preload='none'>
    <source src='mov-diffu/CN_C5/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/CN_C5/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec48">Fourier representation </h2>

<p>
Represent \( I(x) \) as a Fourier series

$$
I(x) \approx \sum_{k\in K} b_k e^{ikx}
$$

<p>
The corresponding sum for \( u \) is

$$
u(x,t) \approx \sum_{k\in K} b_k e^{-\dfc k^2t}e^{ikx}
$$

<p>
Such solutions are also accepted by the numerical schemes, but
with an amplification factor \( A \) different from \( \exp{({-\dfc k^2t})} \):

$$
u^n_q = A^n e^{ikq\Delta x} = A^ne^{ikx}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="diffu:pde1:analysis:summary">Analysis of the finite difference schemes</h2>

<p>
Stability:

<ul>
  <p><li> \( |A| < 1 \): decaying numerical solutions (as we want)</li>
  <p><li> \( A < 0 \): <em>oscillating</em> numerical solutions (as we do not want)</li>
</ul>

Accuracy:

<ul>
  <p><li> Compare numerical and exact amplification factor: \( A \) vs \( \Aex = \exp{(-\dfc k^2 \Delta t)} \)</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="diffu:pde1:analysis:FE">Analysis of the Forward Euler scheme</h2>

$$
\begin{equation*} [D_t^+ u = \dfc D_xD_x u]^n_q \end{equation*}
$$

<p>
Inserting

$$ u^n_q = A^n e^{ikq\Delta x}$$

leads to

$$
A = 1 -4F\sin^2\left(
\frac{k\Delta x}{2}\right),\quad
F = \frac{\dfc\Delta t}{\Delta x^2}\mbox{ (mesh Fourier number)}
$$

<p>
The complete numerical solution is

$$
u^n_q = (1 -4F\sin^2 p)^ne^{ikq\Delta x},\quad
p = k\Delta x/2
$$

<p>
Key spatial discretization quantity: the dimensionless \( p=\half k\Delta x \)

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec51">Results for stability </h2>

<p>
We always have \( A\leq 1 \). The condition \( A\geq -1 \) implies

$$ 4F\sin^2p\leq 2 $$

The worst case is when \( \sin^2 p=1 \), so a sufficient criterion for
stability is

$$ F\leq {\half} $$

or:

$$ \Delta t\leq \frac{\Delta x^2}{2\dfc} $$

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Implications of the stability result.</b>
<p>
Less favorable criterion than for \( u_{tt}=c^2u_{xx} \): halving \( \Delta x \)
implies time step \( \frac{1}{4}\Delta t \) (not just \( \half\Delta t \)
as in a wave equation). Need very small time steps for fine spatial
meshes!
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="diffu:pde1:analysis:BE">Analysis of the Backward Euler scheme</h2>

$$
\begin{equation*} [D_t^- u = \dfc D_xD_x u]^n_q\end{equation*}
$$


$$ u^n_q = A^n e^{ikq\Delta x}$$


$$ A = (1  + 4F\sin^2p)^{-1} $$


$$ u^n_q = (1  + 4F\sin^2p)^{-n}e^{ikq\Delta x} $$

<p>
Stability:
We see that \( |A| < 1 \) for all \( \Delta t>0 \)
and that \( A>0 \) (no oscillations)

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="diffu:pde1:analysis:CN">Analysis of the Crank-Nicolson scheme</h2>

<p>
The scheme

$$ [D_t u = \dfc D_xD_x \overline{u}^x]^{n+\half}_q$$

leads to

$$ A = \frac{ 1 - 2F\sin^2p}{1 + 2F\sin^2p} $$


$$ u^n_q = \left(\frac{ 1 - 2F\sin^2p}{1 + 2F\sin^2p}\right)^ne^{ikp\Delta x}$$

<p>
Stability:
The criteria \( A>-1 \) and \( A < 1 \) are fulfilled for any \( \Delta t >0 \)

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec54">Summary of amplification factors </h2>

$$
\begin{align*}
\Aex &= \exp{(-\alpha k^2\Delta t)} = \exp{(-4Fp^2)}\\ 
A &= 1 -4F\sin^2\left(\frac{k\Delta x}{2}\right)\quad\mbox{Forward Euler}\\ 
A &= (1  + 4F\sin^2p)^{-1}\quad\mbox{Backward Euler}\\ 
A &= \frac{ 1 - 2F\sin^2p}{1 + 2F\sin^2p}\quad\mbox{Crank-Nicolson}
\end{align*}
$$

<p>
Note: \( \Aex = \exp{(-\dfc k^2\Delta t)}=\exp{(-F k^2\Delta x^2)}=
\exp{(-F4p^2)} \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec55">Summary of accuracy of amplification factors; large time steps </h2>

<p>
<center><p><img src="fig-diffu/diffusion_A_F20_F2.png" align="bottom" width=800></p></center>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec56">Summary of accuracy of amplification factors; time steps around the Forward Euler stability limit </h2>

<p>
<center><p><img src="fig-diffu/diffusion_A_F05_F025.png" align="bottom" width=800></p></center>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec57">Summary of accuracy of amplification factors; small time steps </h2>

<p>
<center><p><img src="fig-diffu/diffusion_A_F01_F001.png" align="bottom" width=800></p></center>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec58">Observations </h2>

<ul>
 <p><li> The key spatial discretization parameter is the dimensionless \( p=\half k\Delta x \)</li>
 <p><li> The key temporal discretization parameter is the dimensionless \( F = \dfc\Delta t/\Delta x^2 \)</li>
 <p><li> Important: \( \Delta t \) and \( \Delta x \) <em>in combination with</em> \( \dfc \) and \( k \)
   determine accuracy</li>
 <p><li> Crank-Nicolson gives oscillations and not much damping of short waves
   for increasing \( F \)</li>
 <p><li> These waves will manifest themselves as high frequency
   oscillatory noise in the solution</li>
 <p><li> Steep solutions will have short waves with significant (visible) amplitudes</li>
 <p><li> All schemes fail to dampen short waves enough</li>
</ul>

The problems of correct damping for \( u_t = u_{xx} \) is partially
manifested in the similar time discretization schemes for \( u'(t)=-\dfc u(t) \).

<!-- ------------------- end of main content --------------- -->


<center style="font-size:80%">
<!-- copyright --> &copy; 2017, Hans Petter Langtangen, Svein Linge. Released under CC Attribution 4.0 license
</center>


</body>
</html>
    

