## Introduction to CFD {#sec-cfd-intro}

Computational Fluid Dynamics (CFD) is the study of fluid flow using
numerical methods. Unlike the simpler PDEs we have studied so far---where
a single scalar quantity like temperature or wave amplitude evolves---CFD
deals with *coupled systems* of equations for velocity and pressure.

The governing equations for most fluid dynamics problems are the
Navier-Stokes equations, named after Claude-Louis Navier and George
Gabriel Stokes. These equations represent conservation of momentum
coupled with conservation of mass (continuity). Despite their apparent
simplicity, they exhibit extraordinarily rich behavior, from laminar
flow in pipes to turbulence in the atmosphere.

### Why CFD Matters

Fluid dynamics governs phenomena across scales:

- **Engineering**: Aircraft design, internal combustion engines, HVAC systems
- **Environmental**: Weather prediction, ocean currents, pollutant dispersion
- **Biomedical**: Blood flow, respiratory mechanics, drug delivery
- **Energy**: Wind turbines, nuclear reactor cooling, oil reservoir flow

In each application, we seek to understand and predict how fluids move,
mix, and transfer heat and mass.

### Incompressible Flow

This chapter focuses on *incompressible* flow, where the fluid density
$\rho$ is constant. This is an excellent approximation for liquids and
for gases moving at low Mach numbers (velocity much less than the speed
of sound). The incompressibility constraint dramatically simplifies the
equations while retaining the essential physics of convection, diffusion,
and pressure-velocity coupling.

### Chapter Overview

We develop a solver for the classic *lid-driven cavity* problem:
a square box of fluid with a moving lid that drives circulatory flow.
This problem has been studied extensively since the 1960s and serves
as the standard benchmark for incompressible flow solvers.

The chapter covers:

1. Derivation of the incompressible Navier-Stokes equations
2. The pressure-velocity coupling problem and projection methods
3. Finite difference discretization
4. Implementation in Devito
5. Verification against published benchmarks


## The Navier-Stokes Equations {#sec-cfd-navier-stokes}

The Navier-Stokes equations express conservation of momentum for a
Newtonian fluid. In two dimensions, for velocity components $(u, v)$
in the $(x, y)$ directions, the momentum equations are:

$$
\frac{\partial u}{\partial t} + u \frac{\partial u}{\partial x}
+ v \frac{\partial u}{\partial y} =
-\frac{1}{\rho}\frac{\partial p}{\partial x}
+ \nu \left( \frac{\partial^2 u}{\partial x^2}
+ \frac{\partial^2 u}{\partial y^2} \right)
$$ {#eq-cfd-ns-u}

$$
\frac{\partial v}{\partial t} + u \frac{\partial v}{\partial x}
+ v \frac{\partial v}{\partial y} =
-\frac{1}{\rho}\frac{\partial p}{\partial y}
+ \nu \left( \frac{\partial^2 v}{\partial x^2}
+ \frac{\partial^2 v}{\partial y^2} \right)
$$ {#eq-cfd-ns-v}

where:

- $u, v$ are velocity components [m/s]
- $p$ is pressure [Pa]
- $\rho$ is fluid density [kg/m$^3$]
- $\nu$ is kinematic viscosity [m$^2$/s]

### Physical Interpretation of Terms

Each term has a clear physical meaning:

| Term | Name | Physical Interpretation |
|------|------|------------------------|
| $\partial u/\partial t$ | Local acceleration | Rate of change at a fixed point |
| $u \partial u/\partial x + v \partial u/\partial y$ | Convective acceleration | Change due to fluid moving to regions of different velocity |
| $-\frac{1}{\rho}\nabla p$ | Pressure gradient | Force per unit mass from pressure differences |
| $\nu \nabla^2 u$ | Viscous diffusion | Momentum diffusion from molecular friction |

The left-hand side represents the *material derivative* $Du/Dt$---the
rate of change following a fluid particle. The right-hand side contains
the forces acting on that particle.

### The Continuity Equation

Mass conservation for incompressible flow requires:

$$
\frac{\partial u}{\partial x} + \frac{\partial v}{\partial y} = 0
$$ {#eq-cfd-continuity}

This *divergence-free* condition states that fluid cannot accumulate
or deplete at any point. Physically, what flows into a region must
flow out.

### The Reynolds Number

The behavior of fluid flow is governed by the dimensionless Reynolds number:

$$
\text{Re} = \frac{U L}{\nu}
$$ {#eq-cfd-reynolds}

where $U$ is a characteristic velocity and $L$ is a characteristic length.
The Reynolds number represents the ratio of inertial forces (convection)
to viscous forces (diffusion):

- **Low Re ($< 1$)**: Viscous-dominated, creeping flow
- **Moderate Re ($1$--$1000$)**: Balanced, laminar flow with structure
- **High Re ($> 1000$)**: Inertia-dominated, potentially turbulent

For the lid-driven cavity with lid velocity $U_{\text{lid}}$ and
cavity size $L$:

$$
\text{Re} = \frac{U_{\text{lid}} \cdot L}{\nu}
$$

### Vector Form

In compact vector notation, the Navier-Stokes equations become:

$$
\frac{\partial \mathbf{u}}{\partial t}
+ (\mathbf{u} \cdot \nabla) \mathbf{u}
= -\frac{1}{\rho} \nabla p + \nu \nabla^2 \mathbf{u}
$$ {#eq-cfd-ns-vector}

$$
\nabla \cdot \mathbf{u} = 0
$$ {#eq-cfd-div-free}

This form generalizes immediately to three dimensions and highlights
the structure: nonlinear convection, linear pressure gradient, and
linear viscous diffusion.


## Pressure-Velocity Coupling {#sec-cfd-pressure}

The incompressibility constraint @eq-cfd-continuity creates a fundamental
challenge: there is no explicit evolution equation for pressure. The
pressure field must be determined such that the resulting velocity
field is divergence-free.

### The Problem

Consider solving @eq-cfd-ns-u and @eq-cfd-ns-v by explicit time stepping.
If we ignore pressure and simply advance velocities, the result will
generally not satisfy continuity @eq-cfd-continuity. We need pressure
to "correct" the velocity field to maintain incompressibility.

### The Pressure Poisson Equation

Taking the divergence of the momentum equation @eq-cfd-ns-vector and
using the continuity constraint, we obtain the *pressure Poisson equation*:

$$
\nabla^2 p = \rho \left[
\frac{\partial}{\partial t}\left(
\frac{\partial u}{\partial x} + \frac{\partial v}{\partial y}
\right)
- \left(
\frac{\partial u}{\partial x} \right)^2
- 2 \frac{\partial u}{\partial y} \frac{\partial v}{\partial x}
- \left( \frac{\partial v}{\partial y} \right)^2
\right]
$$ {#eq-cfd-pressure-poisson}

The right-hand side contains velocity derivatives that can be computed
from the current velocity field. Solving this elliptic equation gives
the pressure field needed to maintain incompressibility.

### The Projection Method

The *projection method* (also called fractional step method) provides
a systematic approach to pressure-velocity coupling:

**Step 1: Predict intermediate velocity**

Advance velocity ignoring pressure:
$$
\mathbf{u}^* = \mathbf{u}^n + \Delta t \left[
-(\mathbf{u}^n \cdot \nabla)\mathbf{u}^n + \nu \nabla^2 \mathbf{u}^n
\right]
$$

This intermediate velocity $\mathbf{u}^*$ is generally not divergence-free.

**Step 2: Solve pressure Poisson**

Determine pressure to enforce continuity:
$$
\nabla^2 p^{n+1} = \frac{\rho}{\Delta t} \nabla \cdot \mathbf{u}^*
$$

**Step 3: Correct velocity**

Project onto divergence-free space:
$$
\mathbf{u}^{n+1} = \mathbf{u}^* - \frac{\Delta t}{\rho} \nabla p^{n+1}
$$

The corrected velocity $\mathbf{u}^{n+1}$ satisfies $\nabla \cdot \mathbf{u}^{n+1} = 0$
by construction.

### Iterative Pressure Solve

In practice, we solve the pressure Poisson equation iteratively using
methods similar to those in @sec-ch-elliptic. The Jacobi iteration for
the discretized pressure equation with source term $b$ is:

$$
p_{i,j}^{(k+1)} = \frac{
\Delta y^2 (p_{i+1,j}^{(k)} + p_{i-1,j}^{(k)})
+ \Delta x^2 (p_{i,j+1}^{(k)} + p_{i,j-1}^{(k)})
- \Delta x^2 \Delta y^2 \, b_{i,j}
}{2(\Delta x^2 + \Delta y^2)}
$$ {#eq-cfd-pressure-jacobi}

Multiple iterations (typically 50-100) per time step ensure adequate
convergence of the pressure field.


## The Lid-Driven Cavity Problem {#sec-cfd-cavity}

The lid-driven cavity is the canonical benchmark for incompressible
flow solvers. It features all the essential physics (convection,
diffusion, pressure coupling) in a simple geometry.

### Problem Setup

Consider a unit square domain $[0, 1] \times [0, 1]$ filled with
fluid. The boundary conditions are:

- **Top wall (lid)**: $u = U_{\text{lid}}, v = 0$ (moving lid drives flow)
- **Other walls**: $u = v = 0$ (no-slip condition)
- **Pressure**: $\partial p / \partial n = 0$ on all walls (Neumann)

The moving lid drags fluid along, creating a primary vortex that
occupies most of the cavity. Secondary vortices appear in the corners,
especially at higher Reynolds numbers.

### Initial Conditions

The simulation starts from rest:
$$
u(x, y, 0) = 0, \quad v(x, y, 0) = 0, \quad p(x, y, 0) = 0
$$

The flow develops from the lid motion and eventually reaches a
steady state (for moderate Re).

### Flow Features

The flow structure depends strongly on Reynolds number:

| Re | Primary vortex | Secondary vortices | Flow regime |
|----|----------------|-------------------|-------------|
| 100 | Centered, symmetric | Small bottom corners | Steady laminar |
| 400 | Shifted right | Visible in corners | Steady laminar |
| 1000 | Further right, stronger | Multiple corner vortices | Steady laminar |
| 10000+ | Complex structure | Many vortices | Potentially unsteady |

### Why This Benchmark?

The lid-driven cavity is ideal for validation because:

1. **Simple geometry**: Unit square, no internal obstacles
2. **Closed domain**: No inflow/outflow complexities
3. **Rich physics**: Contains convection, diffusion, recirculation
4. **Well-documented**: Extensive benchmark data available
5. **Steady solution**: Converges to known steady state (moderate Re)


## Implementation in Devito {#sec-cfd-devito}

Now we implement the lid-driven cavity solver using Devito. The
implementation follows the pressure-velocity coupling approach,
with separate operators for pressure iteration and velocity update.

### Grid and Fields Setup

We create a 2D grid and `TimeFunction` objects for velocity components
and pressure:

```python
from devito import Grid, TimeFunction, Function, Eq, solve, Operator

# Grid parameters
N = 41          # Grid points
L = 1.0         # Domain size [m]
Re = 100.0      # Reynolds number
U_lid = 1.0     # Lid velocity [m/s]
rho = 1.0       # Density [kg/m^3]

# Derived quantities
nu = U_lid * L / Re  # Kinematic viscosity
dx = L / (N - 1)
dy = dx

# Time step (stability constrained)
dt = min(0.5 * dx / U_lid, 0.25 * dx**2 / nu, 0.001)

# Create Devito grid
grid = Grid(shape=(N, N), extent=(L, L))
x, y = grid.dimensions
t = grid.stepping_dim

# Velocity components as TimeFunction
u = TimeFunction(name='u', grid=grid, space_order=2)
v = TimeFunction(name='v', grid=grid, space_order=2)

# Pressure also as TimeFunction for iterative solve
p = TimeFunction(name='p', grid=grid, space_order=2)

# Source term for pressure Poisson
b = Function(name='b', grid=grid)
```

Using `TimeFunction` for pressure allows us to leverage Devito's
buffer management for the iterative Jacobi solver, treating iterations
as pseudo-time steps.

### Momentum Equations

The momentum equations involve both first and second spatial derivatives.
Devito provides:

- `u.dx`, `u.dy`: First derivatives (upwind)
- `u.dxc`, `u.dyc`: First derivatives (centered)
- `u.laplace`: Laplacian (centered second derivatives)

```python
# x-momentum equation
# du/dt + u*du/dx + v*du/dy = -1/rho * dp/dx + nu * laplace(u)
eq_u = Eq(
    u.dt + u*u.dx + v*u.dy,
    -1.0/rho * p.dxc + nu * u.laplace,
    subdomain=grid.interior
)

# y-momentum equation
eq_v = Eq(
    v.dt + u*v.dx + v*v.dy,
    -1.0/rho * p.dyc + nu * v.laplace,
    subdomain=grid.interior
)

# Solve for forward time level
stencil_u = solve(eq_u, u.forward)
stencil_v = solve(eq_v, v.forward)

update_u = Eq(u.forward, stencil_u)
update_v = Eq(v.forward, stencil_v)
```

The `subdomain=grid.interior` restricts the equation to interior
points, leaving boundaries for explicit treatment.

### Velocity Boundary Conditions

The boundary conditions are implemented as separate equations:

```python
# Velocity BCs: no-slip walls, moving lid at top
bc_u = [
    Eq(u[t+1, x, 0], 0),         # Bottom: u = 0
    Eq(u[t+1, x, N-1], U_lid),   # Top: u = U_lid
    Eq(u[t+1, 0, y], 0),         # Left: u = 0
    Eq(u[t+1, N-1, y], 0),       # Right: u = 0
]

bc_v = [
    Eq(v[t+1, x, 0], 0),         # Bottom: v = 0
    Eq(v[t+1, x, N-1], 0),       # Top: v = 0
    Eq(v[t+1, 0, y], 0),         # Left: v = 0
    Eq(v[t+1, N-1, y], 0),       # Right: v = 0
]

# Build velocity update operator
op_velocity = Operator([update_u, update_v] + bc_u + bc_v)
```

Note the indexing: `u[t+1, x, 0]` refers to velocity at the next time
level (`t+1`), all x-positions (`x`), and y-index 0 (bottom boundary).

### Pressure Poisson Equation

The pressure equation has no time derivative---it is an elliptic
equation that must be satisfied at each time step:

```python
# Pressure Poisson: laplace(p) = b
eq_p = Eq(p.laplace, b, subdomain=grid.interior)
stencil_p = solve(eq_p, p)
update_p = Eq(p.forward, stencil_p)

# Pressure BCs: Neumann (dp/dn = 0) on all walls
bc_p = [
    Eq(p[t+1, 0, y], p[t+1, 1, y]),         # dp/dx = 0 at x = 0
    Eq(p[t+1, N-1, y], p[t+1, N-2, y]),     # dp/dx = 0 at x = 1
    Eq(p[t+1, x, 0], p[t+1, x, 1]),         # dp/dy = 0 at y = 0
    Eq(p[t+1, x, N-1], p[t+1, x, N-2]),     # dp/dy = 0 at y = 1
    Eq(p[t+1, 0, 0], 0),                     # Fix p at corner
]

op_pressure = Operator([update_p] + bc_p)
```

The Neumann conditions are implemented by copying from adjacent cells,
enforcing zero normal gradient. One point must be fixed (here the
corner) since Neumann conditions determine pressure only up to a constant.

### Pressure Source Term

The right-hand side of the pressure Poisson equation involves velocity
derivatives computed in Python:

```python
import numpy as np

def compute_pressure_rhs(u_data, v_data, b_data, dx, dy, dt, rho):
    """Compute RHS of pressure Poisson equation."""
    b_data[1:-1, 1:-1] = rho * (
        # Divergence rate
        1.0 / dt * (
            (u_data[2:, 1:-1] - u_data[:-2, 1:-1]) / (2*dx) +
            (v_data[1:-1, 2:] - v_data[1:-1, :-2]) / (2*dy)
        ) -
        # Nonlinear terms
        ((u_data[2:, 1:-1] - u_data[:-2, 1:-1]) / (2*dx))**2 -
        2 * ((u_data[1:-1, 2:] - u_data[1:-1, :-2]) / (2*dy) *
             (v_data[2:, 1:-1] - v_data[:-2, 1:-1]) / (2*dx)) -
        ((v_data[1:-1, 2:] - v_data[1:-1, :-2]) / (2*dy))**2
    )
```

This function uses NumPy array slicing for efficiency on the structured
grid.

### Time Stepping Loop

The main simulation loop alternates between pressure iteration and
velocity update:

```python
from devito import configuration
configuration['log-level'] = 'ERROR'  # Suppress output

nt = 1000   # Number of time steps
nit = 50    # Pressure iterations per step

# Initialize fields
u.data[:] = 0.0
v.data[:] = 0.0
p.data[:] = 0.0

for step in range(nt):
    # Compute pressure RHS from current velocities
    compute_pressure_rhs(u.data[0], v.data[0], b.data, dx, dy, dt, rho)

    # Solve pressure Poisson (pseudo-timestepping)
    if step > 0:
        op_pressure(time_M=nit)

    # Update velocities
    op_velocity(time_m=step, time_M=step, dt=dt)
```

The pressure solve uses `time_M=nit` to run `nit` iterations internally.
The velocity update uses `time_m=step, time_M=step` to advance exactly
one physical time step.


## Boundary Conditions {#sec-cfd-boundary}

Proper implementation of boundary conditions is critical for CFD.
Incorrect BCs can cause numerical instabilities, non-physical solutions,
or loss of accuracy.

### No-Slip Walls

At solid walls, the fluid velocity equals the wall velocity. For
stationary walls:
$$
u = 0, \quad v = 0 \quad \text{(no-slip)}
$$

This represents the physical observation that fluid molecules adjacent
to a wall move with the wall. For the lid-driven cavity:

- Three walls are stationary: $u = v = 0$
- The top wall moves: $u = U_{\text{lid}}, v = 0$

### Implementation Note: Corner Treatment

At corners, two boundary conditions meet. For a corner at $(0, 0)$:

```python
# Both conditions should give u = 0
u.data[:, 0, 0] = 0  # From bottom wall
u.data[:, 0, :] = 0  # From left wall (compatible)
```

Ensure boundary conditions are consistent at corners. Inconsistency
(e.g., claiming $u = 1$ from one wall and $u = 0$ from another) creates
singularities.

### Pressure Boundary Conditions

For the Navier-Stokes equations, pressure BCs are derived from the
momentum equations at the wall. For a wall with no acceleration:

$$
\frac{\partial p}{\partial n} = 0
$$

This *Neumann condition* is implemented by setting the boundary pressure
equal to its neighbor:

```python
# dp/dx = 0 at x = 0 means p[0,:] = p[1,:]
p.data[:, 0, :] = p.data[:, 1, :]
```

### Uniqueness of Pressure

Neumann conditions on all boundaries determine pressure only up to a
constant. To obtain a unique solution, we fix pressure at one point:

```python
p.data[:, 0, 0] = 0  # Fix corner pressure to zero
```

This is physically acceptable because only pressure *gradients* appear
in the momentum equations. The absolute pressure level is arbitrary
for incompressible flow.


## Convergence to Steady State {#sec-cfd-convergence}

For the lid-driven cavity at moderate Reynolds numbers, the flow
converges to a steady state where all time derivatives vanish:

$$
\frac{\partial u}{\partial t} = 0, \quad
\frac{\partial v}{\partial t} = 0
$$

### Monitoring Convergence

We track the change in velocity fields between time steps:

```python
def check_convergence(u_old, u_new, v_old, v_new, tol=1e-6):
    """Check if steady state has been reached."""
    u_diff = np.max(np.abs(u_new - u_old))
    v_diff = np.max(np.abs(v_new - v_old))
    return max(u_diff, v_diff) < tol
```

When changes drop below a tolerance, we consider the solution converged.

### Typical Convergence Behavior

The number of time steps to steady state depends on Reynolds number:

| Re | Approximate steps to steady state |
|----|-----------------------------------|
| 100 | 1000-2000 |
| 400 | 3000-5000 |
| 1000 | 5000-10000 |
| 3200 | 10000-20000 |

Higher Reynolds numbers require more steps because viscous diffusion
(which damps transients) is weaker.

### Pressure Iteration Convergence

Within each time step, the pressure Poisson solve must also converge.
The number of pressure iterations (typically 50-100) should be chosen
such that:

$$
\| p^{(k+1)} - p^{(k)} \|_\infty < \epsilon_p
$$

where $\epsilon_p$ is a small tolerance. Insufficient pressure iterations
cause divergence buildup in the velocity field.


## Verification with Ghia Benchmark {#sec-cfd-verification}

The classic benchmark for lid-driven cavity solvers is the work of
Ghia, Ghia, and Shin (1982), who published detailed velocity profiles
at various Reynolds numbers using a fine grid (129 x 129 to 257 x 257).

### Benchmark Data

The benchmark provides velocity profiles along the geometric centerlines:

- **u-velocity** along the vertical centerline ($x = 0.5$)
- **v-velocity** along the horizontal centerline ($y = 0.5$)

```python
def ghia_benchmark(Re=100):
    """Return Ghia et al. benchmark data."""
    if Re == 100:
        # y-coordinates and u at x = 0.5
        y_u = np.array([0.0000, 0.0547, 0.0625, 0.0703, 0.1016, 0.1719,
                        0.2813, 0.4531, 0.5000, 0.6172, 0.7344, 0.8516,
                        0.9531, 0.9609, 0.9688, 0.9766, 1.0000])
        u_ghia = np.array([0.0000, -0.0372, -0.0419, -0.0478, -0.0643,
                           -0.1015, -0.1566, -0.2109, -0.2058, -0.1364,
                           0.0033, 0.2315, 0.6872, 0.7372, 0.7887,
                           0.8412, 1.0000])
        # x-coordinates and v at y = 0.5
        x_v = np.array([0.0000, 0.0625, 0.0703, 0.0781, 0.0938, 0.1563,
                        0.2266, 0.2344, 0.5000, 0.8047, 0.8594, 0.9063,
                        0.9453, 0.9531, 0.9609, 0.9688, 1.0000])
        v_ghia = np.array([0.0000, 0.0923, 0.1009, 0.1089, 0.1232, 0.1608,
                           0.1751, 0.1753, 0.0545, -0.2453, -0.2245,
                           -0.1691, -0.1031, -0.0886, -0.0739, -0.0591,
                           0.0000])
        return (y_u, u_ghia), (x_v, v_ghia)
    # Add other Re values similarly...
```

### Extracting Centerline Data

From our simulation result, we extract the corresponding profiles:

```python
def extract_centerlines(u, v, x, y, N):
    """Extract velocity profiles along centerlines."""
    mid = N // 2

    # u along vertical centerline (x = 0.5)
    u_center = u[mid, :]
    y_center = y

    # v along horizontal centerline (y = 0.5)
    v_center = v[:, mid]
    x_center = x

    return (y_center, u_center), (x_center, v_center)
```

### Comparison Plot

```python
import matplotlib.pyplot as plt

# Get benchmark data
(y_ghia, u_ghia), (x_ghia, v_ghia) = ghia_benchmark(Re=100)

# Get simulation data
(y_sim, u_sim), (x_sim, v_sim) = extract_centerlines(u, v, x, y, N)

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))

# u-velocity profile
ax1.plot(u_sim, y_sim, 'b-', label='Devito')
ax1.plot(u_ghia, y_ghia, 'ro', label='Ghia et al.')
ax1.set_xlabel('u')
ax1.set_ylabel('y')
ax1.set_title('u-velocity at x = 0.5')
ax1.legend()
ax1.grid(True)

# v-velocity profile
ax2.plot(x_sim, v_sim, 'b-', label='Devito')
ax2.plot(x_ghia, v_ghia, 'ro', label='Ghia et al.')
ax2.set_xlabel('x')
ax2.set_ylabel('v')
ax2.set_title('v-velocity at y = 0.5')
ax2.legend()
ax2.grid(True)

plt.tight_layout()
```

### Expected Agreement

With a 41 x 41 grid, we expect reasonable but not perfect agreement
with the benchmark. The Ghia results use much finer grids and more
sophisticated numerics. Key observations:

- **Near walls**: Steep velocity gradients may be under-resolved
- **Center region**: Good agreement expected
- **Velocity extrema**: May be slightly underpredicted

Grid refinement (81 x 81 or 129 x 129) significantly improves agreement.


## Reynolds Number Effects {#sec-cfd-reynolds}

The Reynolds number dramatically affects flow structure. Here we compare
solutions at Re = 100, 400, and 1000.

### Flow Visualization

The primary flow feature is a large recirculating vortex driven by the
lid. At higher Re:

1. The vortex center shifts toward the upper-right
2. Secondary corner vortices strengthen
3. Velocity gradients near walls steepen
4. More iterations are needed for steady state

### Streamlines

The stream function $\psi$ satisfies:
$$
u = \frac{\partial \psi}{\partial y}, \quad
v = -\frac{\partial \psi}{\partial x}
$$

Contours of $\psi$ are streamlines showing the flow pattern:

```python
def compute_streamfunction(u, v, dx, dy, N):
    """Compute stream function from velocity field."""
    psi = np.zeros((N, N))

    # Integrate -v along x
    for j in range(N):
        for i in range(1, N):
            psi[i, j] = psi[i-1, j] - v[i, j] * dx

    return psi

# Plot streamlines
psi = compute_streamfunction(u, v, dx, dy, N)
plt.contour(X, Y, psi, levels=20)
plt.title(f'Streamlines at Re = {Re}')
```

### Vortex Structure Evolution

| Re | Primary vortex center | Corner vortices |
|----|----------------------|-----------------|
| 100 | $(0.62, 0.74)$ | Weak, bottom corners |
| 400 | $(0.55, 0.61)$ | Visible, all corners |
| 1000 | $(0.53, 0.57)$ | Strong, secondary/tertiary |

The vortex center location from our simulation should match published
values to within a few percent.

### Computational Cost

Higher Reynolds numbers require:

- **Finer grids**: To resolve boundary layers
- **More time steps**: To reach steady state
- **More pressure iterations**: Due to stronger pressure gradients

A rough scaling: computational effort grows as $\text{Re}^2$ or faster.


## Complete Solver {#sec-cfd-complete}

We now present the complete solver that incorporates all the elements
discussed:

```python
from devito import Grid, TimeFunction, Function, Eq, solve, Operator
from devito import configuration
import numpy as np

def solve_cavity_2d(N=41, Re=100.0, nt=1000, nit=50, U_lid=1.0, L=1.0, rho=1.0):
    """Solve 2D lid-driven cavity flow using Devito.

    Parameters
    ----------
    N : int
        Grid points in each direction
    Re : float
        Reynolds number
    nt : int
        Number of time steps
    nit : int
        Pressure iterations per step
    U_lid : float
        Lid velocity
    L : float
        Cavity size
    rho : float
        Fluid density

    Returns
    -------
    dict
        Solution fields and coordinates
    """
    configuration['log-level'] = 'ERROR'

    # Derived quantities
    nu = U_lid * L / Re
    dx = L / (N - 1)
    dy = dx
    dt = min(0.5 * dx / U_lid, 0.25 * dx**2 / nu, 0.001)

    # Create grid and fields
    grid = Grid(shape=(N, N), extent=(L, L))
    x_dim, y_dim = grid.dimensions
    t = grid.stepping_dim

    u = TimeFunction(name='u', grid=grid, space_order=2)
    v = TimeFunction(name='v', grid=grid, space_order=2)
    p = TimeFunction(name='p', grid=grid, space_order=2)
    b = Function(name='b', grid=grid)

    # Initialize
    u.data[:] = 0.0
    v.data[:] = 0.0
    p.data[:] = 0.0

    # Momentum equations
    eq_u = Eq(u.dt + u*u.dx + v*u.dy,
              -1.0/rho * p.dxc + nu * u.laplace,
              subdomain=grid.interior)
    eq_v = Eq(v.dt + u*v.dx + v*v.dy,
              -1.0/rho * p.dyc + nu * v.laplace,
              subdomain=grid.interior)

    stencil_u = solve(eq_u, u.forward)
    stencil_v = solve(eq_v, v.forward)
    update_u = Eq(u.forward, stencil_u)
    update_v = Eq(v.forward, stencil_v)

    # Velocity BCs
    bc_u = [Eq(u[t+1, x_dim, 0], 0),
            Eq(u[t+1, x_dim, N-1], U_lid),
            Eq(u[t+1, 0, y_dim], 0),
            Eq(u[t+1, N-1, y_dim], 0)]
    bc_v = [Eq(v[t+1, x_dim, 0], 0),
            Eq(v[t+1, x_dim, N-1], 0),
            Eq(v[t+1, 0, y_dim], 0),
            Eq(v[t+1, N-1, y_dim], 0)]

    op_velocity = Operator([update_u, update_v] + bc_u + bc_v)

    # Pressure equation
    eq_p = Eq(p.laplace, b, subdomain=grid.interior)
    stencil_p = solve(eq_p, p)
    update_p = Eq(p.forward, stencil_p)

    bc_p = [Eq(p[t+1, 0, y_dim], p[t+1, 1, y_dim]),
            Eq(p[t+1, N-1, y_dim], p[t+1, N-2, y_dim]),
            Eq(p[t+1, x_dim, 0], p[t+1, x_dim, 1]),
            Eq(p[t+1, x_dim, N-1], p[t+1, x_dim, N-2]),
            Eq(p[t+1, 0, 0], 0)]

    op_pressure = Operator([update_p] + bc_p)

    # Time stepping
    for step in range(nt):
        # Compute pressure RHS
        u_curr = u.data[0]
        v_curr = v.data[0]
        b.data[1:-1, 1:-1] = rho * (
            1.0/dt * ((u_curr[2:, 1:-1] - u_curr[:-2, 1:-1]) / (2*dx) +
                      (v_curr[1:-1, 2:] - v_curr[1:-1, :-2]) / (2*dy)) -
            ((u_curr[2:, 1:-1] - u_curr[:-2, 1:-1]) / (2*dx))**2 -
            2 * ((u_curr[1:-1, 2:] - u_curr[1:-1, :-2]) / (2*dy) *
                 (v_curr[2:, 1:-1] - v_curr[:-2, 1:-1]) / (2*dx)) -
            ((v_curr[1:-1, 2:] - v_curr[1:-1, :-2]) / (2*dy))**2
        )

        # Solve pressure
        if step > 0:
            op_pressure(time_M=nit)

        # Update velocity
        op_velocity(time_m=step, time_M=step, dt=dt)

    # Return results
    x = np.linspace(0, L, N)
    y = np.linspace(0, L, N)

    return {
        'u': u.data[0].copy(),
        'v': v.data[0].copy(),
        'p': p.data[0].copy(),
        'x': x,
        'y': y,
        'Re': Re,
    }
```

### Usage Example

```python
# Solve at Re = 100
result = solve_cavity_2d(N=41, Re=100.0, nt=1000, nit=50)

# Visualize
import matplotlib.pyplot as plt
from matplotlib import cm

X, Y = np.meshgrid(result['x'], result['y'], indexing='ij')

fig = plt.figure(figsize=(12, 5))

# Pressure contours with velocity vectors
ax1 = fig.add_subplot(121)
cf = ax1.contourf(X, Y, result['p'], levels=20, cmap=cm.viridis)
plt.colorbar(cf, ax=ax1)
ax1.quiver(X[::2, ::2], Y[::2, ::2],
           result['u'][::2, ::2], result['v'][::2, ::2])
ax1.set_xlabel('x')
ax1.set_ylabel('y')
ax1.set_title(f'Pressure and Velocity, Re = {result["Re"]}')
ax1.set_aspect('equal')

# Streamlines
ax2 = fig.add_subplot(122)
psi = compute_streamfunction(result['u'], result['v'],
                             result['x'][1] - result['x'][0],
                             result['y'][1] - result['y'][0], len(result['x']))
ax2.contour(X, Y, psi, levels=30, cmap=cm.RdBu)
ax2.set_xlabel('x')
ax2.set_ylabel('y')
ax2.set_title('Streamlines')
ax2.set_aspect('equal')

plt.tight_layout()
plt.show()
```


## Exercises {#sec-cfd-exercises}

### Exercise 1: Grid Convergence Study

Run the cavity flow solver at Re = 100 with grid sizes N = 21, 41, 81,
and 129. Compare the centerline velocity profiles with the Ghia benchmark.

a) Plot the u-velocity along x = 0.5 for each grid resolution.
b) Compute the L2 error between your solution and Ghia's data for each N.
c) Estimate the order of convergence from the error reduction.

### Exercise 2: Reynolds Number Sweep

Solve the cavity flow at Re = 100, 400, 1000, and 3200 (all at N = 81).

a) Plot streamlines for each Reynolds number.
b) Track the primary vortex center position vs Re.
c) Compare centerline velocities with Ghia benchmark data.

### Exercise 3: Pressure Iteration Study

For Re = 100 on a 41 x 41 grid, investigate the effect of pressure
iterations per time step.

a) Run with nit = 10, 25, 50, 100, and 200.
b) Monitor the velocity divergence magnitude over time.
c) Determine the minimum nit needed for a stable solution.

### Exercise 4: Transient Evolution

Track the evolution from rest to steady state at Re = 400.

a) Save velocity fields every 100 time steps.
b) Plot the kinetic energy $E = \frac{1}{2}\int(u^2 + v^2)dA$ vs time.
c) At what time does the flow reach 99% of steady-state energy?

### Exercise 5: Vorticity Field

The vorticity $\omega = \partial v/\partial x - \partial u/\partial y$
measures local rotation.

a) Implement a function to compute vorticity from (u, v).
b) Plot vorticity contours for Re = 100 and Re = 1000.
c) Identify regions of maximum positive and negative vorticity.

### Exercise 6: Double Lid Cavity

Modify the boundary conditions for a cavity with two moving lids:

- Top lid: u = +1, v = 0 (moves right)
- Bottom lid: u = -1, v = 0 (moves left)
- Side walls: no-slip

a) Solve at Re = 100 and plot the resulting streamlines.
b) Compare the flow structure with the single-lid case.
c) Does the solution have any symmetry?

### Exercise 7: Time Step Stability

Investigate the stability limits of the time stepping scheme.

a) At Re = 100 with N = 41, find the maximum stable dt.
b) Compare with the CFL condition dt < dx/U.
c) Compare with the diffusive stability dt < dx^2/(4*nu).
d) Which constraint is more restrictive at this Re?

### Exercise 8: Alternative Pressure BCs

The standard approach uses dp/dn = 0 on all walls. Implement and test:

a) Fixing p = 0 on one entire wall (instead of one point).
b) Compare the resulting pressure fields.
c) Does the velocity field change significantly?

### Exercise 9: Performance Comparison

Compare the Devito solver with a pure NumPy implementation.

a) Implement the same algorithm in NumPy (see reference code in module).
b) Time both implementations for N = 81 and nt = 1000.
c) Calculate speedup and operations per second.

### Exercise 10: Extension to 3D

Outline (but do not implement) extensions needed for a 3D cavity:

a) What additional equations and variables are needed?
b) How do the boundary conditions change?
c) Estimate the computational cost increase (memory and time).
