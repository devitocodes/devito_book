## Source Terms and Variable Coefficients {#sec-wave-features}

Real-world wave propagation often involves source terms and
spatially varying wave speeds. This section extends the Devito
wave solver to handle these features.

### Adding a Source Term

The wave equation with a source term is:
$$
\frac{\partial^2 u}{\partial t^2} = c^2 \frac{\partial^2 u}{\partial x^2} + f(x, t)
$$ {#eq-wave-source}

In seismic applications, $f(x, t)$ often represents an impulsive
source at a specific location.

### Source Wavelets

The `src.wave` module provides common source wavelets used in
seismic modeling:

```python
from src.wave import ricker_wavelet, gaussian_pulse
import numpy as np

t = np.linspace(0, 0.5, 501)  # Time array

# Ricker wavelet with 25 Hz peak frequency
src_ricker = ricker_wavelet(t, f0=25.0)

# Gaussian pulse
src_gauss = gaussian_pulse(t, t0=0.1, sigma=0.02)
```

### The Ricker Wavelet

The Ricker wavelet (Mexican hat wavelet) is the negative normalized
second derivative of a Gaussian:
$$
r(t) = A \left(1 - 2\pi^2 f_0^2 (t - t_0)^2\right) e^{-\pi^2 f_0^2 (t - t_0)^2}
$$

where $f_0$ is the peak frequency and $t_0$ is the time shift.

```python
import matplotlib.pyplot as plt
from src.wave import ricker_wavelet, get_source_spectrum

t = np.linspace(0, 0.3, 301)
dt = t[1] - t[0]

# Create wavelet
wavelet = ricker_wavelet(t, f0=25.0)

# Compute spectrum
freq, amp = get_source_spectrum(wavelet, dt)

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4))
ax1.plot(t, wavelet)
ax1.set_xlabel('Time (s)')
ax1.set_ylabel('Amplitude')
ax1.set_title('Ricker Wavelet (f0 = 25 Hz)')

ax2.plot(freq[:100], amp[:100])
ax2.set_xlabel('Frequency (Hz)')
ax2.set_ylabel('Amplitude')
ax2.set_title('Frequency Spectrum')
ax2.axvline(25, color='r', linestyle='--', label='Peak freq')
ax2.legend()
```

### Point Sources in Devito

For seismic modeling, sources are often located at specific
points in space. Devito provides `SparseTimeFunction` for this:

```python
from devito import SparseTimeFunction

# Point source at x = 0.5
src = SparseTimeFunction(
    name='src', grid=grid,
    npoint=1, nt=Nt,
    coordinates=np.array([[0.5]])
)

# Set source wavelet
src.data[:] = ricker_wavelet(t, f0=25.0).reshape(-1, 1)

# Inject into the wave equation
src_term = src.inject(field=u.forward, expr=src * dt**2)
```

### Variable Wave Speed

In heterogeneous media, the wave speed varies in space:
$$
\frac{\partial^2 u}{\partial t^2} = \nabla \cdot (c^2(x) \nabla u)
$$

In 1D, this simplifies to:
$$
u_{tt} = (c^2 u_x)_x = c^2 u_{xx} + 2 c c_x u_x
$$

For smoothly varying $c(x)$, we can approximate this as:
$$
u_{tt} \approx c^2(x) u_{xx}
$$

### Implementing Variable Velocity in Devito

We use a `Function` (not `TimeFunction`) for the velocity field:

```python
from devito import Function

# Velocity field
c = Function(name='c', grid=grid)

# Set velocity values (e.g., layer model)
x_coords = np.linspace(0, L, Nx + 1)
c.data[:] = np.where(x_coords < 0.5, 1.0, 2.0)  # Two layers
```

The PDE uses this spatially varying velocity:

```python
pde = u.dt2 - c**2 * u.dx2
stencil = Eq(u.forward, solve(pde, u.forward))
```

### CFL Condition with Variable Velocity

When velocity varies, the CFL condition must use the maximum velocity:
$$
\Delta t \le \frac{\Delta x}{c_{\max}}
$$

```python
c_max = np.max(c.data)
dt_stable = dx / c_max
```

### Example: Wave Propagation in Layered Medium

Consider a domain with two layers of different wave speeds:

```python
from devito import Grid, TimeFunction, Function, Eq, solve, Operator

# Setup
L = 2.0
Nx = 200
grid = Grid(shape=(Nx + 1,), extent=(L,))

# Velocity: slow layer (c=1) then fast layer (c=2)
c = Function(name='c', grid=grid)
x_coords = np.linspace(0, L, Nx + 1)
c.data[:] = np.where(x_coords < 1.0, 1.0, 2.0)

# Wave field
u = TimeFunction(name='u', grid=grid, time_order=2, space_order=2)

# Initial condition: Gaussian pulse in slow region
sigma = 0.1
x0 = 0.3
u.data[0, :] = np.exp(-((x_coords - x0) / sigma)**2)
u.data[1, :] = u.data[0, :]

# Wave equation with variable velocity
pde = u.dt2 - c**2 * u.dx2
stencil = Eq(u.forward, solve(pde, u.forward))

# Boundary conditions
bc_left = Eq(u[grid.stepping_dim + 1, 0], 0)
bc_right = Eq(u[grid.stepping_dim + 1, Nx], 0)

# Operator
op = Operator([stencil, bc_left, bc_right])
```

When the pulse reaches the interface at $x = 1$:

1. Part of the wave is **reflected** back into the slow medium
2. Part of the wave is **transmitted** into the fast medium
3. The transmitted wave travels faster and has a different wavelength

### Reflection and Transmission Coefficients

At an interface between media with velocities $c_1$ and $c_2$,
the reflection coefficient is:
$$
R = \frac{c_2 - c_1}{c_2 + c_1}
$$

And the transmission coefficient is:
$$
T = \frac{2 c_2}{c_2 + c_1}
$$

For our example with $c_1 = 1$ and $c_2 = 2$:

- $R = (2 - 1)/(2 + 1) = 1/3$
- $T = 2 \cdot 2/(2 + 1) = 4/3$

The transmitted wave has larger amplitude but carries the same energy
(accounting for the velocity change).

### Absorbing Boundary Conditions

For open-domain problems, we want waves to leave without reflecting
from artificial boundaries. A simple approach is a **sponge layer**
that gradually damps the solution near boundaries:

```python
from devito import Function

# Damping coefficient (zero in interior, increasing at boundaries)
damp = Function(name='damp', grid=grid)

pad = 20  # Width of sponge layer
damp_profile = np.zeros(Nx + 1)
damp_profile[:pad] = 0.1 * (1 - np.linspace(0, 1, pad))
damp_profile[-pad:] = 0.1 * np.linspace(0, 1, pad)
damp.data[:] = damp_profile

# Modified PDE with damping term
pde_damped = u.dt2 + damp * u.dt - c**2 * u.dx2
```

The damping term $\gamma u_t$ removes energy from the wave as it
enters the sponge layer.

### Summary

Devito makes it straightforward to extend the basic wave solver
to handle:

- **Source terms**: Point sources and wavelets for seismic modeling
- **Variable velocity**: Layered or smooth velocity variations
- **Absorbing boundaries**: Sponge layers to reduce reflections

The key is that Devito handles the discretization automatically
once we express the PDE symbolically. This allows us to focus on
the physics rather than implementation details.
