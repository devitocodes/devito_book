## Introduction to PDE Systems {#sec-systems-intro}

So far in this book, we have focused on solving single PDEs: the wave
equation, diffusion equation, advection equation, and nonlinear extensions.
In many physical applications, however, we encounter *systems* of coupled
PDEs where multiple unknowns evolve together, with each equation depending
on several fields.

### Conservation Laws

Many important physical systems are described by *conservation laws*,
which express the fundamental principle that certain quantities (mass,
momentum, energy) cannot be created or destroyed, only transported.
The general form of a conservation law in one dimension is:

$$
\frac{\partial \mathbf{U}}{\partial t} + \frac{\partial \mathbf{F}(\mathbf{U})}{\partial x} = \mathbf{S}
$$ {#eq-conservation-law}

where:

- $\mathbf{U}$ is the vector of conserved quantities
- $\mathbf{F}(\mathbf{U})$ is the flux function (how quantities move through space)
- $\mathbf{S}$ is a source/sink term

In two dimensions, this extends to:

$$
\frac{\partial \mathbf{U}}{\partial t} + \frac{\partial \mathbf{F}}{\partial x} + \frac{\partial \mathbf{G}}{\partial y} = \mathbf{S}
$$ {#eq-conservation-law-2d}

### Coupling Between Equations

When we have multiple coupled PDEs, the unknowns in each equation depend
on the solutions of other equations. This creates computational challenges:

1. **Temporal coupling**: The time derivative in one equation involves
   terms from equations that have not yet been updated.

2. **Spatial coupling**: Spatial derivatives may involve multiple fields
   at the same location.

3. **Nonlinear coupling**: The coupling terms are often nonlinear,
   requiring careful treatment of products of unknowns.

### Hyperbolic Systems

The shallow water equations we study in this chapter form a *hyperbolic
system* of PDEs. Hyperbolic systems have the property that information
propagates at finite speeds, similar to the wave equation. This is in
contrast to parabolic systems (like coupled diffusion equations) where
information spreads instantaneously.

For hyperbolic systems, the CFL stability condition becomes:

$$
\Delta t \leq \frac{\Delta x}{\max|\lambda_i|}
$$

where $\lambda_i$ are the eigenvalues of the flux Jacobian matrix. For
shallow water, these eigenvalues correspond to wave speeds.

## The Shallow Water Equations {#sec-swe}

The 2D Shallow Water Equations (SWE) are a fundamental model in
computational geophysics and coastal engineering. They are derived from
the Navier-Stokes equations under the assumption that horizontal
length scales are much larger than the water depth.

### Physical Setup

Consider a body of water with:

- $h(x, y)$: bathymetry (depth from mean sea level to seafloor, static)
- $\eta(x, y, t)$: surface elevation above mean sea level (dynamic)
- $D = h + \eta$: total water column depth
- $u(x, y, t)$, $v(x, y, t)$: depth-averaged horizontal velocities

The shallow water approximation assumes that:

1. Horizontal length scales $L$ are much larger than depth $H$: $L \gg H$
2. Vertical accelerations are negligible compared to gravity
3. The pressure is hydrostatic: $p = \rho g (\eta - z)$

### Governing Equations

The 2D Shallow Water Equations consist of three coupled PDEs:

**Continuity equation (mass conservation):**

$$
\frac{\partial \eta}{\partial t} + \frac{\partial M}{\partial x} + \frac{\partial N}{\partial y} = 0
$$ {#eq-swe-continuity}

**x-Momentum equation:**

$$
\frac{\partial M}{\partial t} + \frac{\partial}{\partial x}\left(\frac{M^2}{D}\right) + \frac{\partial}{\partial y}\left(\frac{MN}{D}\right) + gD\frac{\partial \eta}{\partial x} + \frac{g\alpha^2}{D^{7/3}}M\sqrt{M^2+N^2} = 0
$$ {#eq-swe-xmom}

**y-Momentum equation:**

$$
\frac{\partial N}{\partial t} + \frac{\partial}{\partial x}\left(\frac{MN}{D}\right) + \frac{\partial}{\partial y}\left(\frac{N^2}{D}\right) + gD\frac{\partial \eta}{\partial y} + \frac{g\alpha^2}{D^{7/3}}N\sqrt{M^2+N^2} = 0
$$ {#eq-swe-ymom}

### Discharge Fluxes

Rather than solving for velocities $(u, v)$ directly, the SWE are typically
formulated in terms of *discharge fluxes* $M$ and $N$:

$$
\begin{aligned}
M &= \int_{-h}^{\eta} u\, dz = uD \\
N &= \int_{-h}^{\eta} v\, dz = vD
\end{aligned}
$$ {#eq-discharge-flux}

The discharge flux has units of $[\text{m}^2/\text{s}]$ and represents
the volume of water flowing per unit width per unit time. This formulation
has numerical advantages:

1. Mass conservation becomes linear in $M$ and $N$
2. The flux form handles moving shorelines better
3. Boundary conditions are more naturally expressed

### Physical Interpretation of Terms

Each term in the momentum equations has a physical meaning:

| Term | Physical Meaning |
|------|------------------|
| $\partial M/\partial t$ | Local acceleration |
| $\partial(M^2/D)/\partial x$ | Advection of x-momentum in x |
| $\partial(MN/D)/\partial y$ | Advection of x-momentum in y |
| $gD\partial\eta/\partial x$ | Pressure gradient (hydrostatic) |
| $g\alpha^2 M\sqrt{M^2+N^2}/D^{7/3}$ | Bottom friction |

### Manning's Roughness Coefficient

The friction term uses Manning's formula for open channel flow. The
Manning's roughness coefficient $\alpha$ depends on the seafloor:

| Surface Type | $\alpha$ |
|--------------|----------|
| Smooth concrete | 0.010 - 0.013 |
| Natural channels (good) | 0.020 - 0.030 |
| Natural channels (poor) | 0.050 - 0.070 |
| Vegetated floodplains | 0.100 - 0.200 |

For tsunami modeling in the open ocean, $\alpha \approx 0.025$ is typical.

### Applications

The Shallow Water Equations are used to model:

- **Tsunami propagation**: Large-scale ocean wave modeling
- **Storm surges**: Coastal flooding from hurricanes/cyclones
- **Dam breaks**: Sudden release of reservoir water
- **Tidal flows**: Estuarine and coastal circulation
- **River flooding**: Overbank flows and inundation

## Devito Implementation {#sec-swe-devito}

Implementing the Shallow Water Equations in Devito demonstrates several
powerful features for coupled systems:

1. **Multiple TimeFunction fields** for the three unknowns
2. **Function for static fields** (bathymetry)
3. **The solve() function** for isolating forward time terms
4. **ConditionalDimension** for efficient snapshot saving

### Setting Up the Grid and Fields

We begin by creating the computational grid and the required fields:

```python
from devito import Grid, TimeFunction, Function

# Create 2D grid
grid = Grid(shape=(Ny, Nx), extent=(Ly, Lx), dtype=np.float32)

# Three time-varying fields for the unknowns
eta = TimeFunction(name='eta', grid=grid, space_order=2)  # wave height
M = TimeFunction(name='M', grid=grid, space_order=2)      # x-discharge
N = TimeFunction(name='N', grid=grid, space_order=2)      # y-discharge

# Static fields
h = Function(name='h', grid=grid)   # bathymetry
D = Function(name='D', grid=grid)   # total depth (updated each step)
```

Note that `h` is a `Function` (not `TimeFunction`) because the bathymetry
is static---it does not change during the simulation. The total depth
`D` is also a `Function` but is updated at each time step as $D = h + \eta$.

### Writing the PDEs Symbolically

Devito allows us to write the PDEs in a form close to the mathematical
notation. For the continuity equation:

```python
from devito import Eq, solve

# Continuity: deta/dt + dM/dx + dN/dy = 0
# Using centered differences in space (.dxc, .dyc)
pde_eta = Eq(eta.dt + M.dxc + N.dyc)

# Solve for eta.forward
stencil_eta = solve(pde_eta, eta.forward)
```

The `.dxc` and `.dyc` operators compute centered finite differences:

- `.dxc` $\approx \frac{u_{i+1,j} - u_{i-1,j}}{2\Delta x}$
- `.dyc` $\approx \frac{u_{i,j+1} - u_{i,j-1}}{2\Delta y}$

### The solve() Function for Coupled Stencils

When we have nonlinear coupled equations, isolating the forward time
term algebraically is tedious and error-prone. Devito's `solve()` function
handles this automatically:

```python
from devito import sqrt

# Friction term
friction_M = g * alpha**2 * sqrt(M**2 + N**2) / D**(7./3.)

# x-Momentum PDE
pde_M = Eq(
    M.dt
    + (M**2 / D).dxc
    + (M * N / D).dyc
    + g * D * eta.forward.dxc
    + friction_M * M
)

# solve() isolates M.forward algebraically
stencil_M = solve(pde_M, M.forward)
```

The `solve()` function:

1. Parses the equation for the target term (`M.forward`)
2. Algebraically isolates it on the left-hand side
3. Returns the right-hand side expression

This is particularly valuable for the momentum equations where the
forward terms appear in multiple places.

### Update Equations with Subdomain

The update equations apply only to interior points, avoiding boundary
modifications:

```python
update_eta = Eq(eta.forward, stencil_eta, subdomain=grid.interior)
update_M = Eq(M.forward, stencil_M, subdomain=grid.interior)
update_N = Eq(N.forward, stencil_N, subdomain=grid.interior)
```

The `subdomain=grid.interior` restricts updates to interior points,
leaving boundary values unchanged. For tsunami modeling, this effectively
implements open (non-reflecting) boundaries as a first approximation.

### Updating the Total Depth

After updating $\eta$, we must update the total water depth:

```python
eq_D = Eq(D, eta.forward + h)
```

This equation is evaluated after the main updates, using the new value
of $\eta$.

### Complete Operator Construction

The full operator combines all equations:

```python
from devito import Operator

op = Operator([update_eta, update_M, update_N, eq_D])
```

### ConditionalDimension for Snapshots

For visualization and analysis, we often want to save the solution at
regular intervals without storing every time step (which would be
memory-prohibitive). Devito's `ConditionalDimension` provides efficient
subsampling:

```python
from devito import ConditionalDimension

# Save every 'factor' time steps
factor = round(Nt / nsnaps)
time_subsampled = ConditionalDimension(
    't_sub', parent=grid.time_dim, factor=factor
)

# Create TimeFunction that saves at reduced frequency
eta_save = TimeFunction(
    name='eta_save', grid=grid, space_order=2,
    save=nsnaps, time_dim=time_subsampled
)

# Add saving equation to operator
op = Operator([update_eta, update_M, update_N, eq_D, Eq(eta_save, eta)])
```

The `ConditionalDimension`:

1. Creates a time dimension that only activates every `factor` steps
2. Links it to a `TimeFunction` with `save=nsnaps` storage
3. Automatically manages indexing and memory allocation

### Running the Simulation

With all components in place, we run the simulation:

```python
# Apply operator for Nt time steps
op.apply(eta=eta, M=M, N=N, D=D, h=h, time=Nt-2, dt=dt)
```

The `time=Nt-2` specifies the number of iterations (Devito uses 0-based
indexing for the time loop).

## Example: Tsunami with Constant Depth {#sec-swe-constant-depth}

Let us model tsunami propagation in an ocean with constant depth.
This is the simplest case for understanding the basic wave behavior.

### Problem Setup

- Domain: $100 \times 100$ m
- Grid: $401 \times 401$ points
- Depth: $h = 50$ m (constant)
- Gravity: $g = 9.81$ m/s$^2$
- Manning's roughness: $\alpha = 0.025$
- Simulation time: $T = 3$ s

The initial condition is a Gaussian pulse at the center:

$$
\eta_0(x, y) = 0.5 \exp\left(-\frac{(x-50)^2}{10} - \frac{(y-50)^2}{10}\right)
$$

with initial discharge:

$$
M_0 = 100 \cdot \eta_0, \quad N_0 = 0
$$

### Devito Implementation

```python
from devito import Grid, TimeFunction, Function, Eq, Operator, solve, sqrt
import numpy as np

# Physical parameters
Lx, Ly = 100.0, 100.0  # Domain size [m]
Nx, Ny = 401, 401       # Grid points
g = 9.81                # Gravity [m/s^2]
alpha = 0.025           # Manning's roughness
h0 = 50.0               # Constant depth [m]

# Time stepping
Tmax = 3.0
dt = 1/4500
Nt = int(Tmax / dt)

# Create coordinate arrays
x = np.linspace(0.0, Lx, Nx)
y = np.linspace(0.0, Ly, Ny)
X, Y = np.meshgrid(x, y)

# Initial conditions
eta0 = 0.5 * np.exp(-((X - 50)**2 / 10) - ((Y - 50)**2 / 10))
M0 = 100.0 * eta0
N0 = np.zeros_like(M0)
h_array = h0 * np.ones_like(X)

# Create Devito grid
grid = Grid(shape=(Ny, Nx), extent=(Ly, Lx), dtype=np.float32)

# Create fields
eta = TimeFunction(name='eta', grid=grid, space_order=2)
M = TimeFunction(name='M', grid=grid, space_order=2)
N = TimeFunction(name='N', grid=grid, space_order=2)
h = Function(name='h', grid=grid)
D = Function(name='D', grid=grid)

# Set initial data
eta.data[0, :, :] = eta0
M.data[0, :, :] = M0
N.data[0, :, :] = N0
h.data[:] = h_array
D.data[:] = eta0 + h_array

# Build equations
friction_M = g * alpha**2 * sqrt(M**2 + N**2) / D**(7./3.)
friction_N = g * alpha**2 * sqrt(M.forward**2 + N**2) / D**(7./3.)

pde_eta = Eq(eta.dt + M.dxc + N.dyc)
pde_M = Eq(M.dt + (M**2/D).dxc + (M*N/D).dyc
           + g*D*eta.forward.dxc + friction_M*M)
pde_N = Eq(N.dt + (M.forward*N/D).dxc + (N**2/D).dyc
           + g*D*eta.forward.dyc + friction_N*N)

stencil_eta = solve(pde_eta, eta.forward)
stencil_M = solve(pde_M, M.forward)
stencil_N = solve(pde_N, N.forward)

update_eta = Eq(eta.forward, stencil_eta, subdomain=grid.interior)
update_M = Eq(M.forward, stencil_M, subdomain=grid.interior)
update_N = Eq(N.forward, stencil_N, subdomain=grid.interior)
eq_D = Eq(D, eta.forward + h)

# Create and run operator
op = Operator([update_eta, update_M, update_N, eq_D])
op.apply(eta=eta, M=M, N=N, D=D, h=h, time=Nt-2, dt=dt)
```

### Expected Behavior

In constant depth, the tsunami propagates outward as a circular wave
at the shallow water wave speed:

$$
c = \sqrt{gD} \approx \sqrt{9.81 \times 50} \approx 22.1 \text{ m/s}
$$

The wave maintains its circular shape but decreases in amplitude due to:

1. Geometric spreading (energy distributed over larger circumference)
2. Bottom friction (energy dissipation)

## Example: Tsunami with Varying Bathymetry {#sec-swe-bathymetry}

Real ocean bathymetry significantly affects tsunami propagation.
As waves approach shallow water, they slow down, their wavelength
decreases, and their amplitude increases---a process called *shoaling*.

### Tanh Depth Profile

A common test case uses a $\tanh$ profile to model a coastal transition:

$$
h(x, y) = h_{\text{deep}} - (h_{\text{deep}} - h_{\text{shallow}}) \cdot \frac{1 + \tanh((x - x_0)/w)}{2}
$$

This creates a smooth transition from deep water to shallow water.

### Implementation

```python
# Tanh bathymetry: deep on left, shallow on right
h_deep = 50.0   # Deep water depth [m]
h_shallow = 5.0 # Shallow water depth [m]
x_transition = 70.0  # Transition location
width = 8.0     # Transition width

h_array = h_deep - (h_deep - h_shallow) * (
    0.5 * (1 + np.tanh((X - x_transition) / width))
)

# Tsunami source in deep water
eta0 = 0.5 * np.exp(-((X - 30)**2 / 10) - ((Y - 50)**2 / 20))
```

### Physical Effects

As the tsunami propagates from deep to shallow water:

1. **Speed decreases**: $c = \sqrt{gh}$ drops from $\sim 22$ m/s to $\sim 7$ m/s
2. **Wavelength shortens**: Waves compress as they slow
3. **Amplitude increases**: Energy conservation requires higher waves
4. **Wave steepening**: Front of wave catches up to back

This shoaling effect is why tsunamis, barely noticeable in the open
ocean, become devastating near the coast.

## Example: Tsunami Interacting with a Seamount {#sec-swe-seamount}

Underwater topographic features like seamounts cause wave diffraction
and focusing effects.

### Seamount Bathymetry

A Gaussian seamount rising from a flat seafloor:

$$
h(x, y) = h_0 - A \exp\left(-\frac{(x-x_0)^2}{\sigma^2} - \frac{(y-y_0)^2}{\sigma^2}\right)
$$

where $A$ is the seamount height and $\sigma$ controls its width.

### Implementation

```python
# Constant depth with Gaussian seamount
h_base = 50.0    # Base depth [m]
x_mount, y_mount = 50.0, 50.0  # Seamount center
height = 45.0    # Height (leaves 5m above summit)
sigma = 20.0     # Width parameter

h_array = h_base * np.ones_like(X)
h_array -= height * np.exp(
    -((X - x_mount)**2 / sigma) - ((Y - y_mount)**2 / sigma)
)

# Tsunami source to the left of seamount
eta0 = 0.5 * np.exp(-((X - 30)**2 / 5) - ((Y - 50)**2 / 5))
```

### Physical Effects

When the tsunami encounters the seamount:

1. **Wave focusing**: Waves refract around the shallow region
2. **Energy concentration**: Waves converge behind the seamount
3. **Shadow zone**: Reduced amplitude directly behind
4. **Scattered waves**: Secondary circular waves radiate outward

## Using the Module Interface {#sec-swe-module}

The complete solver is available in `src/systems/swe_devito.py`.
The high-level interface simplifies common use cases:

```python
from src.systems import solve_swe
import numpy as np

# Constant depth simulation
result = solve_swe(
    Lx=100.0, Ly=100.0,
    Nx=201, Ny=201,
    T=2.0,
    dt=1/4000,
    g=9.81,
    alpha=0.025,
    h0=50.0,
    nsnaps=100  # Save 100 snapshots
)

# Access results
print(f"Final max wave height: {result.eta.max():.4f} m")
print(f"Snapshots shape: {result.eta_snapshots.shape}")
```

### Custom Bathymetry

For non-constant bathymetry, pass an array:

```python
# Create coordinate arrays
x = np.linspace(0, 100, 201)
y = np.linspace(0, 100, 201)
X, Y = np.meshgrid(x, y)

# Custom bathymetry with seamount
h_custom = 50.0 * np.ones_like(X)
h_custom -= 45.0 * np.exp(-((X-50)**2/20) - ((Y-50)**2/20))

# Solve with custom bathymetry
result = solve_swe(
    Lx=100.0, Ly=100.0,
    Nx=201, Ny=201,
    T=2.0,
    dt=1/4000,
    h0=h_custom,  # Pass array instead of scalar
)
```

### Custom Initial Conditions

Both initial wave height and discharge can be specified:

```python
# Two tsunami sources
eta0 = 0.5 * np.exp(-((X-35)**2/10) - ((Y-35)**2/10))
eta0 -= 0.5 * np.exp(-((X-65)**2/10) - ((Y-65)**2/10))

# Directional initial discharge
M0 = 100.0 * eta0
N0 = 50.0 * eta0  # Also some y-component

result = solve_swe(
    Lx=100.0, Ly=100.0,
    Nx=201, Ny=201,
    T=3.0,
    dt=1/4000,
    eta0=eta0,
    M0=M0,
    N0=N0,
)
```

### Helper Functions

Utility functions for common scenarios:

```python
from src.systems.swe_devito import (
    gaussian_tsunami_source,
    seamount_bathymetry,
    tanh_bathymetry
)

# Create coordinate grid
x = np.linspace(0, 100, 201)
y = np.linspace(0, 100, 201)
X, Y = np.meshgrid(x, y)

# Gaussian tsunami source
eta0 = gaussian_tsunami_source(X, Y, x0=30, y0=50, amplitude=0.5)

# Seamount bathymetry
h = seamount_bathymetry(X, Y, h_base=50, height=45, sigma=20)

# Or coastal profile
h = tanh_bathymetry(X, Y, h_deep=50, h_shallow=5, x_transition=70)
```

## Stability and Accuracy Considerations {#sec-swe-stability}

### CFL Condition

The shallow water equations have a CFL condition based on the gravity
wave speed:

$$
\Delta t \leq \frac{\min(\Delta x, \Delta y)}{\sqrt{g \cdot \max(D)}}
$$

For $g = 9.81$ m/s$^2$ and $D_{\max} = 50$ m:

$$
\sqrt{gD} \approx 22.1 \text{ m/s}
$$

With $\Delta x = 0.25$ m (for a 401-point grid over 100 m):

$$
\Delta t \leq \frac{0.25}{22.1} \approx 0.011 \text{ s}
$$

In practice, we use smaller time steps (e.g., $\Delta t = 1/4500 \approx 0.00022$ s)
for accuracy and to handle nonlinear effects.

### Grid Resolution

The grid must resolve the relevant wavelengths. For tsunami modeling:

- Open ocean wavelengths: 100--500 km (coarse grid acceptable)
- Coastal wavelengths: 1--10 km (finer grid needed)
- Near-shore: 10--100 m (very fine grid required)

### Boundary Conditions

The current implementation uses implicit open boundaries (values at
boundaries remain unchanged). For more accurate modeling, consider:

1. **Sponge layers**: Absorbing regions near boundaries
2. **Characteristic boundary conditions**: Based on wave directions
3. **Periodic boundaries**: For idealized studies

## Elastic Wave Equations {#sec-systems-elastic}

The elastic wave equations describe the propagation of seismic waves
through solid media. Unlike acoustic waves in fluids, elastic waves in
solids support both compressional (P) and shear (S) waves, each traveling
at different velocities. This makes elastic wave modeling essential for:

- **Seismic exploration**: Oil and gas reservoir characterization
- **Earthquake seismology**: Understanding ground motion and hazards
- **Non-destructive testing**: Material inspection and quality control
- **Full waveform inversion (FWI)**: High-resolution subsurface imaging

### The Velocity-Stress Formulation {#sec-systems-elastic-velstress}

The elastic wave equations can be written in several forms. The
*velocity-stress formulation* is particularly suited for finite difference
methods because it naturally leads to a staggered grid discretization
that improves accuracy and stability.

The coupled system consists of:

**Momentum equation** (Newton's second law):

$$
\rho \frac{\partial \mathbf{v}}{\partial t} = \nabla \cdot \boldsymbol{\tau}
$$ {#eq-elastic-momentum}

**Stress equation** (Hooke's law for isotropic media):

$$
\frac{\partial \boldsymbol{\tau}}{\partial t} = \lambda (\nabla \cdot \mathbf{v}) \mathbf{I} + \mu \left( \nabla \mathbf{v} + (\nabla \mathbf{v})^T \right)
$$ {#eq-elastic-stress}

where:

- $\mathbf{v} = (v_x, v_z)$ is the particle velocity vector
- $\boldsymbol{\tau}$ is the stress tensor
- $\rho$ is the density
- $\lambda$ and $\mu$ are the Lame parameters
- $\mathbf{I}$ is the identity tensor

### Lame Parameters and Wave Velocities {#sec-systems-elastic-lame}

The Lame parameters $\lambda$ and $\mu$ characterize the elastic properties
of the medium. The shear modulus $\mu$ (also called the second Lame parameter)
measures resistance to shear deformation. The first Lame parameter $\lambda$
relates volumetric stress to volumetric strain.

The P-wave (compressional) and S-wave (shear) velocities are related to
these parameters by:

$$
V_p = \sqrt{\frac{\lambda + 2\mu}{\rho}}, \quad V_s = \sqrt{\frac{\mu}{\rho}}
$$ {#eq-wave-velocities}

Conversely, given wave velocities and density:

$$
\mu = \rho V_s^2, \quad \lambda = \rho V_p^2 - 2\mu
$$ {#eq-lame-from-velocities}

For realistic materials, $V_p > V_s$ (typically $V_p/V_s \approx 1.7$--2.0
in crusite rocks). This means P-waves arrive before S-waves---the basis
for locating earthquakes.

### VectorTimeFunction and TensorTimeFunction {#sec-systems-elastic-tensors}

Devito provides specialized data types for vector and tensor fields that
greatly simplify the implementation of elastic wave equations.

**VectorTimeFunction** stores a time-varying vector field:

```python
from devito import Grid, VectorTimeFunction

grid = Grid(shape=(Nx, Nz), extent=(Lx, Lz))
v = VectorTimeFunction(name='v', grid=grid, space_order=2, time_order=1)

# Access components
vx = v[0]  # x-component of velocity
vz = v[1]  # z-component of velocity
```

**TensorTimeFunction** stores a time-varying tensor field. For the stress
tensor in 2D, we use a symmetric tensor:

```python
from devito import TensorTimeFunction

tau = TensorTimeFunction(name='t', grid=grid, space_order=2,
                         time_order=1, symmetric=True)

# Access components
tau_xx = tau[0, 0]  # Normal stress in x
tau_zz = tau[1, 1]  # Normal stress in z
tau_xz = tau[0, 1]  # Shear stress (= tau[1, 0] for symmetric)
```

The `symmetric=True` option ensures that off-diagonal components are
stored only once, exploiting the symmetry $\tau_{xz} = \tau_{zx}$.

### Vector Operators: div, grad, diag {#sec-systems-elastic-operators}

Devito provides symbolic vector calculus operators that work directly
with `VectorTimeFunction` and `TensorTimeFunction`:

**Divergence of a tensor** ($\nabla \cdot \boldsymbol{\tau}$):

```python
from devito import div

# div(tau) returns a vector
div_tau = div(tau)  # Vector: (d(tau_xx)/dx + d(tau_xz)/dz,
                    #          d(tau_xz)/dx + d(tau_zz)/dz)
```

**Gradient of a vector** ($\nabla \mathbf{v}$):

```python
from devito import grad

# grad(v) returns a tensor
grad_v = grad(v)  # Tensor: [[dv_x/dx, dv_x/dz],
                  #          [dv_z/dx, dv_z/dz]]
```

**Diagonal tensor from scalar** ($s \cdot \mathbf{I}$):

```python
from devito import diag

# diag(scalar) creates diagonal tensor
div_v = div(v)  # Scalar: dv_x/dx + dv_z/dz
diag_tensor = diag(div_v)  # Tensor: [[div_v, 0], [0, div_v]]
```

These operators handle the staggered grid discretization automatically
when used with staggered `VectorTimeFunction` and `TensorTimeFunction`.

### Staggered Grid Discretization {#sec-systems-elastic-staggered}

The velocity-stress formulation naturally leads to a staggered grid
arrangement where different field components are stored at different
locations within each cell. This staggering:

1. Improves numerical accuracy by centering spatial derivatives
2. Avoids spurious oscillations in the solution
3. Is handled automatically by Devito when using vector/tensor functions

In the standard Virieux staggered grid for 2D:

- Normal stresses $\tau_{xx}$, $\tau_{zz}$ are at cell centers
- Shear stress $\tau_{xz}$ is at cell corners
- Velocity $v_x$ is at cell edges (x-direction)
- Velocity $v_z$ is at cell edges (z-direction)

When you create a `VectorTimeFunction` or `TensorTimeFunction` in Devito,
the staggering is applied automatically, and the `div`, `grad`, and other
operators account for the grid layout when computing derivatives.

### Implementation in Devito {#sec-systems-elastic-implementation}

With the tensor types and operators, the elastic wave equations can be
written almost exactly as they appear mathematically:

```python
from devito import (
    Grid, VectorTimeFunction, TensorTimeFunction,
    Eq, Operator, solve, div, grad, diag
)

# Create grid
grid = Grid(shape=(Nx, Nz), extent=(Lx, Lz))

# Create fields
v = VectorTimeFunction(name='v', grid=grid, space_order=2, time_order=1)
tau = TensorTimeFunction(name='t', grid=grid, space_order=2, time_order=1)

# Material parameters
V_p, V_s = 2.0, 1.0  # Wave velocities [km/s]
rho = 1.8            # Density [g/cm^3]

# Compute Lame parameters
mu = rho * V_s**2
lam = rho * V_p**2 - 2 * mu
ro = 1.0 / rho  # Buoyancy (inverse density)

# Momentum equation: rho * dv/dt = div(tau)
# Rewritten as: dv/dt = (1/rho) * div(tau)
pde_v = v.dt - ro * div(tau)

# Stress equation: dtau/dt = lam * div(v) * I + mu * (grad(v) + grad(v)^T)
pde_tau = (
    tau.dt
    - lam * diag(div(v.forward))
    - mu * (grad(v.forward) + grad(v.forward).transpose(inner=False))
)

# Solve for forward time values
u_v = Eq(v.forward, solve(pde_v, v.forward))
u_tau = Eq(tau.forward, solve(pde_tau, tau.forward))

# Create operator
op = Operator([u_v, u_tau])
```

The key points are:

1. We use `v.forward` in the stress equation to ensure proper time stepping
2. The `.transpose(inner=False)` creates $(\nabla \mathbf{v})^T$ without
   contracting indices
3. The `solve()` function isolates the forward time terms automatically

### Example: P-wave and S-wave Propagation {#sec-systems-elastic-example}

Let us simulate wave propagation from an explosive source in a homogeneous
medium and observe the separation of P-waves and S-waves.

```python
from devito import (
    Grid, VectorTimeFunction, TensorTimeFunction,
    Eq, Operator, solve, div, grad, diag,
    SpaceDimension, Constant
)
import numpy as np

# Domain parameters
extent = (1500., 1500.)  # Domain size [m]
shape = (201, 201)       # Grid points

# Create grid with explicit spacing
dx = extent[0] / (shape[0] - 1)
dz = extent[1] / (shape[1] - 1)
x = SpaceDimension(name='x', spacing=Constant(name='h_x', value=dx))
z = SpaceDimension(name='z', spacing=Constant(name='h_z', value=dz))
grid = Grid(extent=extent, shape=shape, dimensions=(x, z))

# Material parameters
V_p = 2.0   # P-wave velocity [km/s]
V_s = 1.0   # S-wave velocity [km/s]
rho = 1.8   # Density [g/cm^3]

# Lame parameters
mu = rho * V_s**2
lam = rho * V_p**2 - 2 * mu
ro = 1.0 / rho

# Time stepping
dt = dx / (np.sqrt(2) * V_p) * 0.9  # CFL condition
T = 300.0  # Total time
Nt = int(T / dt)

# Create fields (space_order=2 for basic implementation)
so = 2
v = VectorTimeFunction(name='v', grid=grid, space_order=so, time_order=1)
tau = TensorTimeFunction(name='t', grid=grid, space_order=so, time_order=1)

# Elastic wave equations
pde_v = v.dt - ro * div(tau)
pde_tau = (
    tau.dt
    - lam * diag(div(v.forward))
    - mu * (grad(v.forward) + grad(v.forward).transpose(inner=False))
)

u_v = Eq(v.forward, solve(pde_v, v.forward))
u_tau = Eq(tau.forward, solve(pde_tau, tau.forward))

op = Operator([u_v, u_tau])

# Ricker wavelet source
def ricker_wavelet(t, f0, t0=None):
    if t0 is None:
        t0 = 1.0 / f0
    pi_f0_t = np.pi * f0 * (t - t0)
    return (1.0 - 2.0 * pi_f0_t**2) * np.exp(-pi_f0_t**2)

t_vals = np.arange(0, T, dt)
f0 = 0.01  # Dominant frequency
src = ricker_wavelet(t_vals, f0)

# Source location (center of domain)
src_x, src_z = shape[0] // 2, shape[1] // 2

# Run simulation with source injection
for n in range(Nt):
    # Inject explosive source into normal stresses
    if n < len(src):
        tau[0, 0].data[0, src_x, src_z] += src[n]
        tau[1, 1].data[0, src_x, src_z] += src[n]

    # Advance one time step
    op.apply(time_m=0, time_M=0, dt=dt)

# Results: v[0].data[0], v[1].data[0] contain final velocities
# tau[0,0].data[0], tau[1,1].data[0], tau[0,1].data[0] contain final stresses
```

After running this simulation, you will observe:

1. **P-wave**: A circular wavefront propagating at $V_p = 2$ km/s
2. **S-wave**: A slower circular wavefront at $V_s = 1$ km/s
3. **Wave separation**: The P-wave pulls ahead of the S-wave over time

For an explosive source (injecting into $\tau_{xx}$ and $\tau_{zz}$),
the P-wave is dominant. To generate stronger S-waves, you would inject
into the shear stress component $\tau_{xz}$.

### Varying Lame Parameters {#sec-systems-elastic-varying}

In realistic geophysical applications, the Lame parameters vary
spatially to represent layered or heterogeneous Earth structure. Devito
handles this naturally by using `Function` objects for the parameters:

```python
from devito import Function

# Create spatially varying parameters
lam_field = Function(name='lam', grid=grid, space_order=so)
mu_field = Function(name='mu', grid=grid, space_order=so)
b_field = Function(name='b', grid=grid, space_order=so)  # Buoyancy = 1/rho

# Create a layered model (5 layers with increasing velocity)
nlayers = 5
layer_thickness = shape[1] // nlayers

for i in range(nlayers):
    z_start = i * layer_thickness
    z_end = (i + 1) * layer_thickness if i < nlayers - 1 else shape[1]

    # Velocities increase with depth
    V_p_layer = 1.5 + i * 0.5  # 1.5 to 3.5 km/s
    V_s_layer = 0.5 + i * 0.4  # 0.5 to 2.1 km/s
    rho_layer = 1.0 + i * 0.4  # 1.0 to 2.6 g/cm^3

    mu_layer = rho_layer * V_s_layer**2
    lam_layer = rho_layer * V_p_layer**2 - 2 * mu_layer

    lam_field.data[:, z_start:z_end] = lam_layer
    mu_field.data[:, z_start:z_end] = mu_layer
    b_field.data[:, z_start:z_end] = 1.0 / rho_layer

# Use Function objects in the PDEs
pde_v = v.dt - b_field * div(tau)
pde_tau = (
    tau.dt
    - lam_field * diag(div(v.forward))
    - mu_field * (grad(v.forward) + grad(v.forward).transpose(inner=False))
)
```

With varying parameters:

- Waves refract (bend) at layer interfaces
- Reflections occur due to impedance contrasts
- P-to-S and S-to-P conversions happen at interfaces

### Exercises {#sec-systems-elastic-exercises}

::: {#exr-elastic-wave-speeds}
**Computing wave speeds**

Given a medium with $\lambda = 10$ GPa, $\mu = 5$ GPa, and
$\rho = 2500$ kg/m$^3$:

a) Calculate the P-wave velocity $V_p$
b) Calculate the S-wave velocity $V_s$
c) Calculate the ratio $V_p/V_s$ and compare to the theoretical
   minimum of $\sqrt{2}$ for $\lambda = 0$
:::

::: {#exr-elastic-cfl}
**CFL condition for elastic waves**

The CFL stability condition for the elastic wave equation is:

$$
\Delta t \leq \frac{\Delta x}{\sqrt{2} V_p}
$$

For a 201 x 201 grid over a 3 km x 3 km domain with $V_p = 4$ km/s:

a) Calculate the maximum stable time step
b) How many time steps are needed to simulate 2 seconds?
c) If you use higher-order spatial discretization (space_order=8),
   does the CFL condition change?
:::

::: {#exr-elastic-source}
**Source mechanisms**

Modify the explosive source example to:

a) Create a vertical force source by injecting into $v_z$ instead of
   the stress tensor
b) Create a shear source by injecting into $\tau_{xz}$
c) Compare the radiation patterns of P-waves and S-waves for each source type
:::

::: {#exr-elastic-receiver}
**Recording seismic data**

Extend the elastic wave solver to:

a) Record velocity components at a line of receivers along $z = 10$ m
b) Plot the receiver data as a "shot gather" (time vs. receiver position)
c) Identify the P-wave and S-wave arrivals in the data
:::

::: {#exr-elastic-layered}
**Layered medium**

Using the varying Lame parameters approach:

a) Create a two-layer model with a velocity contrast at depth $z = 750$ m
b) Place a source at the surface and observe reflections from the interface
c) Measure the reflection coefficient and compare to the theoretical value:
   $R = \frac{\rho_2 V_{p2} - \rho_1 V_{p1}}{\rho_2 V_{p2} + \rho_1 V_{p1}}$
:::

## Viscoacoustic Wave Equations {#sec-viscoacoustic}

The elastic and acoustic wave equations we have studied assume that
wave propagation is lossless---energy is conserved as waves travel
through the medium. In real Earth materials, however, seismic waves
lose energy as they propagate due to *attenuation*. This energy loss
causes wave amplitudes to decrease and affects the frequency content
of signals. Modeling attenuation is essential for:

- **Seismic imaging**: Q compensation in migration algorithms
- **Full waveform inversion (FWI)**: Accurate amplitude fitting
- **Reservoir characterization**: Oil and gas cause anomalous attenuation
- **Earthquake seismology**: Understanding ground motion decay

### The Quality Factor Q {#sec-quality-factor}

Attenuation in seismic wave propagation is quantified by the *quality
factor* $Q$, a dimensionless number defined as:

$$
Q = 2\pi \frac{E}{\Delta E}
$$ {#eq-q-definition}

where $E$ is the energy stored in the wave and $\Delta E$ is the energy
lost per cycle. A high $Q$ means low attenuation (the wave travels far
with little energy loss), while a low $Q$ means high attenuation.

Typical values in the Earth:

| Material | Q |
|----------|---|
| Steel | 5000 |
| Granite | 100--500 |
| Sandstone (dry) | 50--100 |
| Sandstone (oil-saturated) | 10--50 |
| Sediments | 20--100 |
| Water | nearly $\infty$ |

The relationship between $Q$ and amplitude decay over distance $x$ is:

$$
A(x) = A_0 \exp\left(-\frac{\omega x}{2 v Q}\right)
$$ {#eq-amplitude-decay}

where $\omega = 2\pi f$ is the angular frequency and $v$ is velocity.
This shows that high frequencies attenuate faster than low frequencies,
leading to *dispersion* (frequency-dependent velocity).

### Rheological Models {#sec-rheological-models}

Several mathematical models exist to incorporate attenuation into
wave equations. Each has trade-offs between accuracy, computational
cost, and ease of implementation.

#### Standard Linear Solid (SLS) Model

The Standard Linear Solid (SLS) model, also known as the Zener model,
uses a *memory variable* to capture the viscoelastic behavior of the
medium. This approach accurately models frequency-dependent $Q$ across
a broad bandwidth.

The first-order velocity-pressure formulation with memory variable is:

$$
\begin{aligned}
\frac{\partial P}{\partial t} + \kappa (\tau + 1) \nabla \cdot \mathbf{v} + r &= S \\
\frac{\partial \mathbf{v}}{\partial t} + \frac{1}{\rho} \nabla P &= 0 \\
\frac{\partial r}{\partial t} + \frac{1}{\tau_\sigma} \left( r + \tau \kappa \nabla \cdot \mathbf{v} \right) &= 0
\end{aligned}
$$ {#eq-sls-system}

where:

- $P$ is the pressure field
- $\mathbf{v} = (v_x, v_z)$ is particle velocity
- $r$ is the memory variable
- $\kappa = \rho v_p^2$ is the bulk modulus
- $\tau = \tau_\epsilon / \tau_\sigma - 1$ is the relaxation magnitude
- $\tau_\sigma$ and $\tau_\epsilon$ are stress and strain relaxation times

The relaxation parameters are computed from $Q$ and the reference
frequency $f_0$:

$$
\tau_\sigma = \frac{\sqrt{Q^2 + 1} - 1}{2\pi f_0 Q}, \quad
\tau_\epsilon = \frac{\sqrt{Q^2 + 1} + 1}{2\pi f_0 Q}
$$ {#eq-relaxation-times}

This can be simplified to:

$$
\tau_\sigma = \frac{\sqrt{1 + 1/Q^2} - 1/Q}{f_0}, \quad
\tau_\epsilon = \frac{1}{f_0^2 \tau_\sigma}
$$ {#eq-relaxation-simplified}

#### Kelvin-Voigt Model

The Kelvin-Voigt model adds a viscosity term directly to the wave equation:

$$
\frac{\partial^2 P}{\partial t^2} - v^2 \nabla^2 P - \eta \nabla^2 \left(\frac{\partial P}{\partial t}\right) = S
$$ {#eq-kelvin-voigt-second}

where $\eta = v^2 / (\omega_0 Q)$ is the viscosity coefficient.

In first-order form:

$$
\begin{aligned}
\frac{\partial P}{\partial t} + \kappa \nabla \cdot \mathbf{v} - \eta \rho \nabla \cdot \left(\frac{1}{\rho} \nabla P\right) &= S \\
\frac{\partial \mathbf{v}}{\partial t} + \frac{1}{\rho} \nabla P &= 0
\end{aligned}
$$ {#eq-kelvin-voigt-system}

The Kelvin-Voigt model is simpler than SLS (no memory variable) but
provides frequency-dependent attenuation that increases with frequency.

#### Maxwell Model

The Maxwell model uses a simple absorption coefficient $g$:

$$
\begin{aligned}
\frac{\partial P}{\partial t} + \kappa \nabla \cdot \mathbf{v} + \frac{\omega_0}{Q} P &= S \\
\frac{\partial \mathbf{v}}{\partial t} + \frac{1}{\rho} \nabla P &= 0
\end{aligned}
$$ {#eq-maxwell-system}

where $\omega_0 = 2\pi f_0$ is the angular reference frequency. The
absorption coefficient is $g = \omega_0 / Q$.

This is the simplest approach computationally but provides constant
(frequency-independent) attenuation, which is less physically realistic.

### Devito Implementation of the SLS Model {#sec-sls-devito}

The SLS viscoacoustic equations can be implemented in Devito using the
explicit API:

```python
from devito import (
    Grid, VectorTimeFunction, TimeFunction, Function,
    Eq, Operator, div, grad, solve
)
import numpy as np

# Domain and grid setup
Lx, Lz = 6000.0, 6000.0  # meters
Nx, Nz = 301, 301
grid = Grid(shape=(Nx, Nz), extent=(Lx, Lz), dtype=np.float32)

# Material parameters
space_order = 8
vp = Function(name='vp', grid=grid, space_order=space_order)
b = Function(name='b', grid=grid, space_order=space_order)   # buoyancy = 1/rho
qp = Function(name='qp', grid=grid, space_order=space_order)

# Set parameter values (here constant, but can be spatially varying)
vp.data[:] = 2.0   # km/s
b.data[:] = 1.0    # 1/rho
qp.data[:] = 50.0  # Quality factor

# Reference frequency
f0 = 0.005  # kHz

# Compute relaxation parameters
Q = qp.data
t_s = (np.sqrt(1.0 + 1.0/Q**2) - 1.0/Q) / f0
t_ep = 1.0 / (f0**2 * t_s)
tau = t_ep / t_s - 1.0

# Create Functions for relaxation parameters
t_s_fn = Function(name='t_s', grid=grid, space_order=space_order)
tau_fn = Function(name='tau', grid=grid, space_order=space_order)
t_s_fn.data[:] = t_s
tau_fn.data[:] = tau

# Bulk modulus
bm = Function(name='bm', grid=grid, space_order=space_order)
rho = 1.0 / b.data
bm.data[:] = rho * vp.data**2

# Create fields
v = VectorTimeFunction(name='v', grid=grid, time_order=1, space_order=space_order)
p = TimeFunction(name='p', grid=grid, time_order=1, space_order=space_order)
r = TimeFunction(name='r', grid=grid, time_order=1, space_order=space_order)

# SLS equations
# dv/dt + b * grad(p) = 0
pde_v = v.dt + b * grad(p)
u_v = Eq(v.forward, solve(pde_v, v.forward))

# dr/dt + (1/t_s) * (r + tau * bm * div(v.forward)) = 0
pde_r = r.dt + (1.0 / t_s_fn) * (r + tau_fn * bm * div(v.forward))
u_r = Eq(r.forward, solve(pde_r, r.forward))

# dp/dt + bm * (tau + 1) * div(v.forward) + r.forward = 0
pde_p = p.dt + bm * (tau_fn + 1.0) * div(v.forward) + r.forward
u_p = Eq(p.forward, solve(pde_p, p.forward))

# Create operator
op = Operator([u_v, u_r, u_p])
```

The key differences from the acoustic case are:

1. **Memory variable** $r$: An additional `TimeFunction` that tracks
   the viscoelastic memory of the medium.

2. **Relaxation parameters**: The `t_s` and `tau` fields control the
   attenuation behavior. These are derived from $Q$.

3. **Three coupled PDEs**: The velocity, memory, and pressure equations
   must be solved together at each time step.

### Using the Module Interface {#sec-viscoacoustic-module}

The complete viscoacoustic solvers are available in
`src/systems/viscoacoustic_devito.py`:

```python
from src.systems import solve_viscoacoustic_sls

result = solve_viscoacoustic_sls(
    Lx=6000.0, Lz=6000.0,  # Domain [m]
    Nx=301, Nz=301,         # Grid points
    T=2000.0,               # Simulation time [ms]
    vp=2.0,                 # P-wave velocity [km/s]
    rho=1.0,                # Density
    Q=50.0,                 # Quality factor
    f0=0.005,               # Reference frequency [kHz]
)

# Access results
print(f"Max pressure: {result.p.max():.6f}")
```

All three rheological models are available:

```python
from src.systems import (
    solve_viscoacoustic_sls,      # Standard Linear Solid
    solve_viscoacoustic_kv,       # Kelvin-Voigt
    solve_viscoacoustic_maxwell,  # Maxwell
)
```

### Comparison of Rheological Models {#sec-rheological-comparison}

| Model | Memory Vars | Q Accuracy | Complexity | Use Case |
|-------|-------------|------------|------------|----------|
| SLS | Yes (1) | Excellent | Medium | FWI, RTM |
| Kelvin-Voigt | No | Good | Low | Simple modeling |
| Maxwell | No | Fair | Lowest | Quick tests |

The SLS model is most widely used in production seismic imaging because
it accurately captures the frequency-dependent nature of real-world
attenuation. The Kelvin-Voigt model provides a good balance of accuracy
and simplicity. The Maxwell model is useful for quick tests but should
not be used when accurate amplitude information is needed.

## Viscoelastic Wave Equations {#sec-viscoelastic}

While viscoacoustic equations model attenuation in fluids and for P-waves
only, *viscoelastic* equations extend this to solid media where both
P-waves and S-waves experience attenuation. This requires separate
quality factors $Q_p$ (for P-waves) and $Q_s$ (for S-waves).

### The Velocity-Stress Formulation with Attenuation {#sec-viscoelastic-formulation}

The 3D viscoelastic wave equations in velocity-stress form with
memory variables are:

**Momentum equation:**

$$
\rho \frac{\partial \mathbf{v}}{\partial t} = \nabla \cdot \boldsymbol{\tau}
$$ {#eq-viscoelastic-momentum}

**Stress equation with relaxation:**

$$
\frac{\partial \boldsymbol{\tau}}{\partial t} =
\lambda \frac{\tau_{\epsilon,p}}{\tau_\sigma} (\nabla \cdot \mathbf{v}) \mathbf{I} +
\mu \frac{\tau_{\epsilon,s}}{\tau_\sigma} \mathbf{e} + \mathbf{r}
$$ {#eq-viscoelastic-stress}

**Memory variable equation:**

$$
\frac{\partial \mathbf{r}}{\partial t} + \frac{1}{\tau_\sigma} \left(
\mathbf{r} +
\lambda \left(\frac{\tau_{\epsilon,p}}{\tau_\sigma} - 1\right) (\nabla \cdot \mathbf{v}) \mathbf{I} +
\mu \left(\frac{\tau_{\epsilon,s}}{\tau_\sigma} - 1\right) \mathbf{e}
\right) = 0
$$ {#eq-viscoelastic-memory}

where:

- $\mathbf{v} = (v_x, v_y, v_z)$ is the velocity vector
- $\boldsymbol{\tau}$ is the stress tensor
- $\mathbf{r}$ is the memory tensor
- $\mathbf{e} = \nabla \mathbf{v} + (\nabla \mathbf{v})^T$ is the strain rate tensor
- $\tau_\sigma$ is the stress relaxation time (from $Q_p$)
- $\tau_{\epsilon,p}$ is the strain relaxation time for P-waves
- $\tau_{\epsilon,s}$ is the strain relaxation time for S-waves

### Relaxation Parameters for P and S Waves {#sec-viscoelastic-relaxation}

The relaxation times are computed from the quality factors:

$$
\tau_\sigma = \frac{\sqrt{1 + 1/Q_p^2} - 1/Q_p}{f_0}
$$ {#eq-tau-sigma}

$$
\tau_{\epsilon,p} = \frac{1}{f_0^2 \tau_\sigma}
$$ {#eq-tau-ep}

$$
\tau_{\epsilon,s} = \frac{1 + f_0 Q_s \tau_\sigma}{f_0 Q_s - f_0^2 \tau_\sigma}
$$ {#eq-tau-es}

For fluid layers (water) where $V_s = 0$ and $Q_s = 0$, special
handling is required. Setting $\tau_{\epsilon,s} = \tau_{\epsilon,p}$
in fluid regions effectively disables shear wave attenuation.

### TensorTimeFunction for Memory Variables {#sec-tensor-memory}

The viscoelastic equations require tensor memory variables. In Devito,
we use `TensorTimeFunction` for both the stress $\boldsymbol{\tau}$
and memory $\mathbf{r}$:

```python
from devito import (
    Grid, VectorTimeFunction, TensorTimeFunction, Function,
    Eq, Operator, div, grad, diag, solve
)

# 3D Grid
grid = Grid(shape=(Nx, Ny, Nz), extent=(Lx, Ly, Lz))

# Velocity vector (3 components)
v = VectorTimeFunction(name='v', grid=grid, time_order=1, space_order=4)

# Stress tensor (6 unique components for symmetric 3x3)
tau = TensorTimeFunction(name='t', grid=grid, time_order=1, space_order=4)

# Memory tensor (same structure as stress)
r = TensorTimeFunction(name='r', grid=grid, time_order=1, space_order=4)
```

The `TensorTimeFunction` automatically handles the 3D tensor structure:

- `tau[0, 0]` = $\tau_{xx}$
- `tau[1, 1]` = $\tau_{yy}$
- `tau[2, 2]` = $\tau_{zz}$
- `tau[0, 1]` = $\tau_{xy}$
- `tau[0, 2]` = $\tau_{xz}$
- `tau[1, 2]` = $\tau_{yz}$

### Devito Implementation {#sec-viscoelastic-devito}

The complete viscoelastic equations in Devito:

```python
# Material parameter Functions
l = Function(name='l', grid=grid, space_order=so)       # lambda
mu = Function(name='mu', grid=grid, space_order=so)     # shear modulus
b = Function(name='b', grid=grid, space_order=so)       # buoyancy = 1/rho

# Relaxation parameter Functions
t_s = Function(name='t_s', grid=grid, space_order=so)   # tau_sigma
t_ep = Function(name='t_ep', grid=grid, space_order=so) # tau_epsilon_p
t_es = Function(name='t_es', grid=grid, space_order=so) # tau_epsilon_s

# Strain rate tensor: e = grad(v) + grad(v)^T
e = grad(v.forward) + grad(v.forward).transpose(inner=False)

# Particle velocity equation: dv/dt = b * div(tau)
pde_v = v.dt - b * div(tau)
u_v = Eq(v.forward, solve(pde_v, v.forward))

# Stress equation with memory:
# dtau/dt = l*(t_ep/t_s)*div(v)*I + mu*(t_es/t_s)*e - r
pde_tau = (
    tau.dt
    - r.forward
    - l * (t_ep / t_s) * diag(div(v.forward))
    - mu * (t_es / t_s) * e
)
u_tau = Eq(tau.forward, solve(pde_tau, tau.forward))

# Memory variable equation:
# dr/dt + (1/t_s)*(r + l*(t_ep/t_s - 1)*div(v)*I + mu*(t_es/t_s - 1)*e) = 0
pde_r = (
    r.dt
    + (1.0 / t_s) * (
        r
        + l * (t_ep / t_s - 1.0) * diag(div(v.forward))
        + mu * (t_es / t_s - 1.0) * e
    )
)
u_r = Eq(r.forward, solve(pde_r, r.forward))

# Create operator
op = Operator([u_v, u_r, u_tau])
```

Key points:

1. **Three tensor equations**: Velocity, memory, and stress are all
   coupled tensors.

2. **The `diag()` function**: Creates a diagonal tensor from a scalar
   (the divergence), representing $(\nabla \cdot \mathbf{v}) \mathbf{I}$.

3. **Transpose with `inner=False`**: The `transpose(inner=False)`
   transposes the spatial indices of the gradient tensor without
   contracting them.

4. **Order of equations**: The memory variable equation uses `v.forward`
   to ensure consistent time stepping.

### Example: Marine Seismic with Water Layer {#sec-viscoelastic-marine}

A common application is marine seismic modeling with a water layer
(fluid) over sediments and rock (solids):

```python
from src.systems import solve_viscoelastic_3d, create_layered_model_3d

# Create a 3-layer model: water, sediment, rock
shape = (201, 101, 101)  # Nx, Ny, Nz
vp, vs, Qp, Qs, rho = create_layered_model_3d(
    shape,
    vp_layers=[1.52, 1.6, 2.2],      # km/s
    vs_layers=[0.0, 0.4, 1.2],       # km/s (water has vs=0)
    Qp_layers=[10000., 40., 100.],   # Q for P-waves
    Qs_layers=[0., 30., 70.],        # Q for S-waves (water has Qs=0)
    rho_layers=[1.05, 1.3, 2.0],     # g/cm^3
    layer_depths=[0, 50, 54],        # layer interfaces in z-index
)

# Run simulation
result = solve_viscoelastic_3d(
    extent=(200., 100., 100.),  # meters
    shape=shape,
    T=30.0,                     # milliseconds
    vp=vp, vs=vs, rho=rho,
    Qp=Qp, Qs=Qs,
    f0=0.12,                    # reference frequency
    src_coords=(100., 50., 35.), # source location
)
```

In this example:

- The **water layer** ($V_s = 0$, $Q_s = 0$) only supports P-waves
- The **sediment layer** has low $Q$ values (high attenuation)
- The **rock layer** has higher $Q$ values (less attenuation)

### Stability Considerations {#sec-viscoelastic-stability}

The viscoelastic wave equation can be less stable than the elastic
case due to the memory variables. A smaller time step (typically
0.9$\times$ the elastic CFL limit) is recommended:

$$
\Delta t \leq 0.9 \times \frac{h}{\sqrt{3} V_{p,\max}}
$$

where $h = \min(\Delta x, \Delta y, \Delta z)$ is the minimum grid
spacing in 3D.

### Exercises {#sec-viscoelastic-exercises}

::: {#exr-viscoacoustic-q}
**Effect of Q on wave propagation**

Using the viscoacoustic solver:

a) Run simulations with $Q = 20$, $Q = 50$, and $Q = 200$
b) Compare the maximum pressure amplitude at the same time
c) Plot amplitude vs. distance from source for each case
d) Verify the exponential decay relationship @eq-amplitude-decay
:::

::: {#exr-viscoacoustic-models}
**Comparing rheological models**

a) Run the same problem with SLS, Kelvin-Voigt, and Maxwell models
b) Compare the wavefield snapshots at the same time
c) Compare computational time for each model
d) Which model would you choose for FWI and why?
:::

::: {#exr-viscoelastic-marine}
**Marine seismic simulation**

Using the viscoelastic solver:

a) Create a model with 50 m water layer over rock
b) Place a source at 35 m depth (in the water)
c) Observe the P-wave transmission into the rock
d) Identify the water-bottom reflection in the data
e) Why are there no S-waves in the water layer?
:::

::: {#exr-viscoelastic-memory}
**Understanding memory variables**

a) Run a viscoelastic simulation and plot the memory tensor component $r_{xx}$
b) Compare the memory variable magnitude for high and low $Q$
c) What happens to the memory variable as $Q \to \infty$?
d) Explain why memory variables are necessary for accurate attenuation modeling
:::

## Key Takeaways {#sec-systems-summary}

1. **Systems of PDEs** require careful treatment of coupling between
   unknowns, both in time and space.

2. **The Shallow Water Equations** are a fundamental hyperbolic system
   used for tsunami, storm surge, and flood modeling.

3. **The Elastic Wave Equations** model seismic wave propagation in solids,
   supporting both P-waves (compressional) and S-waves (shear).

4. **The Viscoacoustic Wave Equations** add attenuation to acoustic/P-wave
   propagation using the quality factor $Q$ and rheological models (SLS,
   Kelvin-Voigt, Maxwell).

5. **The Viscoelastic Wave Equations** extend attenuation modeling to full
   elastic media with separate $Q_p$ and $Q_s$ for P-waves and S-waves.

6. **Memory variables** in SLS and viscoelastic models capture the
   history-dependent response of attenuating media.

7. **Devito's solve() function** automatically isolates forward time
   terms in coupled nonlinear equations.

8. **VectorTimeFunction and TensorTimeFunction** provide convenient
   abstractions for vector and tensor fields in Devito.

9. **Vector operators** (div, grad, diag) work directly with tensor types
   and handle staggered grid discretization automatically.

10. **Static fields** (like bathymetry or Lame parameters) use `Function`
    instead of `TimeFunction` to avoid unnecessary time indexing.

11. **ConditionalDimension** enables efficient snapshot saving without
    storing every time step.

12. **Staggered grids** improve accuracy for first-order hyperbolic systems
    like the velocity-stress formulation of elastic and viscoelastic waves.
