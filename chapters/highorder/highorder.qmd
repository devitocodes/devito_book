## Introduction to High-Order Methods {#sec-highorder-intro}

In previous chapters, we have used second-order accurate finite difference
schemes for spatial discretization. While these schemes are straightforward
and widely applicable, they can introduce significant numerical errors,
particularly *numerical dispersion* in wave propagation problems. This
chapter explores high-order methods that mitigate these errors.

### Why High-Order Methods?

When solving the wave equation, standard finite difference schemes introduce
*numerical dispersion*: different frequency components of the solution travel
at different speeds, causing waves to distort as they propagate. This effect
becomes more pronounced when:

- The wavelength approaches the grid spacing (high wavenumber content)
- Waves propagate over long distances
- Multiple reflections occur

The severity of numerical dispersion depends on the *order* of the spatial
discretization. Higher-order schemes use wider stencils with more grid points,
achieving better accuracy for the same grid spacing or allowing coarser grids
for the same accuracy.

### Chapter Overview

This chapter covers:

1. **Dispersion Analysis** (@sec-highorder-dispersion): Understanding how
   numerical schemes affect wave propagation
2. **The Fornberg Algorithm** (@sec-highorder-fornberg): Computing finite
   difference weights for arbitrary accuracy orders
3. **Dispersion-Relation-Preserving Schemes** (@sec-highorder-drp): Optimized
   coefficients that minimize dispersion error
4. **Implementation in Devito** (@sec-highorder-devito): Using custom weights
   in Devito solvers
5. **Comparison Studies** (@sec-highorder-comparison): Quantitative comparison
   of standard versus DRP schemes


## Dispersion Analysis {#sec-highorder-dispersion}

To understand numerical dispersion, we analyze how finite difference schemes
affect the relationship between frequency and wavenumber---the *dispersion
relation*.

### The Continuous Wave Equation

Consider the 1D acoustic wave equation:
$$
\frac{\partial^2 u}{\partial t^2} = c^2 \frac{\partial^2 u}{\partial x^2}
$$ {#eq-highorder-wave}

where $c$ is the wave speed. Substituting a plane wave solution
$u(x, t) = e^{i(kx - \omega t)}$ yields the *analytical dispersion relation*:
$$
\omega = c k
$$ {#eq-highorder-dispersion-analytic}

This means all frequency components travel at the same speed $c$,
preserving the wave shape.

### Phase and Group Velocity

The *phase velocity* $v_p$ describes how individual wave crests move:
$$
v_p = \frac{\omega}{k}
$$ {#eq-highorder-phase-velocity}

For the continuous wave equation, $v_p = c$ for all wavenumbers.

The *group velocity* $v_g$ describes how energy (or wave packets) propagates:
$$
v_g = \frac{d\omega}{dk}
$$ {#eq-highorder-group-velocity}

For non-dispersive media, $v_g = v_p = c$.

### The Numerical Dispersion Relation

When we discretize @eq-highorder-wave using central differences in space
and time, the discretized equation is:
$$
\frac{u_i^{n+1} - 2u_i^n + u_i^{n-1}}{\Delta t^2} = c^2 \sum_{m=-M}^{M} a_m \frac{u_{i+m}^n}{h^2}
$$ {#eq-highorder-discrete-wave}

where $h$ is the grid spacing, $\Delta t$ is the time step, and $a_m$ are
the finite difference weights for the second derivative.

Substituting the plane wave $u_i^n = e^{i(k i h - \omega n \Delta t)}$ gives
the *numerical dispersion relation*:
$$
\frac{2(1 - \cos(\omega \Delta t))}{\Delta t^2} = \frac{c^2}{h^2} \sum_{m=-M}^{M} a_m e^{i m k h}
$$ {#eq-highorder-numerical-dispersion}

For symmetric stencils ($a_{-m} = a_m$), this simplifies to:
$$
\frac{2(1 - \cos(\omega \Delta t))}{\Delta t^2} = \frac{c^2}{h^2} \left[ a_0 + 2\sum_{m=1}^{M} a_m \cos(mkh) \right]
$$

### The Velocity Error Ratio

To quantify numerical dispersion, we compute the ratio of the numerical
phase velocity to the analytical phase velocity. Following Chen, Peng,
and Li [@chen2022framework], the *velocity error ratio* is:
$$
\delta = \frac{v_{FD}}{c} = \frac{1}{r\beta} \arccos\left(1 + r^2 \left[ \sum_{m=1}^{M} a_m (\cos(m\beta\cos\alpha) + \cos(m\beta\sin\alpha) - 2) \right] \right)
$$ {#eq-highorder-velocity-ratio}

where:

- $r = c \Delta t / h$ is the Courant number
- $\beta = k h$ is the normalized wavenumber
- $\alpha$ is the propagation angle (in 2D/3D)

When $\delta = 1$, the numerical scheme is exact. Values $\delta \neq 1$
indicate dispersion error.

### Python Implementation

```python
import numpy as np

def dispersion_ratio(weights, h, dt, v, k, alpha=0):
    """
    Compute the velocity error ratio for a finite difference scheme.

    Parameters
    ----------
    weights : array_like
        Symmetric FD weights [a_0, a_1, ..., a_M] for the second derivative
    h : float
        Grid spacing
    dt : float
        Time step
    v : float
        Wave velocity
    k : float
        Wavenumber
    alpha : float
        Propagation angle (radians), default 0 for 1D

    Returns
    -------
    float
        Velocity error ratio v_FD / v
    """
    if k == 0:
        return 1.0

    m = len(weights)
    # Sum over m = 1 to M
    cosines = np.array([
        np.cos(i * k * h * np.cos(alpha)) +
        np.cos(i * k * h * np.sin(alpha)) - 2
        for i in range(1, m)
    ])
    total = np.sum(np.array(weights)[1:] * cosines)

    # Compute the argument of arccos
    arg = 1 + (v**2 * dt**2 / h**2) * total

    # Clamp to valid range for arccos
    arg = np.clip(arg, -1, 1)

    ratio = np.arccos(arg) / (v * k * dt)
    return ratio
```

### Dispersion Behavior

For standard Taylor-series-derived stencils, the dispersion error:

1. **Increases with $\beta = kh$**: Shorter wavelengths (relative to grid
   spacing) experience more dispersion
2. **Varies with Courant number**: Different velocities within the model
   produce different dispersion characteristics
3. **Depends on propagation direction**: In 2D/3D, waves aligned with grid
   axes experience different dispersion than diagonal propagation

The goal of high-order and DRP schemes is to minimize this dispersion error
across the relevant range of wavenumbers and Courant numbers.


## The Fornberg Algorithm {#sec-highorder-fornberg}

The Fornberg algorithm [@fornberg1988generation] computes finite difference
weights of arbitrary accuracy on arbitrary point distributions. This is the
standard method for generating Taylor-series-optimal coefficients.

### Derivation of FD Weights

For a function $f(x)$ sampled at points $x_0, x_1, \ldots, x_N$, we seek
weights $w_j$ such that:
$$
f^{(m)}(x_0) \approx \sum_{j=0}^{N} w_j f(x_j)
$$ {#eq-highorder-fd-weights}

approximates the $m$-th derivative at $x_0$ with maximum accuracy.

The weights are determined by requiring the approximation to be exact for
polynomials up to degree $N$. For equally spaced points, a stencil with
$2M+1$ points ($M$ on each side of the center) achieves accuracy $O(h^{2M})$
for the second derivative.

### Standard Stencil Coefficients

The second derivative with a $(2M+1)$-point symmetric stencil:
$$
\frac{d^2 f}{dx^2} \approx \frac{1}{h^2} \sum_{m=-M}^{M} a_m f(x + mh)
$$ {#eq-highorder-stencil}

The Fornberg algorithm gives these weights for common stencil sizes:

| Stencil Size | $a_0$ | $a_{\pm 1}$ | $a_{\pm 2}$ | $a_{\pm 3}$ | $a_{\pm 4}$ | Order |
|--------------|-------|-------------|-------------|-------------|-------------|-------|
| 3-point | $-2$ | $1$ | | | | $O(h^2)$ |
| 5-point | $-5/2$ | $4/3$ | $-1/12$ | | | $O(h^4)$ |
| 7-point | $-49/18$ | $3/2$ | $-3/20$ | $1/90$ | | $O(h^6)$ |
| 9-point | $-205/72$ | $8/5$ | $-1/5$ | $8/315$ | $-1/560$ | $O(h^8)$ |

### SymPy Implementation

SymPy provides the Fornberg algorithm via `finite_diff_weights`:

```python
import sympy as sp
import numpy as np

def fornberg_weights(M, derivative=2):
    """
    Compute Fornberg FD weights for a symmetric stencil.

    Parameters
    ----------
    M : int
        Number of points on each side of center (total 2M+1 points)
    derivative : int
        Order of derivative (default 2)

    Returns
    -------
    np.ndarray
        Symmetric weights [a_0, a_1, ..., a_M]
    """
    # Generate points: 0, 1, -1, 2, -2, ..., M, -M
    x = [(1 - (-1)**n * (2*n + 1)) // 4 for n in range(2*M + 1)]

    # Compute weights using Fornberg's algorithm
    weights = sp.finite_diff_weights(derivative, x, 0)

    # Extract weights for the requested derivative
    # The result is nested: weights[derivative][-1] gives the full stencil
    full_weights = weights[derivative][-1]

    # Convert to symmetric form [a_0, a_1, ..., a_M]
    # Points are ordered: 0, 1, -1, 2, -2, ...
    # We take every other weight starting from index 0
    symmetric = np.array([float(full_weights[i]) for i in range(0, 2*M+1, 2)])

    return symmetric


# Example: 9-point stencil (M=4)
weights = fornberg_weights(M=4)
print(f"9-point stencil weights: {weights}")
# Output: [-2.84722222  1.6        -0.2         0.02539683 -0.00178571]
```

### Truncation Error Analysis

For the second derivative approximated by a $(2M+1)$-point stencil, the
truncation error is:
$$
\frac{d^2 f}{dx^2} = \frac{1}{h^2} \sum_{m=-M}^{M} a_m f(x + mh) + O(h^{2M})
$$ {#eq-highorder-truncation}

The leading error term involves the $(2M+2)$-th derivative of $f$. Higher-order
stencils:

1. Reduce truncation error for smooth solutions
2. Require more points per stencil (wider data dependencies)
3. May have stability constraints on the time step


## Dispersion-Relation-Preserving Schemes {#sec-highorder-drp}

Dispersion-Relation-Preserving (DRP) schemes optimize the finite difference
coefficients to minimize dispersion error rather than maximize Taylor series
accuracy. This approach, pioneered by Tam and Webb [@tam1993drp], can
significantly outperform standard schemes for wave propagation.

### The Optimization Approach

Standard Fornberg coefficients minimize truncation error in a Taylor series
sense. DRP schemes instead minimize a measure of dispersion error over a
range of wavenumbers.

For a symmetric stencil, the coefficients must satisfy:

**Constraint 1** (Consistency):
$$
a_0 + 2\sum_{m=1}^{M} a_m = 0
$$

**Constraint 2** (Second-order minimum accuracy):
$$
\sum_{m=1}^{M} a_m m^2 = 1
$$

**Additional constraints** (Higher-order accuracy):
$$
\frac{2}{(2n)!}\sum_{m=0}^{M} a_m m^{2n} = 0 \quad \text{for } n = 2, \ldots, \lfloor M/2 \rfloor
$$

With these constraints, the system is underdetermined, leaving degrees of
freedom to optimize for dispersion.

### Tam-Webb DRP Objective Function

Tam and Webb minimize the $L^2$ norm of the error in Fourier space:
$$
\Phi(a_m) = \int_0^{\pi/2} \left| \varphi^2 + a_0 + 2\sum_{m=1}^{M} a_m \cos(m\varphi) \right|^2 d\varphi
$$ {#eq-highorder-tamwebb-objective}

where $\varphi = kh$ is the normalized wavenumber. The term $\varphi^2$
represents the exact second derivative in Fourier space; the stencil terms
approximate it.

### Velocity-Based DRP Objective

An alternative approach [@chen2022framework] directly minimizes the velocity
error integrated over the relevant wavenumber and velocity ranges:
$$
\hat{\Phi}(a_m) = \int_{v_{min}}^{v_{max}} \int_0^{k_{max}(v)} \int_0^{\pi/4} |v_{FD} - v| \, d\alpha \, dk \, dv
$$ {#eq-highorder-chen-objective}

This directly targets the physical quantity of interest (velocity error)
rather than a proxy (Fourier space error).

### Python Implementation of DRP Optimization

```python
import numpy as np
from scipy import optimize, integrate

def drp_objective_tamwebb(a, M):
    """
    Tam-Webb DRP objective function.

    Parameters
    ----------
    a : array_like
        Coefficients [a_0, a_1, ..., a_M]
    M : int
        Stencil half-width

    Returns
    -------
    float
        Objective function value
    """
    x = np.linspace(0, np.pi/2, 201)
    m = np.arange(1, M + 1)

    # Fourier representation of the stencil
    stencil_fourier = a[0] + 2 * np.sum(
        [a[i] * np.cos(i * x) for i in range(1, M + 1)],
        axis=0
    )

    # Error: should equal -x^2 for exact second derivative
    error = x**2 + stencil_fourier

    # Integrate squared error
    return integrate.trapezoid(error**2, x=x)


def compute_drp_weights(M, method='tamwebb'):
    """
    Compute DRP-optimized finite difference weights.

    Parameters
    ----------
    M : int
        Stencil half-width (total 2M+1 points)
    method : str
        Optimization method: 'tamwebb' or 'velocity'

    Returns
    -------
    np.ndarray
        Optimized weights [a_0, a_1, ..., a_M]
    """
    # Initial guess: Fornberg weights
    initial = fornberg_weights(M)

    # Constraints
    constraints = []

    # Constraint 1: a_0 + 2*sum(a_m) = 0
    constraints.append({
        'type': 'eq',
        'fun': lambda x: x[0] + 2 * np.sum(x[1:])
    })

    # Constraint 2: sum(a_m * m^2) = 1
    constraints.append({
        'type': 'eq',
        'fun': lambda x: np.sum([x[i] * i**2 for i in range(len(x))]) - 1
    })

    # Higher-order constraints (for n = 2 to M//2)
    for n in range(2, (M + 1) // 2):
        def constraint(x, n=n):
            return np.sum([x[i] * i**(2*n) for i in range(len(x))])
        constraints.append({'type': 'eq', 'fun': constraint})

    # Optimize
    if method == 'tamwebb':
        objective = lambda a: drp_objective_tamwebb(a, M)
    else:
        raise ValueError(f"Unknown method: {method}")

    result = optimize.minimize(
        objective,
        initial,
        method='SLSQP',
        constraints=constraints,
        options={'ftol': 1e-15, 'maxiter': 500}
    )

    if not result.success:
        print(f"Warning: Optimization did not converge: {result.message}")

    return result.x
```

### Pre-computed DRP Coefficients

For convenience, here are optimized DRP coefficients for common stencil sizes:

```python
# Pre-computed DRP coefficients for the second derivative
DRP_COEFFICIENTS = {
    # 9-point stencil (M=4) - Tam-Webb optimized
    4: np.array([-2.94199219, 1.67723453, -0.24123423, 0.03838539, -0.00362139]),

    # 7-point stencil (M=3) - Tam-Webb optimized
    3: np.array([-2.79926470, 1.57407407, -0.18518519, 0.01851852]),

    # 5-point stencil (M=2)
    2: np.array([-2.5, 1.33333333, -0.08333333]),
}
```

### Comparison: Fornberg vs DRP

The key difference between Fornberg and DRP coefficients:

| Property | Fornberg | DRP |
|----------|----------|-----|
| Optimization target | Taylor series truncation | Dispersion error |
| Accuracy at low $kh$ | Optimal | Near-optimal |
| Accuracy at high $kh$ | Degrades | Better maintained |
| Best for | General purposes | Wave propagation |


## Implementation in Devito {#sec-highorder-devito}

Devito supports custom finite difference weights through the `weights`
keyword argument to derivative methods. This allows straightforward
implementation of DRP schemes.

### Using Custom Weights in Devito

The basic pattern for applying custom weights:

```python
from devito import Grid, TimeFunction, Eq, Operator, solve
import numpy as np

# Custom DRP weights for 9-point stencil
weights = np.array([
    -2.94199219, 1.67723453, -0.24123423, 0.03838539, -0.00362139
])

# Devito expects the full symmetric stencil: [a_M, ..., a_1, a_0, a_1, ..., a_M]
full_weights = np.concatenate([weights[::-1], weights[1:]])

# Create grid and field
grid = Grid(shape=(201, 201), extent=(2000., 2000.))
u = TimeFunction(name='u', grid=grid, time_order=2, space_order=8)

# Use custom weights for the second derivative
u_xx_custom = u.dx2(weights=full_weights)
u_yy_custom = u.dy2(weights=full_weights)

print(f"Custom Laplacian: {u_xx_custom + u_yy_custom}")
```

### Complete 2D Wave Solver with DRP Scheme

```python
from devito import (
    Grid, TimeFunction, Function, SparseTimeFunction,
    Eq, Operator, solve
)
import numpy as np

def ricker_wavelet(t, f0=30, A=1):
    """Ricker wavelet source function."""
    tau = (np.pi * f0 * (t - 1/f0))**2
    return A * (1 - 2*tau) * np.exp(-tau)


def solve_wave_2d_drp(
    extent=(2000., 2000.),
    shape=(201, 201),
    velocity=1500.,
    f0=30.,
    t_end=0.6,
    dt=0.0008,
    source_location=None,
    use_drp=True,
    space_order=8
):
    """
    Solve 2D acoustic wave equation with optional DRP scheme.

    Parameters
    ----------
    extent : tuple
        Domain size (Lx, Ly) in meters
    shape : tuple
        Grid shape (Nx, Ny)
    velocity : float or ndarray
        Wave velocity in m/s
    f0 : float
        Source peak frequency in Hz
    t_end : float
        Simulation end time in seconds
    dt : float
        Time step in seconds
    source_location : tuple, optional
        Source (x, y) coordinates. Default: center of domain
    use_drp : bool
        If True, use DRP coefficients; else use standard Fornberg
    space_order : int
        Spatial order (must be even; stencil has space_order+1 points)

    Returns
    -------
    u : TimeFunction
        Final wavefield
    """
    # DRP weights for 9-point stencil (space_order=8)
    drp_weights = np.array([
        -2.94199219, 1.67723453, -0.24123423, 0.03838539, -0.00362139
    ])

    # Fornberg weights for comparison
    fornberg_weights = np.array([
        -205/72, 8/5, -1/5, 8/315, -1/560
    ])

    # Select weights
    if use_drp:
        weights = drp_weights
    else:
        weights = fornberg_weights

    # Full symmetric stencil
    full_weights = np.concatenate([weights[::-1], weights[1:]])

    # Create grid
    grid = Grid(shape=shape, extent=extent)
    x, y = grid.dimensions

    # Create wavefield
    u = TimeFunction(name='u', grid=grid, time_order=2, space_order=space_order)

    # Velocity model (can be heterogeneous)
    vel = Function(name='vel', grid=grid, space_order=space_order)
    if np.isscalar(velocity):
        vel.data[:] = velocity
    else:
        vel.data[:] = velocity

    # Source setup
    nt = int(t_end / dt) + 1
    t_values = np.linspace(0, t_end, nt)

    if source_location is None:
        source_location = (extent[0]/2, extent[1]/2)

    source = SparseTimeFunction(
        name='src',
        grid=grid,
        npoint=1,
        nt=nt,
        coordinates=[source_location]
    )
    source.data[:, 0] = ricker_wavelet(t_values, f0=f0)

    # Wave equation with custom weights
    # PDE: u_tt = c^2 * (u_xx + u_yy)
    laplacian = u.dx2(weights=full_weights) + u.dy2(weights=full_weights)
    pde = u.dt2 - vel**2 * laplacian
    stencil = Eq(u.forward, solve(pde, u.forward))

    # Source injection
    src_term = source.inject(field=u.forward, expr=source * dt**2 * vel**2)

    # Build and run operator
    op = Operator([stencil] + src_term, subs=grid.spacing_map)
    op(time=nt-1, dt=dt)

    return u


# Example usage
if __name__ == "__main__":
    # Run with DRP scheme
    u_drp = solve_wave_2d_drp(use_drp=True)
    print(f"DRP wavefield norm: {np.linalg.norm(u_drp.data[-1]):.4f}")

    # Run with standard scheme
    u_std = solve_wave_2d_drp(use_drp=False)
    print(f"Standard wavefield norm: {np.linalg.norm(u_std.data[-1]):.4f}")
```

### Using Subdomains for Variable Coefficients

In heterogeneous media, different regions may benefit from different
stencils. Devito's `SubDomain` feature allows this:

```python
from devito import SubDomain

class UpperLayer(SubDomain):
    name = 'upper'
    def define(self, dimensions):
        x, z = dimensions
        return {x: x, z: ('left', 100)}  # Top 100 points

class LowerLayer(SubDomain):
    name = 'lower'
    def define(self, dimensions):
        x, z = dimensions
        return {x: x, z: ('right', 100)}  # Bottom 100 points

# Create stencils for each subdomain
stencil_upper = Eq(u.forward, ..., subdomain=upper)
stencil_lower = Eq(u.forward, ..., subdomain=lower)

op = Operator([stencil_upper, stencil_lower] + src_term)
```


## Comparison: Standard vs DRP Schemes {#sec-highorder-comparison}

This section presents quantitative comparisons between standard Fornberg
and DRP schemes.

### Dispersion Error Comparison

```python
import numpy as np
import matplotlib.pyplot as plt

def compare_dispersion(h=7.14, dt=0.0008, velocities=[1500, 3000, 5500]):
    """
    Compare dispersion properties of Fornberg and DRP stencils.
    """
    # Weights
    fornberg = np.array([-205/72, 8/5, -1/5, 8/315, -1/560])
    drp = np.array([-2.94199219, 1.67723453, -0.24123423, 0.03838539, -0.00362139])

    # Wavenumber range
    beta = np.linspace(0, np.pi, 200)  # normalized wavenumber kh

    fig, axes = plt.subplots(1, len(velocities), figsize=(12, 4))

    for ax, v in zip(axes, velocities):
        # Compute dispersion ratio for each scheme
        ratio_fornberg = []
        ratio_drp = []

        for b in beta:
            k = b / h
            r_f = dispersion_ratio(fornberg, h, dt, v, k)
            r_d = dispersion_ratio(drp, h, dt, v, k)
            ratio_fornberg.append(r_f)
            ratio_drp.append(r_d)

        ax.plot(beta, ratio_fornberg, label='Fornberg', linestyle='-')
        ax.plot(beta, ratio_drp, label='DRP', linestyle='--')
        ax.axhline(y=1, color='k', linestyle=':', linewidth=0.5)
        ax.set_xlabel(r'$\beta = kh$')
        ax.set_ylabel('Velocity ratio')
        ax.set_title(f'v = {v} m/s')
        ax.legend()
        ax.set_ylim([0.8, 1.2])
        ax.set_xlim([0, np.pi])

    plt.tight_layout()
    return fig


# Generate comparison plot
fig = compare_dispersion()
plt.savefig('dispersion_comparison.png', dpi=150)
```

### Wavefield Comparison

The most compelling demonstration of DRP benefits is visual comparison
of wavefields:

```python
import matplotlib.pyplot as plt

# Run simulations
u_standard = solve_wave_2d_drp(use_drp=False, t_end=0.5)
u_drp = solve_wave_2d_drp(use_drp=True, t_end=0.5)

# Plot comparison
fig, axes = plt.subplots(1, 3, figsize=(15, 5))

# Standard scheme
im1 = axes[0].imshow(
    u_standard.data[-1].T,
    cmap='seismic',
    vmin=-0.5, vmax=0.5,
    extent=[0, 2000, 2000, 0]
)
axes[0].set_title('Standard (Fornberg)')
axes[0].set_xlabel('x (m)')
axes[0].set_ylabel('z (m)')

# DRP scheme
im2 = axes[1].imshow(
    u_drp.data[-1].T,
    cmap='seismic',
    vmin=-0.5, vmax=0.5,
    extent=[0, 2000, 2000, 0]
)
axes[1].set_title('DRP Scheme')
axes[1].set_xlabel('x (m)')

# Difference
diff = u_drp.data[-1] - u_standard.data[-1]
im3 = axes[2].imshow(
    diff.T,
    cmap='seismic',
    extent=[0, 2000, 2000, 0]
)
axes[2].set_title('Difference (DRP - Standard)')
axes[2].set_xlabel('x (m)')

plt.tight_layout()
plt.savefig('wavefield_comparison.png', dpi=150)
```

### Quantitative Error Metrics

For a systematic comparison, we compute:

1. **Maximum dispersion error** over the relevant wavenumber range
2. **Computational cost** (similar for same stencil size)
3. **Stability limit** (CFL condition)

```python
def compute_max_dispersion_error(weights, h, dt, v, k_max):
    """
    Compute maximum dispersion error over wavenumber range.
    """
    k_range = np.linspace(0, k_max, 100)
    errors = []

    for k in k_range:
        ratio = dispersion_ratio(weights, h, dt, v, k)
        errors.append(abs(ratio - 1))

    return np.max(errors)


def critical_dt(weights, h=7.14, v_max=5500):
    """
    Compute critical time step for stability.

    Parameters
    ----------
    weights : array_like
        Stencil weights [a_0, a_1, ..., a_M]
    h : float
        Grid spacing
    v_max : float
        Maximum velocity

    Returns
    -------
    float
        Critical time step
    """
    sum_abs = np.sum(np.abs(weights))
    return h * np.sqrt(2 / sum_abs) / v_max


# Compare critical time steps
fornberg = np.array([-205/72, 8/5, -1/5, 8/315, -1/560])
drp = np.array([-2.94199219, 1.67723453, -0.24123423, 0.03838539, -0.00362139])

print(f"Critical dt (Fornberg): {critical_dt(fornberg):.6f} s")
print(f"Critical dt (DRP): {critical_dt(drp):.6f} s")
```

### When to Use DRP Schemes

DRP schemes are most beneficial when:

1. **Long propagation distances**: Dispersion errors accumulate over time
2. **High-frequency content**: Wavelengths approaching grid spacing
3. **Heterogeneous media**: Multiple reflections amplify dispersion
4. **Seismic imaging**: Accurate phase information is critical

Standard Fornberg schemes may be preferred when:

1. **Memory is limited**: DRP offers no advantage for the same stencil size
2. **Short propagation times**: Dispersion hasn't accumulated significantly
3. **Low-frequency content**: Long wavelengths well-resolved on the grid


## CFL Stability Condition {#sec-highorder-cfl}

The CFL (Courant-Friedrichs-Lewy) condition places an upper bound on the
time step for explicit time integration. For the acoustic wave equation:
$$
\Delta t \leq \frac{h}{v_{max}} \sqrt{\frac{\sum |a_{time}|}{d \sum |a_{space}|}}
$$ {#eq-highorder-cfl}

where:

- $d$ is the number of spatial dimensions
- $a_{time}$ are the time discretization weights (for second-order: $[1, -2, 1]$)
- $a_{space}$ are the spatial stencil weights
- $v_{max}$ is the maximum velocity in the model

For second-order time integration, $\sum |a_{time}| = 4$.

### CFL for Standard and DRP Stencils

```python
def cfl_number(weights, d=2):
    """
    Compute the CFL factor for a given stencil.

    The critical time step is: dt <= h / v_max * cfl_factor
    """
    sum_abs_space = np.sum(np.abs(weights))
    sum_abs_time = 4  # Second-order time: |1| + |-2| + |1|
    return np.sqrt(sum_abs_time / (d * sum_abs_space))


# Compare CFL factors
print(f"CFL factor (Fornberg): {cfl_number(fornberg):.4f}")
print(f"CFL factor (DRP): {cfl_number(drp):.4f}")
```

Note that DRP coefficients typically have slightly larger magnitudes than
Fornberg coefficients, resulting in a marginally smaller critical time step.


## Exercises {#sec-highorder-exercises}

### Exercise 1: Dispersion Analysis

Implement the `dispersion_ratio` function and create plots showing:

a) The velocity error ratio as a function of normalized wavenumber $\beta = kh$
   for the 5-point, 7-point, and 9-point Fornberg stencils.

b) How the dispersion error changes with Courant number $r = c\Delta t/h$.

c) Compare your results with the theoretical prediction that higher-order
   stencils have smaller dispersion errors for a given $\beta$.

### Exercise 2: DRP Optimization

Using `scipy.optimize.minimize` with the SLSQP method:

a) Implement the Tam-Webb objective function and compute DRP weights for
   a 7-point stencil.

b) Verify that your optimized weights satisfy the consistency constraints.

c) Compare the Fourier space representation of your DRP stencil with the
   Fornberg stencil. Plot $-a_0 - 2\sum a_m \cos(m\varphi)$ versus $\varphi^2$.

### Exercise 3: 1D Wave Propagation

Create a 1D wave propagation test:

a) Implement a 1D wave solver with both Fornberg and DRP schemes.

b) Initialize with a Ricker wavelet and propagate for several domain lengths.

c) Compare the waveforms at the final time. Quantify the dispersion-induced
   "tail" behind the main pulse.

### Exercise 4: 2D Heterogeneous Medium

Extend the 2D solver to a two-layer velocity model:

a) Set $v_1 = 1500$ m/s for $z < 1200$ m and $v_2 = 4000$ m/s for $z \geq 1200$ m.

b) Use Devito's `SubDomain` feature to apply different stencils in each layer.

c) Compare wavefields from standard and DRP schemes. Pay particular attention
   to the transmitted and reflected waves at the interface.

### Exercise 5: Stability Analysis

Investigate the CFL condition:

a) For the 9-point DRP stencil, compute the critical time step for
   $h = 10$ m and $v_{max} = 4500$ m/s.

b) Run simulations at 90%, 100%, and 110% of the critical time step.
   Observe and document the stability behavior.

c) Explain why the simulation becomes unstable above the critical time step.

### Exercise 6: Computational Cost

Compare computational efficiency:

a) Time the execution of Fornberg and DRP schemes for the same problem.
   Are they comparable?

b) Now compare a 9-point DRP scheme with a 13-point Fornberg scheme that
   achieves similar dispersion properties. Which is more efficient?

c) Discuss the trade-offs between stencil width and dispersion accuracy.


## Summary {#sec-highorder-summary}

This chapter introduced high-order finite difference methods and their
application to wave propagation in Devito.

### Key Concepts

1. **Numerical dispersion** causes different frequency components to travel
   at different speeds, distorting wave shapes over time.

2. **The Fornberg algorithm** generates finite difference weights that
   maximize Taylor series accuracy.

3. **DRP schemes** optimize weights to minimize dispersion error, often
   outperforming Fornberg weights of the same stencil size for wave problems.

4. **Devito's custom weights** feature enables easy implementation of any
   finite difference scheme, including DRP.

### Practical Guidelines

- **For general PDEs**: Use Devito's default Fornberg weights with
  appropriate `space_order`.

- **For wave propagation**: Consider DRP weights, especially for long
  simulations or high-frequency content.

- **Always verify stability**: Compute the CFL limit for your chosen
  weights and ensure $\Delta t$ is below it.

- **Profile before optimizing**: Standard schemes may be sufficient for
  many applications; measure dispersion error before switching to DRP.

### Looking Ahead

The techniques in this chapter apply to:

- **Seismic imaging**: Full waveform inversion, reverse-time migration
- **Computational acoustics**: Room acoustics, outdoor sound propagation
- **Electromagnetic simulation**: Maxwell's equations in FDTD form

Each application may benefit from domain-specific optimizations of the
finite difference coefficients.


## References {.unnumbered}

::: {#refs}
:::
